<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nutcracker: flat_set.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>flat_set.hpp</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00002"></a>00002 <span class="comment">//</span>
<a name="l00003"></a>00003 <span class="comment">// (C) Copyright Ion Gaztanaga 2005-2009. Distributed under the Boost</span>
<a name="l00004"></a>00004 <span class="comment">// Software License, Version 1.0. (See accompanying file</span>
<a name="l00005"></a>00005 <span class="comment">// LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)</span>
<a name="l00006"></a>00006 <span class="comment">//</span>
<a name="l00007"></a>00007 <span class="comment">// See http://www.boost.org/libs/container for documentation.</span>
<a name="l00008"></a>00008 <span class="comment">//</span>
<a name="l00010"></a>00010 <span class="comment"></span>
<a name="l00011"></a>00011 <span class="preprocessor">#ifndef BOOST_CONTAINERS_FLAT_SET_HPP</span>
<a name="l00012"></a>00012 <span class="preprocessor"></span><span class="preprocessor">#define BOOST_CONTAINERS_FLAT_SET_HPP</span>
<a name="l00013"></a>00013 <span class="preprocessor"></span>
<a name="l00014"></a>00014 <span class="preprocessor">#if (defined _MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200)</span>
<a name="l00015"></a>00015 <span class="preprocessor"></span><span class="preprocessor">#  pragma once</span>
<a name="l00016"></a>00016 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00017"></a>00017 <span class="preprocessor"></span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &quot;detail/config_begin.hpp&quot;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_WORKAROUND_HPP</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span>
<a name="l00021"></a>00021 <span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_CONTAINER_FWD_HPP</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span><span class="preprocessor">#include &lt;utility&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;functional&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;memory&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_FLAT_TREE_HPP</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span><span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_MPL_HPP</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span><span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_MOVE_HPP</span>
<a name="l00028"></a>00028 <span class="preprocessor"></span>
<a name="l00029"></a>00029 <span class="preprocessor">#ifdef BOOST_CONTAINER_DOXYGEN_INVOKED</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span><span class="keyword">namespace </span>boost {
<a name="l00031"></a>00031 <span class="keyword">namespace </span>container {
<a name="l00032"></a>00032 <span class="preprocessor">#else</span>
<a name="l00033"></a>00033 <span class="preprocessor"></span><span class="keyword">namespace </span>boost {
<a name="l00034"></a>00034 <span class="keyword">namespace </span>container {
<a name="l00035"></a>00035 <span class="preprocessor">#endif</span>
<a name="l00036"></a>00036 <span class="preprocessor"></span>
<a name="l00038"></a>00038 <span class="comment">// Forward declarations of operators &lt; and ==, needed for friend declaration.</span>
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00041"></a>00041 <span class="keyword">class </span>flat_set;
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00044"></a>00044 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> flat_set&lt;T,Pred,Alloc&gt;&amp; x, 
<a name="l00045"></a>00045                        <span class="keyword">const</span> flat_set&lt;T,Pred,Alloc&gt;&amp; y);
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00048"></a>00048 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&lt;(const flat_set&lt;T,Pred,Alloc&gt;&amp; x, 
<a name="l00049"></a>00049                       <span class="keyword">const</span> flat_set&lt;T,Pred,Alloc&gt;&amp; y);
<a name="l00051"></a>00051 
<a name="l00063"></a>00063 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00064"></a><a class="code" href="classboost_1_1container_1_1flat__set.html">00064</a> <span class="keyword">class </span><a class="code" href="classboost_1_1container_1_1flat__set.html">flat_set</a> 
<a name="l00065"></a>00065 {
<a name="l00067"></a>00067    <span class="keyword">private</span>:
<a name="l00068"></a>00068    BOOST_MOVE_MACRO_COPYABLE_AND_MOVABLE(<a class="code" href="classboost_1_1container_1_1flat__set.html">flat_set</a>)
<a name="l00069"></a>00069    <span class="keyword">typedef</span> <a class="code" href="classboost_1_1container_1_1containers__detail_1_1flat__tree.html">containers_detail::flat_tree&lt;T, T, containers_detail::identity&lt;T&gt;</a>, Pred, Alloc&gt; tree_t;
<a name="l00070"></a>00070    tree_t m_flat_tree;  <span class="comment">// flat tree representing flat_set</span>
<a name="l00071"></a>00071    <span class="keyword">typedef</span> <span class="keyword">typename</span> containers_detail::
<a name="l00072"></a>00072       move_const_ref_type&lt;T&gt;::type insert_const_ref_type;
<a name="l00074"></a>00074 
<a name="l00075"></a>00075    <span class="keyword">public</span>:
<a name="l00076"></a>00076 
<a name="l00077"></a>00077    <span class="comment">// typedefs:</span>
<a name="l00078"></a>00078    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::key_type               key_type;
<a name="l00079"></a>00079    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::value_type             value_type;
<a name="l00080"></a>00080    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::pointer                pointer;
<a name="l00081"></a>00081    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::const_pointer          const_pointer;
<a name="l00082"></a>00082    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::reference              reference;
<a name="l00083"></a>00083    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::const_reference        const_reference;
<a name="l00084"></a>00084    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::key_compare            key_compare;
<a name="l00085"></a>00085    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::value_compare          value_compare;
<a name="l00086"></a>00086    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::iterator               iterator;
<a name="l00087"></a>00087    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::const_iterator         const_iterator;
<a name="l00088"></a>00088    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::reverse_iterator       reverse_iterator;
<a name="l00089"></a>00089    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::const_reverse_iterator const_reverse_iterator;
<a name="l00090"></a>00090    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::size_type              size_type;
<a name="l00091"></a>00091    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::difference_type        difference_type;
<a name="l00092"></a>00092    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::allocator_type         allocator_type;
<a name="l00093"></a>00093    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::stored_allocator_type  stored_allocator_type;
<a name="l00094"></a>00094 
<a name="l00099"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a535509ab9600ea2a3e796446a93c861b">00099</a>    <span class="keyword">explicit</span> <a class="code" href="classboost_1_1container_1_1flat__set.html">flat_set</a>(<span class="keyword">const</span> Pred&amp; comp = Pred(),
<a name="l00100"></a>00100                      <span class="keyword">const</span> allocator_type&amp; a = allocator_type())
<a name="l00101"></a>00101       : m_flat_tree(comp, a)
<a name="l00102"></a>00102    {}
<a name="l00103"></a>00103 
<a name="l00109"></a>00109    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
<a name="l00110"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a201be31dba9594bf4e7f4d1ba3e9dd6a">00110</a>    <a class="code" href="classboost_1_1container_1_1flat__set.html">flat_set</a>(InputIterator first, InputIterator last, 
<a name="l00111"></a>00111             <span class="keyword">const</span> Pred&amp; comp = Pred(),
<a name="l00112"></a>00112             <span class="keyword">const</span> allocator_type&amp; a = allocator_type())
<a name="l00113"></a>00113       : m_flat_tree(comp, a) 
<a name="l00114"></a>00114       { m_flat_tree.insert_unique(first, last); }
<a name="l00115"></a>00115 
<a name="l00124"></a>00124    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
<a name="l00125"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#afa58630afb66e0e800a9ea32602132b0">00125</a>    <a class="code" href="classboost_1_1container_1_1flat__set.html">flat_set</a>(ordered_unique_range_t, InputIterator first, InputIterator last, 
<a name="l00126"></a>00126             <span class="keyword">const</span> Pred&amp; comp = Pred(),
<a name="l00127"></a>00127             <span class="keyword">const</span> allocator_type&amp; a = allocator_type())
<a name="l00128"></a>00128       : m_flat_tree(ordered_range, first, last, comp, a) 
<a name="l00129"></a>00129    {}
<a name="l00130"></a>00130 
<a name="l00134"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#ac58f8525191976d28194c8295330a987">00134</a>    <a class="code" href="classboost_1_1container_1_1flat__set.html">flat_set</a>(<span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1flat__set.html">flat_set&lt;T,Pred,Alloc&gt;</a>&amp; x) 
<a name="l00135"></a>00135       : m_flat_tree(x.m_flat_tree) {}
<a name="l00136"></a>00136 
<a name="l00142"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#aee242a47acb2a15e54c1635b0a9cfcc4">00142</a>    <a class="code" href="classboost_1_1container_1_1flat__set.html">flat_set</a>(BOOST_MOVE_MACRO_RV_REF(<a class="code" href="classboost_1_1container_1_1flat__set.html">flat_set</a>) mx) 
<a name="l00143"></a>00143       : m_flat_tree(BOOST_CONTAINER_MOVE_NAMESPACE::move(mx.m_flat_tree))
<a name="l00144"></a>00144    {}
<a name="l00145"></a>00145 
<a name="l00149"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a8f0cd1f353424c1679f29ed841b03d5c">00149</a>    <a class="code" href="classboost_1_1container_1_1flat__set.html">flat_set&lt;T,Pred,Alloc&gt;</a>&amp; operator=(BOOST_MOVE_MACRO_COPY_ASSIGN_REF(<a class="code" href="classboost_1_1container_1_1flat__set.html">flat_set</a>) x)
<a name="l00150"></a>00150       {  m_flat_tree = x.m_flat_tree;   <span class="keywordflow">return</span> *<span class="keyword">this</span>;  }
<a name="l00151"></a>00151 
<a name="l00155"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a9597c3bd119d5937f53e1b8307b581e2">00155</a>    <a class="code" href="classboost_1_1container_1_1flat__set.html">flat_set&lt;T,Pred,Alloc&gt;</a>&amp; operator=(BOOST_MOVE_MACRO_RV_REF(<a class="code" href="classboost_1_1container_1_1flat__set.html">flat_set</a>) mx)
<a name="l00156"></a>00156    {  m_flat_tree = BOOST_CONTAINER_MOVE_NAMESPACE::move(mx.m_flat_tree);   <span class="keywordflow">return</span> *<span class="keyword">this</span>;  }
<a name="l00157"></a>00157 
<a name="l00162"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#aa449391c35739eb33de7d3cb5aa3c2f2">00162</a>    key_compare key_comp()<span class="keyword"> const </span>
<a name="l00163"></a>00163 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.key_comp(); }
<a name="l00164"></a>00164 
<a name="l00169"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a3eba232d843a5f81143885eca8ffa3c3">00169</a>    value_compare value_comp()<span class="keyword"> const </span>
<a name="l00170"></a>00170 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.key_comp(); }
<a name="l00171"></a>00171 
<a name="l00176"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#adcca677c263d38b2fcda950f0f1ab9c3">00176</a>    allocator_type get_allocator()<span class="keyword"> const </span>
<a name="l00177"></a>00177 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.get_allocator(); }
<a name="l00178"></a>00178 
<a name="l00179"></a>00179    <span class="keyword">const</span> stored_allocator_type &amp;get_stored_allocator()<span class="keyword"> const </span>
<a name="l00180"></a>00180 <span class="keyword">   </span>{  <span class="keywordflow">return</span> m_flat_tree.get_stored_allocator(); }
<a name="l00181"></a>00181 
<a name="l00182"></a>00182    stored_allocator_type &amp;get_stored_allocator()
<a name="l00183"></a>00183    {  <span class="keywordflow">return</span> m_flat_tree.get_stored_allocator(); }
<a name="l00184"></a>00184 
<a name="l00190"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a8eed8a14472fa655d1e8aa32c52e91d0">00190</a>    iterator begin() 
<a name="l00191"></a>00191       { <span class="keywordflow">return</span> m_flat_tree.begin(); }
<a name="l00192"></a>00192 
<a name="l00198"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a2ddcc5df7033c7bf11bd66b82c0dd0d5">00198</a>    const_iterator begin()<span class="keyword"> const </span>
<a name="l00199"></a>00199 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.begin(); }
<a name="l00200"></a>00200 
<a name="l00206"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a14578e31d6fbfe352dd1ca6ad32bb1f6">00206</a>    const_iterator cbegin()<span class="keyword"> const </span>
<a name="l00207"></a>00207 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.cbegin(); }
<a name="l00208"></a>00208 
<a name="l00214"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a4c29acd1f82152bacd441e1e9b877a0a">00214</a>    iterator end() 
<a name="l00215"></a>00215       { <span class="keywordflow">return</span> m_flat_tree.end(); }
<a name="l00216"></a>00216 
<a name="l00222"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a67ee52534de83c9b7e142e2c69d58c95">00222</a>    const_iterator end()<span class="keyword"> const </span>
<a name="l00223"></a>00223 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.end(); }
<a name="l00224"></a>00224 
<a name="l00230"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a7b714a4f9315d2257dcaed5f5000341d">00230</a>    const_iterator cend()<span class="keyword"> const </span>
<a name="l00231"></a>00231 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.cend(); }
<a name="l00232"></a>00232 
<a name="l00239"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#ab802a5cad13d07ab8bc732c3769611bb">00239</a>    reverse_iterator rbegin() 
<a name="l00240"></a>00240       { <span class="keywordflow">return</span> m_flat_tree.rbegin(); } 
<a name="l00241"></a>00241 
<a name="l00248"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#aeeec98f10f246214275766554394c16b">00248</a>    const_reverse_iterator rbegin()<span class="keyword"> const </span>
<a name="l00249"></a>00249 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.rbegin(); } 
<a name="l00250"></a>00250 
<a name="l00257"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a36ad5dcbc63a35e684553528bc2597f8">00257</a>    const_reverse_iterator crbegin()<span class="keyword"> const </span>
<a name="l00258"></a>00258 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.crbegin(); } 
<a name="l00259"></a>00259 
<a name="l00266"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a6e132c55eaa01d26689863bb3ce38bb2">00266</a>    reverse_iterator rend()
<a name="l00267"></a>00267       { <span class="keywordflow">return</span> m_flat_tree.rend(); }
<a name="l00268"></a>00268 
<a name="l00275"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a0f8a5ce6c220ab81c11fc93a1854c481">00275</a>    const_reverse_iterator rend()<span class="keyword"> const </span>
<a name="l00276"></a>00276 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.rend(); }
<a name="l00277"></a>00277 
<a name="l00284"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#ae9b6449f53aedf9190853d9f1af3b174">00284</a>    const_reverse_iterator crend()<span class="keyword"> const </span>
<a name="l00285"></a>00285 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.crend(); }
<a name="l00286"></a>00286 
<a name="l00292"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a540d0dac7bd95a1733916ec39582fd0a">00292</a>    <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>
<a name="l00293"></a>00293 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.empty(); }
<a name="l00294"></a>00294 
<a name="l00300"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a15246e67e3ecf879cd924288ee6d1c38">00300</a>    size_type size()<span class="keyword"> const </span>
<a name="l00301"></a>00301 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.size(); }
<a name="l00302"></a>00302 
<a name="l00308"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a5dfcc55653d775efb4026716692f8db8">00308</a>    size_type max_size()<span class="keyword"> const </span>
<a name="l00309"></a>00309 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.max_size(); }
<a name="l00310"></a>00310 
<a name="l00317"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a7685d540a20c778f1b79aa93d160c85a">00317</a>    <span class="keywordtype">void</span> swap(<a class="code" href="classboost_1_1container_1_1flat__set.html">flat_set</a>&amp; x)
<a name="l00318"></a>00318    { m_flat_tree.swap(x.m_flat_tree); }
<a name="l00319"></a>00319 
<a name="l00331"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a334bd7703245f1211d0c968ad3df6da0">00331</a>    std::pair&lt;iterator, bool&gt; insert(insert_const_ref_type x) 
<a name="l00332"></a>00332    {  <span class="keywordflow">return</span> priv_insert(x); }
<a name="l00333"></a>00333 
<a name="l00334"></a>00334 <span class="preprocessor">   #if defined(BOOST_NO_RVALUE_REFERENCES) &amp;&amp; !defined(BOOST_MOVE_DOXYGEN_INVOKED)</span>
<a name="l00335"></a>00335 <span class="preprocessor"></span>   std::pair&lt;iterator, bool&gt; insert(T &amp;x)
<a name="l00336"></a>00336    { <span class="keywordflow">return</span> this-&gt;insert(const_cast&lt;const T &amp;&gt;(x)); }
<a name="l00337"></a>00337 
<a name="l00338"></a>00338    <span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt;
<a name="l00339"></a>00339    std::pair&lt;iterator, bool&gt; insert(<span class="keyword">const</span> U &amp;u, <span class="keyword">typename</span> containers_detail::enable_if_c&lt;containers_detail::is_same&lt;T, U&gt;::value &amp;&amp; !::BOOST_CONTAINER_MOVE_NAMESPACE::is_movable&lt;U&gt;::value &gt;::type* =0)
<a name="l00340"></a>00340    {  <span class="keywordflow">return</span> priv_insert(u); }
<a name="l00341"></a>00341 <span class="preprocessor">   #endif</span>
<a name="l00342"></a>00342 <span class="preprocessor"></span>
<a name="l00354"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a9908d3fcff91bfe736c0dde59512d6fb">00354</a>    std::pair&lt;iterator,bool&gt; insert(BOOST_MOVE_MACRO_RV_REF(value_type) x) 
<a name="l00355"></a>00355    {  <span class="keywordflow">return</span> m_flat_tree.insert_unique(BOOST_CONTAINER_MOVE_NAMESPACE::move(x));  }
<a name="l00356"></a>00356 
<a name="l00368"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#aae0bd60bb99b5a28dbf08dfe10d45ca4">00368</a>    iterator insert(const_iterator p, insert_const_ref_type x) 
<a name="l00369"></a>00369    {  <span class="keywordflow">return</span> priv_insert(p, x); }
<a name="l00370"></a>00370 
<a name="l00371"></a>00371 <span class="preprocessor">   #if defined(BOOST_NO_RVALUE_REFERENCES) &amp;&amp; !defined(BOOST_MOVE_DOXYGEN_INVOKED)</span>
<a name="l00372"></a>00372 <span class="preprocessor"></span>   iterator insert(const_iterator position, T &amp;x)
<a name="l00373"></a>00373    { <span class="keywordflow">return</span> this-&gt;insert(position, const_cast&lt;const T &amp;&gt;(x)); }
<a name="l00374"></a>00374 
<a name="l00375"></a>00375    <span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt;
<a name="l00376"></a>00376    iterator insert(const_iterator position, <span class="keyword">const</span> U &amp;u, <span class="keyword">typename</span> containers_detail::enable_if_c&lt;containers_detail::is_same&lt;T, U&gt;::value &amp;&amp; !::BOOST_CONTAINER_MOVE_NAMESPACE::is_movable&lt;U&gt;::value &gt;::type* =0)
<a name="l00377"></a>00377    {  <span class="keywordflow">return</span> priv_insert(position, u); }
<a name="l00378"></a>00378 <span class="preprocessor">   #endif</span>
<a name="l00379"></a>00379 <span class="preprocessor"></span>
<a name="l00389"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#ab4c42930f12248c9c4bd08446fa312f8">00389</a>    iterator insert(const_iterator position, BOOST_MOVE_MACRO_RV_REF(value_type) x) 
<a name="l00390"></a>00390    {  <span class="keywordflow">return</span> m_flat_tree.insert_unique(position, BOOST_CONTAINER_MOVE_NAMESPACE::move(x)); }
<a name="l00391"></a>00391 
<a name="l00401"></a>00401    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
<a name="l00402"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#ae29cae380c070282300e533611c5c60c">00402</a>    <span class="keywordtype">void</span> insert(InputIterator first, InputIterator last) 
<a name="l00403"></a>00403       {  m_flat_tree.insert_unique(first, last);  }
<a name="l00404"></a>00404 
<a name="l00405"></a>00405 <span class="preprocessor">   #if defined(BOOST_CONTAINERS_PERFECT_FORWARDING) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)</span>
<a name="l00406"></a>00406 <span class="preprocessor"></span>
<a name="l00419"></a>00419    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;
<a name="l00420"></a>00420    iterator emplace(Args&amp;&amp;... args)
<a name="l00421"></a>00421    {  <span class="keywordflow">return</span> m_flat_tree.emplace_unique(BOOST_CONTAINER_MOVE_NAMESPACE::forward&lt;Args&gt;(args)...); }
<a name="l00422"></a>00422 
<a name="l00435"></a>00435    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;
<a name="l00436"></a>00436    iterator emplace_hint(const_iterator hint, Args&amp;&amp;... args)
<a name="l00437"></a>00437    {  <span class="keywordflow">return</span> m_flat_tree.emplace_hint_unique(hint, BOOST_CONTAINER_MOVE_NAMESPACE::forward&lt;Args&gt;(args)...); }
<a name="l00438"></a>00438 
<a name="l00439"></a>00439 <span class="preprocessor">   #else //#ifdef BOOST_CONTAINERS_PERFECT_FORWARDING</span>
<a name="l00440"></a>00440 <span class="preprocessor"></span>
<a name="l00441"></a>00441    iterator emplace()
<a name="l00442"></a>00442    {  <span class="keywordflow">return</span> m_flat_tree.emplace_unique(); }
<a name="l00443"></a>00443 
<a name="l00444"></a>00444    iterator emplace_hint(const_iterator hint)
<a name="l00445"></a>00445    {  <span class="keywordflow">return</span> m_flat_tree.emplace_hint_unique(hint); }
<a name="l00446"></a>00446 
<a name="l00447"></a>00447 <span class="preprocessor">   #define BOOST_PP_LOCAL_MACRO(n)                                                                             \</span>
<a name="l00448"></a>00448 <span class="preprocessor">   template&lt;BOOST_PP_ENUM_PARAMS(n, class P)&gt;                                                                  \</span>
<a name="l00449"></a>00449 <span class="preprocessor">   iterator emplace(BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_LIST, _))                                     \</span>
<a name="l00450"></a>00450 <span class="preprocessor">   {  return m_flat_tree.emplace_unique(BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_FORWARD, _)); }           \</span>
<a name="l00451"></a>00451 <span class="preprocessor">                                                                                                               \</span>
<a name="l00452"></a>00452 <span class="preprocessor">   template&lt;BOOST_PP_ENUM_PARAMS(n, class P)&gt;                                                                  \</span>
<a name="l00453"></a>00453 <span class="preprocessor">   iterator emplace_hint(const_iterator hint, BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_LIST, _))           \</span>
<a name="l00454"></a>00454 <span class="preprocessor">   {  return m_flat_tree.emplace_hint_unique(hint, BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_FORWARD, _)); }\</span>
<a name="l00455"></a>00455 <span class="preprocessor"></span>
<a name="l00456"></a>00456 <span class="preprocessor">   #define BOOST_PP_LOCAL_LIMITS (1, BOOST_CONTAINERS_MAX_CONSTRUCTOR_PARAMETERS)</span>
<a name="l00457"></a>00457 <span class="preprocessor"></span><span class="preprocessor">   #include BOOST_PP_LOCAL_ITERATE()</span>
<a name="l00458"></a>00458 <span class="preprocessor"></span>
<a name="l00459"></a>00459 <span class="preprocessor">   #endif   //#ifdef BOOST_CONTAINERS_PERFECT_FORWARDING</span>
<a name="l00460"></a>00460 <span class="preprocessor"></span>
<a name="l00471"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#aad04961c00775c85243edddd3fb3c155">00471</a>    iterator erase(const_iterator position) 
<a name="l00472"></a>00472       {  <span class="keywordflow">return</span> m_flat_tree.erase(position); }
<a name="l00473"></a>00473 
<a name="l00480"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a07bf9a3d40de196b31caf4bbd9a091bd">00480</a>    size_type erase(<span class="keyword">const</span> key_type&amp; x) 
<a name="l00481"></a>00481       {  <span class="keywordflow">return</span> m_flat_tree.erase(x); }
<a name="l00482"></a>00482 
<a name="l00491"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a39db35eb595cdc5145ab634b53ba128f">00491</a>    iterator erase(const_iterator first, const_iterator last) 
<a name="l00492"></a>00492       {  <span class="keywordflow">return</span> m_flat_tree.erase(first, last);  }
<a name="l00493"></a>00493 
<a name="l00499"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a2baeb0764334cf15aae4a4b812419ed3">00499</a>    <span class="keywordtype">void</span> clear() 
<a name="l00500"></a>00500       { m_flat_tree.clear(); }
<a name="l00501"></a>00501 
<a name="l00503"></a>00503    <span class="comment">//    with previous allocations. The size of the vector is unchanged</span>
<a name="l00508"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#aadb6bf6d8c08c4d917b4837f915f7de4">00508</a> <span class="comment"></span>   <span class="keywordtype">void</span> shrink_to_fit()
<a name="l00509"></a>00509       { m_flat_tree.shrink_to_fit(); }
<a name="l00510"></a>00510 
<a name="l00515"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#aafd1035d44ce8900fa180724ae353912">00515</a>    iterator find(<span class="keyword">const</span> key_type&amp; x) 
<a name="l00516"></a>00516       { <span class="keywordflow">return</span> m_flat_tree.find(x); }
<a name="l00517"></a>00517 
<a name="l00522"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#af2e3c21e96c4adad40c128ff500045e1">00522</a>    const_iterator find(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l00523"></a>00523 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.find(x); }
<a name="l00524"></a>00524 
<a name="l00528"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a5659a9f39ed63585f108df869326fe56">00528</a>    size_type count(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l00529"></a>00529 <span class="keyword">      </span>{  <span class="keywordflow">return</span> m_flat_tree.find(x) == m_flat_tree.end() ? 0 : 1;  }
<a name="l00530"></a>00530 
<a name="l00535"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a7d4f94f8c0cf3329caa781123adb0399">00535</a>    iterator lower_bound(<span class="keyword">const</span> key_type&amp; x) 
<a name="l00536"></a>00536       {  <span class="keywordflow">return</span> m_flat_tree.lower_bound(x); }
<a name="l00537"></a>00537 
<a name="l00542"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a9eeddf5a4d76ffed2c556d88a5cb3325">00542</a>    const_iterator lower_bound(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l00543"></a>00543 <span class="keyword">      </span>{  <span class="keywordflow">return</span> m_flat_tree.lower_bound(x); }
<a name="l00544"></a>00544 
<a name="l00549"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#afdab18673861a583c3f96d7900ff2b6a">00549</a>    iterator upper_bound(<span class="keyword">const</span> key_type&amp; x)
<a name="l00550"></a>00550       {  <span class="keywordflow">return</span> m_flat_tree.upper_bound(x);    }
<a name="l00551"></a>00551 
<a name="l00556"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a416ccecf2b368012d258461b9d4ea629">00556</a>    const_iterator upper_bound(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l00557"></a>00557 <span class="keyword">      </span>{  <span class="keywordflow">return</span> m_flat_tree.upper_bound(x);    }
<a name="l00558"></a>00558 
<a name="l00562"></a>00562    std::pair&lt;const_iterator, const_iterator&gt; 
<a name="l00563"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#ab147ed6d179d1a844c446233c502640b">00563</a>       equal_range(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l00564"></a>00564 <span class="keyword">      </span>{  <span class="keywordflow">return</span> m_flat_tree.equal_range(x); }
<a name="l00565"></a>00565 
<a name="l00569"></a>00569    std::pair&lt;iterator,iterator&gt; 
<a name="l00570"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a6deb56b73537f9d181586654e48e042b">00570</a>       equal_range(<span class="keyword">const</span> key_type&amp; x) 
<a name="l00571"></a>00571       {  <span class="keywordflow">return</span> m_flat_tree.equal_range(x); }
<a name="l00572"></a>00572 
<a name="l00579"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#a69ad6b15174caea645937be3a99b9729">00579</a>    size_type capacity()<span class="keyword"> const           </span>
<a name="l00580"></a>00580 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.capacity(); }
<a name="l00581"></a>00581 
<a name="l00591"></a><a class="code" href="classboost_1_1container_1_1flat__set.html#ac36d20e437f7519d7f04e70455aade0b">00591</a>    <span class="keywordtype">void</span> reserve(size_type count)       
<a name="l00592"></a>00592       { m_flat_tree.reserve(count);   }
<a name="l00593"></a>00593 
<a name="l00595"></a>00595    <span class="keyword">template</span> &lt;<span class="keyword">class</span> K1, <span class="keyword">class</span> C1, <span class="keyword">class</span> A1&gt;
<a name="l00596"></a>00596    <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator== (<span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1flat__set.html">flat_set&lt;K1,C1,A1&gt;</a>&amp;, <span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1flat__set.html">flat_set&lt;K1,C1,A1&gt;</a>&amp;);
<a name="l00597"></a>00597 
<a name="l00598"></a>00598    <span class="keyword">template</span> &lt;<span class="keyword">class</span> K1, <span class="keyword">class</span> C1, <span class="keyword">class</span> A1&gt;
<a name="l00599"></a>00599    <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator&lt; (const flat_set&lt;K1,C1,A1&gt;&amp;, <span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1flat__set.html">flat_set&lt;K1,C1,A1&gt;</a>&amp;);
<a name="l00600"></a>00600 
<a name="l00601"></a>00601    <span class="keyword">private</span>:
<a name="l00602"></a>00602    std::pair&lt;iterator, bool&gt; priv_insert(<span class="keyword">const</span> T &amp;x) 
<a name="l00603"></a>00603    {  <span class="keywordflow">return</span> m_flat_tree.insert_unique(x);  }
<a name="l00604"></a>00604 
<a name="l00605"></a>00605    iterator priv_insert(const_iterator p, <span class="keyword">const</span> T &amp;x) 
<a name="l00606"></a>00606    {  <span class="keywordflow">return</span> m_flat_tree.insert_unique(p, x); }
<a name="l00608"></a>00608 };
<a name="l00609"></a>00609 
<a name="l00610"></a>00610 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00611"></a>00611 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> flat_set&lt;T,Pred,Alloc&gt;&amp; x, 
<a name="l00612"></a>00612                        <span class="keyword">const</span> flat_set&lt;T,Pred,Alloc&gt;&amp; y) 
<a name="l00613"></a>00613    {  <span class="keywordflow">return</span> x.m_flat_tree == y.m_flat_tree;  }
<a name="l00614"></a>00614 
<a name="l00615"></a>00615 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00616"></a>00616 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&lt;(const flat_set&lt;T,Pred,Alloc&gt;&amp; x, 
<a name="l00617"></a>00617                       <span class="keyword">const</span> flat_set&lt;T,Pred,Alloc&gt;&amp; y) 
<a name="l00618"></a>00618    {  <span class="keywordflow">return</span> x.m_flat_tree &lt; y.m_flat_tree;   }
<a name="l00619"></a>00619 
<a name="l00620"></a>00620 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00621"></a>00621 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> flat_set&lt;T,Pred,Alloc&gt;&amp; x, 
<a name="l00622"></a>00622                        <span class="keyword">const</span> flat_set&lt;T,Pred,Alloc&gt;&amp; y) 
<a name="l00623"></a>00623    {  <span class="keywordflow">return</span> !(x == y);   }
<a name="l00624"></a>00624 
<a name="l00625"></a>00625 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00626"></a>00626 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&gt;(<span class="keyword">const</span> flat_set&lt;T,Pred,Alloc&gt;&amp; x, 
<a name="l00627"></a>00627                       <span class="keyword">const</span> flat_set&lt;T,Pred,Alloc&gt;&amp; y) 
<a name="l00628"></a>00628    {  <span class="keywordflow">return</span> y &lt; x; }
<a name="l00629"></a>00629 
<a name="l00630"></a>00630 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00631"></a>00631 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&lt;=(const flat_set&lt;T,Pred,Alloc&gt;&amp; x, 
<a name="l00632"></a>00632                        <span class="keyword">const</span> flat_set&lt;T,Pred,Alloc&gt;&amp; y) 
<a name="l00633"></a>00633    {  <span class="keywordflow">return</span> !(y &lt; x); }
<a name="l00634"></a>00634 
<a name="l00635"></a>00635 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00636"></a>00636 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&gt;=(<span class="keyword">const</span> flat_set&lt;T,Pred,Alloc&gt;&amp; x, 
<a name="l00637"></a>00637                        <span class="keyword">const</span> flat_set&lt;T,Pred,Alloc&gt;&amp; y) 
<a name="l00638"></a>00638    {  <span class="keywordflow">return</span> !(x &lt; y);  }
<a name="l00639"></a>00639 
<a name="l00640"></a>00640 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00641"></a>00641 <span class="keyword">inline</span> <span class="keywordtype">void</span> swap(flat_set&lt;T,Pred,Alloc&gt;&amp; x, flat_set&lt;T,Pred,Alloc&gt;&amp; y) 
<a name="l00642"></a>00642    {  x.swap(y);  }
<a name="l00643"></a>00643 
<a name="l00645"></a>00645 
<a name="l00646"></a>00646 }  <span class="comment">//namespace container {</span>
<a name="l00647"></a>00647 <span class="comment">/*</span>
<a name="l00650"></a>00650 <span class="comment">template &lt;class T, class C, class A&gt;</span>
<a name="l00651"></a>00651 <span class="comment">struct has_trivial_destructor_after_move&lt;boost::container::flat_set&lt;T, C, A&gt; &gt;</span>
<a name="l00652"></a>00652 <span class="comment">{</span>
<a name="l00653"></a>00653 <span class="comment">   static const bool value = has_trivial_destructor&lt;A&gt;::value &amp;&amp;has_trivial_destructor&lt;C&gt;::value;</span>
<a name="l00654"></a>00654 <span class="comment">};</span>
<a name="l00655"></a>00655 <span class="comment">*/</span>
<a name="l00656"></a>00656 <span class="keyword">namespace </span>container {
<a name="l00657"></a>00657 
<a name="l00658"></a>00658 <span class="comment">// Forward declaration of operators &lt; and ==, needed for friend declaration.</span>
<a name="l00659"></a>00659 
<a name="l00660"></a>00660 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00661"></a>00661 <span class="keyword">class </span>flat_multiset;
<a name="l00662"></a>00662 
<a name="l00663"></a>00663 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00664"></a>00664 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> flat_multiset&lt;T,Pred,Alloc&gt;&amp; x, 
<a name="l00665"></a>00665                        <span class="keyword">const</span> flat_multiset&lt;T,Pred,Alloc&gt;&amp; y);
<a name="l00666"></a>00666 
<a name="l00667"></a>00667 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00668"></a>00668 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&lt;(const flat_multiset&lt;T,Pred,Alloc&gt;&amp; x, 
<a name="l00669"></a>00669                       <span class="keyword">const</span> flat_multiset&lt;T,Pred,Alloc&gt;&amp; y);
<a name="l00671"></a>00671 
<a name="l00683"></a>00683 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00684"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html">00684</a> <span class="keyword">class </span><a class="code" href="classboost_1_1container_1_1flat__multiset.html">flat_multiset</a> 
<a name="l00685"></a>00685 {
<a name="l00687"></a>00687    <span class="keyword">private</span>:
<a name="l00688"></a>00688    BOOST_MOVE_MACRO_COPYABLE_AND_MOVABLE(<a class="code" href="classboost_1_1container_1_1flat__multiset.html">flat_multiset</a>)
<a name="l00689"></a>00689    <span class="keyword">typedef</span> <a class="code" href="classboost_1_1container_1_1containers__detail_1_1flat__tree.html">containers_detail::flat_tree&lt;T, T, containers_detail::identity&lt;T&gt;</a>, Pred, Alloc&gt; tree_t;
<a name="l00690"></a>00690    tree_t m_flat_tree;  <span class="comment">// flat tree representing flat_multiset</span>
<a name="l00691"></a>00691    <span class="keyword">typedef</span> <span class="keyword">typename</span> containers_detail::
<a name="l00692"></a>00692       move_const_ref_type&lt;T&gt;::type insert_const_ref_type;
<a name="l00694"></a>00694 
<a name="l00695"></a>00695    <span class="keyword">public</span>:
<a name="l00696"></a>00696    <span class="comment">// typedefs:</span>
<a name="l00697"></a>00697    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::key_type               key_type;
<a name="l00698"></a>00698    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::value_type             value_type;
<a name="l00699"></a>00699    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::pointer                pointer;
<a name="l00700"></a>00700    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::const_pointer          const_pointer;
<a name="l00701"></a>00701    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::reference              reference;
<a name="l00702"></a>00702    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::const_reference        const_reference;
<a name="l00703"></a>00703    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::key_compare            key_compare;
<a name="l00704"></a>00704    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::value_compare          value_compare;
<a name="l00705"></a>00705    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::iterator               iterator;
<a name="l00706"></a>00706    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::const_iterator         const_iterator;
<a name="l00707"></a>00707    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::reverse_iterator       reverse_iterator;
<a name="l00708"></a>00708    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::const_reverse_iterator const_reverse_iterator;
<a name="l00709"></a>00709    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::size_type              size_type;
<a name="l00710"></a>00710    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::difference_type        difference_type;
<a name="l00711"></a>00711    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::allocator_type         allocator_type;
<a name="l00712"></a>00712    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::stored_allocator_type  stored_allocator_type;
<a name="l00713"></a>00713 
<a name="l00714"></a>00714    <span class="comment">// allocation/deallocation</span>
<a name="l00715"></a>00715    <span class="keyword">explicit</span> <a class="code" href="classboost_1_1container_1_1flat__multiset.html">flat_multiset</a>(<span class="keyword">const</span> Pred&amp; comp = Pred(),
<a name="l00716"></a>00716                           <span class="keyword">const</span> allocator_type&amp; a = allocator_type())
<a name="l00717"></a>00717       : m_flat_tree(comp, a) {}
<a name="l00718"></a>00718 
<a name="l00719"></a>00719    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
<a name="l00720"></a>00720    <a class="code" href="classboost_1_1container_1_1flat__multiset.html">flat_multiset</a>(InputIterator first, InputIterator last,
<a name="l00721"></a>00721                  <span class="keyword">const</span> Pred&amp; comp        = Pred(),
<a name="l00722"></a>00722                  <span class="keyword">const</span> allocator_type&amp; a = allocator_type())
<a name="l00723"></a>00723       : m_flat_tree(comp, a) 
<a name="l00724"></a>00724       { m_flat_tree.insert_equal(first, last); }
<a name="l00725"></a>00725 
<a name="l00733"></a>00733    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
<a name="l00734"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#aba222f17932f2d03f9ee361489b353c2">00734</a>    <a class="code" href="classboost_1_1container_1_1flat__multiset.html">flat_multiset</a>(ordered_range_t, InputIterator first, InputIterator last,
<a name="l00735"></a>00735                  <span class="keyword">const</span> Pred&amp; comp        = Pred(),
<a name="l00736"></a>00736                  <span class="keyword">const</span> allocator_type&amp; a = allocator_type())
<a name="l00737"></a>00737       : m_flat_tree(ordered_range, first, last, comp, a) 
<a name="l00738"></a>00738    {}
<a name="l00739"></a>00739 
<a name="l00740"></a>00740    <a class="code" href="classboost_1_1container_1_1flat__multiset.html">flat_multiset</a>(<span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1flat__multiset.html">flat_multiset&lt;T,Pred,Alloc&gt;</a>&amp; x) 
<a name="l00741"></a>00741       : m_flat_tree(x.m_flat_tree) {}
<a name="l00742"></a>00742 
<a name="l00743"></a>00743    flat_multiset(BOOST_MOVE_MACRO_RV_REF(flat_multiset) x) 
<a name="l00744"></a>00744       : m_flat_tree(BOOST_CONTAINER_MOVE_NAMESPACE::move(x.m_flat_tree))
<a name="l00745"></a>00745    {}
<a name="l00746"></a>00746 
<a name="l00747"></a>00747    flat_multiset&lt;T,Pred,Alloc&gt;&amp; operator=(BOOST_MOVE_MACRO_COPY_ASSIGN_REF(flat_multiset) x) 
<a name="l00748"></a>00748       {  m_flat_tree = x.m_flat_tree;   <span class="keywordflow">return</span> *<span class="keyword">this</span>;  }
<a name="l00749"></a>00749 
<a name="l00750"></a>00750    flat_multiset&lt;T,Pred,Alloc&gt;&amp; operator=(BOOST_MOVE_MACRO_RV_REF(flat_multiset) mx) 
<a name="l00751"></a>00751    {  m_flat_tree = BOOST_CONTAINER_MOVE_NAMESPACE::move(mx.m_flat_tree);   <span class="keywordflow">return</span> *<span class="keyword">this</span>;  }
<a name="l00752"></a>00752 
<a name="l00757"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#a43c6968001172a8ac089bc1b66f09d64">00757</a>    key_compare key_comp()<span class="keyword"> const </span>
<a name="l00758"></a>00758 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.key_comp(); }
<a name="l00759"></a>00759 
<a name="l00764"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#ad842f15edf92c0b4b1ed71801ff485c6">00764</a>    value_compare value_comp()<span class="keyword"> const </span>
<a name="l00765"></a>00765 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.key_comp(); }
<a name="l00766"></a>00766 
<a name="l00771"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#a8f58c885c6288b4a8bccea9600c2992f">00771</a>    allocator_type get_allocator()<span class="keyword"> const </span>
<a name="l00772"></a>00772 <span class="keyword">   </span>{ <span class="keywordflow">return</span> m_flat_tree.get_allocator(); }
<a name="l00773"></a>00773 
<a name="l00774"></a>00774    <span class="keyword">const</span> stored_allocator_type &amp;get_stored_allocator()<span class="keyword"> const </span>
<a name="l00775"></a>00775 <span class="keyword">   </span>{ <span class="keywordflow">return</span> m_flat_tree.get_stored_allocator(); }
<a name="l00776"></a>00776 
<a name="l00777"></a>00777    stored_allocator_type &amp;get_stored_allocator()
<a name="l00778"></a>00778    { <span class="keywordflow">return</span> m_flat_tree.get_stored_allocator(); }
<a name="l00779"></a>00779 
<a name="l00785"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#a9a7b4597feee8d63861e9f369538c8aa">00785</a>    iterator begin() 
<a name="l00786"></a>00786       { <span class="keywordflow">return</span> m_flat_tree.begin(); }
<a name="l00787"></a>00787 
<a name="l00793"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#a4e10a21d3a855d88aefd44a39efab762">00793</a>    const_iterator begin()<span class="keyword"> const </span>
<a name="l00794"></a>00794 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.begin(); }
<a name="l00795"></a>00795 
<a name="l00801"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#a7ccd0119bbb09789aeeab2d98af092f7">00801</a>    const_iterator cbegin()<span class="keyword"> const </span>
<a name="l00802"></a>00802 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.cbegin(); }
<a name="l00803"></a>00803 
<a name="l00809"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#a68d2fae05daf0ff2d4300a3f84e70339">00809</a>    iterator end() 
<a name="l00810"></a>00810       { <span class="keywordflow">return</span> m_flat_tree.end(); }
<a name="l00811"></a>00811 
<a name="l00817"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#aee2cbbb5cd0574a69817ec1bf327ffff">00817</a>    const_iterator end()<span class="keyword"> const </span>
<a name="l00818"></a>00818 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.end(); }
<a name="l00819"></a>00819 
<a name="l00825"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#aa621ba4742b6e87f19cfcc7c81361f36">00825</a>    const_iterator cend()<span class="keyword"> const </span>
<a name="l00826"></a>00826 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.cend(); }
<a name="l00827"></a>00827 
<a name="l00834"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#a65c70cefb149d9a39eb4060e6f7153f2">00834</a>    reverse_iterator rbegin() 
<a name="l00835"></a>00835       { <span class="keywordflow">return</span> m_flat_tree.rbegin(); } 
<a name="l00836"></a>00836 
<a name="l00843"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#a394d4d2d9212d7537461ef71bcbc2f1f">00843</a>    const_reverse_iterator rbegin()<span class="keyword"> const </span>
<a name="l00844"></a>00844 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.rbegin(); } 
<a name="l00845"></a>00845 
<a name="l00852"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#a3dea4c4d24f04c214788e7245796a5ab">00852</a>    const_reverse_iterator crbegin()<span class="keyword"> const </span>
<a name="l00853"></a>00853 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.crbegin(); } 
<a name="l00854"></a>00854 
<a name="l00861"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#ac5320a7463b4ef8f2698c2d9699ef050">00861</a>    reverse_iterator rend()
<a name="l00862"></a>00862       { <span class="keywordflow">return</span> m_flat_tree.rend(); }
<a name="l00863"></a>00863 
<a name="l00870"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#a6d81742608fe085ee23e2eb2843aac99">00870</a>    const_reverse_iterator rend()<span class="keyword"> const </span>
<a name="l00871"></a>00871 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.rend(); }
<a name="l00872"></a>00872 
<a name="l00879"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#acc5397155d48fdee76a95e193eab200c">00879</a>    const_reverse_iterator crend()<span class="keyword"> const </span>
<a name="l00880"></a>00880 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.crend(); }
<a name="l00881"></a>00881 
<a name="l00887"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#a1dd629c12f323f9e7b4730b568ee55eb">00887</a>    <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>
<a name="l00888"></a>00888 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.empty(); }
<a name="l00889"></a>00889 
<a name="l00895"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#af5c4a48ee1cdb50c495ca7ce95e17ea4">00895</a>    size_type size()<span class="keyword"> const </span>
<a name="l00896"></a>00896 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.size(); }
<a name="l00897"></a>00897 
<a name="l00903"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#af1bbcdd82507561e16f37ae1295883d6">00903</a>    size_type max_size()<span class="keyword"> const </span>
<a name="l00904"></a>00904 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.max_size(); }
<a name="l00905"></a>00905 
<a name="l00912"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#ad1615491f0dcc525673b648f53b55dc9">00912</a>    <span class="keywordtype">void</span> swap(<a class="code" href="classboost_1_1container_1_1flat__multiset.html">flat_multiset</a>&amp; x)
<a name="l00913"></a>00913    { m_flat_tree.swap(x.m_flat_tree); }
<a name="l00914"></a>00914 
<a name="l00922"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#a413b596d4addb089b1fbe02481e6f214">00922</a>    iterator insert(insert_const_ref_type x) 
<a name="l00923"></a>00923    {  <span class="keywordflow">return</span> priv_insert(x); }
<a name="l00924"></a>00924 
<a name="l00925"></a>00925 <span class="preprocessor">   #if defined(BOOST_NO_RVALUE_REFERENCES) &amp;&amp; !defined(BOOST_MOVE_DOXYGEN_INVOKED)</span>
<a name="l00926"></a>00926 <span class="preprocessor"></span>   iterator insert(T &amp;x)
<a name="l00927"></a>00927    { <span class="keywordflow">return</span> this-&gt;insert(const_cast&lt;const T &amp;&gt;(x)); }
<a name="l00928"></a>00928 
<a name="l00929"></a>00929    <span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt;
<a name="l00930"></a>00930    iterator insert(<span class="keyword">const</span> U &amp;u, <span class="keyword">typename</span> containers_detail::enable_if_c&lt;containers_detail::is_same&lt;T, U&gt;::value &amp;&amp; !::BOOST_CONTAINER_MOVE_NAMESPACE::is_movable&lt;U&gt;::value &gt;::type* =0)
<a name="l00931"></a>00931    {  <span class="keywordflow">return</span> priv_insert(u); }
<a name="l00932"></a>00932 <span class="preprocessor">   #endif</span>
<a name="l00933"></a>00933 <span class="preprocessor"></span>
<a name="l00941"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#a37561990bbf0efe4d725643ed5a3cbac">00941</a>    iterator insert(BOOST_MOVE_MACRO_RV_REF(value_type) x) 
<a name="l00942"></a>00942    {  <span class="keywordflow">return</span> m_flat_tree.insert_equal(BOOST_CONTAINER_MOVE_NAMESPACE::move(x));   }
<a name="l00943"></a>00943 
<a name="l00954"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#acc9e5e2f328bce4fb45d5c4aa317f75d">00954</a>    iterator insert(const_iterator p, insert_const_ref_type x) 
<a name="l00955"></a>00955    {  <span class="keywordflow">return</span> priv_insert(p, x); }
<a name="l00956"></a>00956 
<a name="l00957"></a>00957 <span class="preprocessor">   #if defined(BOOST_NO_RVALUE_REFERENCES) &amp;&amp; !defined(BOOST_MOVE_DOXYGEN_INVOKED)</span>
<a name="l00958"></a>00958 <span class="preprocessor"></span>   iterator insert(const_iterator position, T &amp;x)
<a name="l00959"></a>00959    { <span class="keywordflow">return</span> this-&gt;insert(position, const_cast&lt;const T &amp;&gt;(x)); }
<a name="l00960"></a>00960 
<a name="l00961"></a>00961    <span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt;
<a name="l00962"></a>00962    iterator insert(const_iterator position, <span class="keyword">const</span> U &amp;u, <span class="keyword">typename</span> containers_detail::enable_if_c&lt;containers_detail::is_same&lt;T, U&gt;::value &amp;&amp; !::BOOST_CONTAINER_MOVE_NAMESPACE::is_movable&lt;U&gt;::value &gt;::type* =0)
<a name="l00963"></a>00963    {  <span class="keywordflow">return</span> priv_insert(position, u); }
<a name="l00964"></a>00964 <span class="preprocessor">   #endif</span>
<a name="l00965"></a>00965 <span class="preprocessor"></span>
<a name="l00976"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#aa855b03ce2a911ec07dfc01af579048c">00976</a>    iterator insert(const_iterator position, BOOST_MOVE_MACRO_RV_REF(value_type) x) 
<a name="l00977"></a>00977    {  <span class="keywordflow">return</span> m_flat_tree.insert_equal(position, BOOST_CONTAINER_MOVE_NAMESPACE::move(x));  }
<a name="l00978"></a>00978 
<a name="l00987"></a>00987    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
<a name="l00988"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#a34a576b9d120bc7827091d70447675e4">00988</a>    <span class="keywordtype">void</span> insert(InputIterator first, InputIterator last) 
<a name="l00989"></a>00989       {  m_flat_tree.insert_equal(first, last);  }
<a name="l00990"></a>00990 
<a name="l00991"></a>00991 <span class="preprocessor">   #if defined(BOOST_CONTAINERS_PERFECT_FORWARDING) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)</span>
<a name="l00992"></a>00992 <span class="preprocessor"></span>
<a name="l01001"></a>01001    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;
<a name="l01002"></a>01002    iterator emplace(Args&amp;&amp;... args)
<a name="l01003"></a>01003    {  <span class="keywordflow">return</span> m_flat_tree.emplace_equal(BOOST_CONTAINER_MOVE_NAMESPACE::forward&lt;Args&gt;(args)...); }
<a name="l01004"></a>01004 
<a name="l01016"></a>01016    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;
<a name="l01017"></a>01017    iterator emplace_hint(const_iterator hint, Args&amp;&amp;... args)
<a name="l01018"></a>01018    {  <span class="keywordflow">return</span> m_flat_tree.emplace_hint_equal(hint, BOOST_CONTAINER_MOVE_NAMESPACE::forward&lt;Args&gt;(args)...); }
<a name="l01019"></a>01019 
<a name="l01020"></a>01020 <span class="preprocessor">   #else //#ifdef BOOST_CONTAINERS_PERFECT_FORWARDING</span>
<a name="l01021"></a>01021 <span class="preprocessor"></span>
<a name="l01022"></a>01022    iterator emplace()
<a name="l01023"></a>01023    {  <span class="keywordflow">return</span> m_flat_tree.emplace_equal(); }
<a name="l01024"></a>01024 
<a name="l01025"></a>01025    iterator emplace_hint(const_iterator hint)
<a name="l01026"></a>01026    {  <span class="keywordflow">return</span> m_flat_tree.emplace_hint_equal(hint); }
<a name="l01027"></a>01027 
<a name="l01028"></a>01028 <span class="preprocessor">   #define BOOST_PP_LOCAL_MACRO(n)                                                                             \</span>
<a name="l01029"></a>01029 <span class="preprocessor">   template&lt;BOOST_PP_ENUM_PARAMS(n, class P)&gt;                                                                  \</span>
<a name="l01030"></a>01030 <span class="preprocessor">   iterator emplace(BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_LIST, _))                                     \</span>
<a name="l01031"></a>01031 <span class="preprocessor">   {  return m_flat_tree.emplace_equal(BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_FORWARD, _)); }            \</span>
<a name="l01032"></a>01032 <span class="preprocessor">                                                                                                               \</span>
<a name="l01033"></a>01033 <span class="preprocessor">   template&lt;BOOST_PP_ENUM_PARAMS(n, class P)&gt;                                                                  \</span>
<a name="l01034"></a>01034 <span class="preprocessor">   iterator emplace_hint(const_iterator hint, BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_LIST, _))           \</span>
<a name="l01035"></a>01035 <span class="preprocessor">   {  return m_flat_tree.emplace_hint_equal(hint, BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_FORWARD, _)); } \</span>
<a name="l01036"></a>01036 <span class="preprocessor"></span>
<a name="l01037"></a>01037 <span class="preprocessor">   #define BOOST_PP_LOCAL_LIMITS (1, BOOST_CONTAINERS_MAX_CONSTRUCTOR_PARAMETERS)</span>
<a name="l01038"></a>01038 <span class="preprocessor"></span><span class="preprocessor">   #include BOOST_PP_LOCAL_ITERATE()</span>
<a name="l01039"></a>01039 <span class="preprocessor"></span>
<a name="l01040"></a>01040 <span class="preprocessor">   #endif   //#ifdef BOOST_CONTAINERS_PERFECT_FORWARDING</span>
<a name="l01041"></a>01041 <span class="preprocessor"></span>
<a name="l01052"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#ab90e30436109f32adb2232d9bc5855b1">01052</a>    iterator erase(const_iterator position) 
<a name="l01053"></a>01053       {  <span class="keywordflow">return</span> m_flat_tree.erase(position); }
<a name="l01054"></a>01054 
<a name="l01061"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#a5b08b8c94d9e7bd495549ee8d7e500ad">01061</a>    size_type erase(<span class="keyword">const</span> key_type&amp; x) 
<a name="l01062"></a>01062       {  <span class="keywordflow">return</span> m_flat_tree.erase(x); }
<a name="l01063"></a>01063 
<a name="l01072"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#a1c64a50d8ade2906acf24fcf5ea158cf">01072</a>    iterator erase(const_iterator first, const_iterator last) 
<a name="l01073"></a>01073       {  <span class="keywordflow">return</span> m_flat_tree.erase(first, last);  }
<a name="l01074"></a>01074 
<a name="l01080"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#ae987da7717f9b8bbadb571b2b4f76f0c">01080</a>    <span class="keywordtype">void</span> clear() 
<a name="l01081"></a>01081       { m_flat_tree.clear(); }
<a name="l01082"></a>01082 
<a name="l01084"></a>01084    <span class="comment">//    with previous allocations. The size of the vector is unchanged</span>
<a name="l01089"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#a037d0531969097219e5722b4592e4a68">01089</a> <span class="comment"></span>   <span class="keywordtype">void</span> shrink_to_fit()
<a name="l01090"></a>01090       { m_flat_tree.shrink_to_fit(); }
<a name="l01091"></a>01091 
<a name="l01096"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#a14f8df4d4a8b1a2f4e5361c08a1aec13">01096</a>    iterator find(<span class="keyword">const</span> key_type&amp; x) 
<a name="l01097"></a>01097       { <span class="keywordflow">return</span> m_flat_tree.find(x); }
<a name="l01098"></a>01098 
<a name="l01103"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#aa107a93655f53470ae014bc5260ae0e8">01103</a>    const_iterator find(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l01104"></a>01104 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.find(x); }
<a name="l01105"></a>01105 
<a name="l01109"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#a35009293b953f8600a1dfe17bda1c49f">01109</a>    size_type count(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l01110"></a>01110 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.count(x); }
<a name="l01111"></a>01111 
<a name="l01116"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#aae48e1fc9273a02f91951b8f0bdcdf2f">01116</a>    iterator lower_bound(<span class="keyword">const</span> key_type&amp; x) 
<a name="l01117"></a>01117       {  <span class="keywordflow">return</span> m_flat_tree.lower_bound(x); }
<a name="l01118"></a>01118 
<a name="l01123"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#a962be2c6560808464ebd66d79de6c303">01123</a>    const_iterator lower_bound(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l01124"></a>01124 <span class="keyword">      </span>{  <span class="keywordflow">return</span> m_flat_tree.lower_bound(x); }
<a name="l01125"></a>01125 
<a name="l01130"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#a06e04eb8ce9eb5c3c9359b74d19e4cc8">01130</a>    iterator upper_bound(<span class="keyword">const</span> key_type&amp; x)
<a name="l01131"></a>01131       {  <span class="keywordflow">return</span> m_flat_tree.upper_bound(x);    }
<a name="l01132"></a>01132 
<a name="l01137"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#a93d71dd45cfd982c2f92bc5e86b86cda">01137</a>    const_iterator upper_bound(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l01138"></a>01138 <span class="keyword">      </span>{  <span class="keywordflow">return</span> m_flat_tree.upper_bound(x);    }
<a name="l01139"></a>01139 
<a name="l01143"></a>01143    std::pair&lt;const_iterator, const_iterator&gt; 
<a name="l01144"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#a29cfd9004e735df63860b05b0296f6a0">01144</a>       equal_range(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l01145"></a>01145 <span class="keyword">      </span>{  <span class="keywordflow">return</span> m_flat_tree.equal_range(x); }
<a name="l01146"></a>01146 
<a name="l01150"></a>01150    std::pair&lt;iterator,iterator&gt; 
<a name="l01151"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#a378a5c916aae4858cc205c9cc8430895">01151</a>       equal_range(<span class="keyword">const</span> key_type&amp; x) 
<a name="l01152"></a>01152       {  <span class="keywordflow">return</span> m_flat_tree.equal_range(x); }
<a name="l01153"></a>01153 
<a name="l01160"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#a72c393f7b82938dad09554d9c77d2fca">01160</a>    size_type capacity()<span class="keyword"> const           </span>
<a name="l01161"></a>01161 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.capacity(); }
<a name="l01162"></a>01162 
<a name="l01172"></a><a class="code" href="classboost_1_1container_1_1flat__multiset.html#a49ee151280bcb1a05311a4f28bfb8fbc">01172</a>    <span class="keywordtype">void</span> reserve(size_type count)       
<a name="l01173"></a>01173       { m_flat_tree.reserve(count);   }
<a name="l01174"></a>01174 
<a name="l01176"></a>01176    <span class="keyword">template</span> &lt;<span class="keyword">class</span> K1, <span class="keyword">class</span> C1, <span class="keyword">class</span> A1&gt;
<a name="l01177"></a>01177    <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator== (<span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1flat__multiset.html">flat_multiset&lt;K1,C1,A1&gt;</a>&amp;,
<a name="l01178"></a>01178                            <span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1flat__multiset.html">flat_multiset&lt;K1,C1,A1&gt;</a>&amp;);
<a name="l01179"></a>01179    <span class="keyword">template</span> &lt;<span class="keyword">class</span> K1, <span class="keyword">class</span> C1, <span class="keyword">class</span> A1&gt;
<a name="l01180"></a>01180    <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator&lt; (const flat_multiset&lt;K1,C1,A1&gt;&amp;,
<a name="l01181"></a>01181                           <span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1flat__multiset.html">flat_multiset&lt;K1,C1,A1&gt;</a>&amp;);
<a name="l01182"></a>01182    <span class="keyword">private</span>:
<a name="l01183"></a>01183    iterator priv_insert(<span class="keyword">const</span> T &amp;x) 
<a name="l01184"></a>01184    {  <span class="keywordflow">return</span> m_flat_tree.insert_equal(x);  }
<a name="l01185"></a>01185 
<a name="l01186"></a>01186    iterator priv_insert(const_iterator p, <span class="keyword">const</span> T &amp;x) 
<a name="l01187"></a>01187    {  <span class="keywordflow">return</span> m_flat_tree.insert_equal(p, x); }
<a name="l01189"></a>01189 };
<a name="l01190"></a>01190 
<a name="l01191"></a>01191 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l01192"></a>01192 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> flat_multiset&lt;T,Pred,Alloc&gt;&amp; x, 
<a name="l01193"></a>01193                        <span class="keyword">const</span> flat_multiset&lt;T,Pred,Alloc&gt;&amp; y) 
<a name="l01194"></a>01194    {  <span class="keywordflow">return</span> x.m_flat_tree == y.m_flat_tree;  }
<a name="l01195"></a>01195 
<a name="l01196"></a>01196 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l01197"></a>01197 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&lt;(const flat_multiset&lt;T,Pred,Alloc&gt;&amp; x, 
<a name="l01198"></a>01198                       <span class="keyword">const</span> flat_multiset&lt;T,Pred,Alloc&gt;&amp; y) 
<a name="l01199"></a>01199    {  <span class="keywordflow">return</span> x.m_flat_tree &lt; y.m_flat_tree;   }
<a name="l01200"></a>01200 
<a name="l01201"></a>01201 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l01202"></a>01202 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> flat_multiset&lt;T,Pred,Alloc&gt;&amp; x, 
<a name="l01203"></a>01203                        <span class="keyword">const</span> flat_multiset&lt;T,Pred,Alloc&gt;&amp; y) 
<a name="l01204"></a>01204    {  <span class="keywordflow">return</span> !(x == y);  }
<a name="l01205"></a>01205 
<a name="l01206"></a>01206 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l01207"></a>01207 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&gt;(<span class="keyword">const</span> flat_multiset&lt;T,Pred,Alloc&gt;&amp; x, 
<a name="l01208"></a>01208                       <span class="keyword">const</span> flat_multiset&lt;T,Pred,Alloc&gt;&amp; y) 
<a name="l01209"></a>01209    {  <span class="keywordflow">return</span> y &lt; x;  }
<a name="l01210"></a>01210 
<a name="l01211"></a>01211 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l01212"></a>01212 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&lt;=(const flat_multiset&lt;T,Pred,Alloc&gt;&amp; x, 
<a name="l01213"></a>01213                        <span class="keyword">const</span> flat_multiset&lt;T,Pred,Alloc&gt;&amp; y) 
<a name="l01214"></a>01214    {  <span class="keywordflow">return</span> !(y &lt; x);  }
<a name="l01215"></a>01215 
<a name="l01216"></a>01216 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l01217"></a>01217 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&gt;=(<span class="keyword">const</span> flat_multiset&lt;T,Pred,Alloc&gt;&amp; x, 
<a name="l01218"></a>01218                        <span class="keyword">const</span> flat_multiset&lt;T,Pred,Alloc&gt;&amp; y) 
<a name="l01219"></a>01219 {  <span class="keywordflow">return</span> !(x &lt; y);  }
<a name="l01220"></a>01220 
<a name="l01221"></a>01221 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l01222"></a>01222 <span class="keyword">inline</span> <span class="keywordtype">void</span> swap(flat_multiset&lt;T,Pred,Alloc&gt;&amp; x, flat_multiset&lt;T,Pred,Alloc&gt;&amp; y) 
<a name="l01223"></a>01223    {  x.swap(y);  }
<a name="l01224"></a>01224 
<a name="l01226"></a>01226 
<a name="l01227"></a>01227 }  <span class="comment">//namespace container {</span>
<a name="l01228"></a>01228 <span class="comment">/*</span>
<a name="l01231"></a>01231 <span class="comment">template &lt;class T, class C, class A&gt;</span>
<a name="l01232"></a>01232 <span class="comment">struct has_trivial_destructor_after_move&lt;boost::container::flat_multiset&lt;T, C, A&gt; &gt;</span>
<a name="l01233"></a>01233 <span class="comment">{</span>
<a name="l01234"></a>01234 <span class="comment">   static const bool value = has_trivial_destructor&lt;A&gt;::value &amp;&amp; has_trivial_destructor&lt;C&gt;::value;</span>
<a name="l01235"></a>01235 <span class="comment">};</span>
<a name="l01236"></a>01236 <span class="comment">*/</span>
<a name="l01237"></a>01237 <span class="keyword">namespace </span>container {
<a name="l01238"></a>01238 
<a name="l01240"></a>01240 
<a name="l01241"></a>01241 }}
<a name="l01242"></a>01242 
<a name="l01243"></a>01243 <span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_CONFIG_END_HPP</span>
<a name="l01244"></a>01244 <span class="preprocessor"></span>
<a name="l01245"></a>01245 <span class="preprocessor">#endif </span><span class="comment">/* BOOST_CONTAINERS_FLAT_SET_HPP */</span>
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Apr 27 2011 00:50:03 for Nutcracker by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
