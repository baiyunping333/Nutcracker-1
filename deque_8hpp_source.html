<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nutcracker: deque.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>deque.hpp</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00002"></a>00002 <span class="comment">//</span>
<a name="l00003"></a>00003 <span class="comment">// (C) Copyright Ion Gaztanaga 2005-2006. Distributed under the Boost</span>
<a name="l00004"></a>00004 <span class="comment">// Software License, Version 1.0. (See accompanying file</span>
<a name="l00005"></a>00005 <span class="comment">// LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)</span>
<a name="l00006"></a>00006 <span class="comment">//</span>
<a name="l00007"></a>00007 <span class="comment">// See http://www.boost.org/libs/container for documentation.</span>
<a name="l00008"></a>00008 <span class="comment">//</span>
<a name="l00010"></a>00010 <span class="comment"></span>
<a name="l00011"></a>00011 <span class="preprocessor">#ifndef BOOST_CONTAINERS_DEQUE_HPP</span>
<a name="l00012"></a>00012 <span class="preprocessor"></span><span class="preprocessor">#define BOOST_CONTAINERS_DEQUE_HPP</span>
<a name="l00013"></a>00013 <span class="preprocessor"></span>
<a name="l00014"></a>00014 <span class="preprocessor">#if (defined _MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200)</span>
<a name="l00015"></a>00015 <span class="preprocessor"></span><span class="preprocessor">#  pragma once</span>
<a name="l00016"></a>00016 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00017"></a>00017 <span class="preprocessor"></span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &quot;detail/config_begin.hpp&quot;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_WORKAROUND_HPP</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span>
<a name="l00021"></a>00021 <span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_UTILITIES_HPP</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span><span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_ITERATORS_HPP</span>
<a name="l00023"></a>00023 <span class="preprocessor"></span><span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_ALGORITHMS_HPP</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span><span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_MPL_HPP</span>
<a name="l00025"></a>00025 <span class="preprocessor"></span><span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_CONTAINER_FWD_HPP</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span><span class="preprocessor">#include &lt;cstddef&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;iterator&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;cassert&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;memory&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;stdexcept&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;boost/detail/no_exceptions_support.hpp&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;boost/type_traits/has_trivial_destructor.hpp&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;boost/type_traits/has_trivial_copy.hpp&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;boost/type_traits/has_trivial_assign.hpp&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;boost/type_traits/has_nothrow_copy.hpp&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;boost/type_traits/has_nothrow_assign.hpp&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_MOVE_HPP</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span><span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_ADVANCED_INSERT_INT_HPP</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span>
<a name="l00041"></a>00041 <span class="preprocessor">#ifdef BOOST_CONTAINER_DOXYGEN_INVOKED</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span><span class="keyword">namespace </span>boost {
<a name="l00043"></a>00043 <span class="keyword">namespace </span>container {
<a name="l00044"></a>00044 <span class="preprocessor">#else</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span><span class="keyword">namespace </span>boost {
<a name="l00046"></a>00046 <span class="keyword">namespace </span>container {
<a name="l00047"></a>00047 <span class="preprocessor">#endif</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span>
<a name="l00050"></a>00050 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;
<a name="l00051"></a>00051 <span class="keyword">class </span>deque;
<a name="l00052"></a>00052 
<a name="l00053"></a>00053 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> A&gt;
<a name="l00054"></a>00054 <span class="keyword">struct </span>deque_value_traits
<a name="l00055"></a>00055 {
<a name="l00056"></a>00056    <span class="keyword">typedef</span> T value_type;
<a name="l00057"></a>00057    <span class="keyword">typedef</span> A allocator_type;
<a name="l00058"></a>00058    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> trivial_dctr = boost::has_trivial_destructor&lt;value_type&gt;::value;
<a name="l00059"></a>00059    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> trivial_dctr_after_move = <span class="keyword">false</span>;
<a name="l00060"></a>00060       <span class="comment">//::boost::has_trivial_destructor_after_move&lt;value_type&gt;::value || trivial_dctr;</span>
<a name="l00061"></a>00061    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> trivial_copy = has_trivial_copy&lt;value_type&gt;::value;
<a name="l00062"></a>00062    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> nothrow_copy = has_nothrow_copy&lt;value_type&gt;::value;
<a name="l00063"></a>00063    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> trivial_assign = has_trivial_assign&lt;value_type&gt;::value;
<a name="l00064"></a>00064    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> nothrow_assign = has_nothrow_assign&lt;value_type&gt;::value;
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 };
<a name="l00067"></a>00067 
<a name="l00068"></a>00068 <span class="comment">// Note: this function is simply a kludge to work around several compilers&#39;</span>
<a name="l00069"></a>00069 <span class="comment">//  bugs in handling constant expressions.</span>
<a name="l00070"></a>00070 <span class="keyword">inline</span> std::size_t deque_buf_size(std::size_t size) 
<a name="l00071"></a>00071    {  <span class="keywordflow">return</span> size &lt; 512 ? std::size_t(512 / size) : std::size_t(1);  }
<a name="l00072"></a>00072 
<a name="l00073"></a>00073 <span class="comment">// Deque base class.  It has two purposes.  First, its constructor</span>
<a name="l00074"></a>00074 <span class="comment">//  and destructor allocate (but don&#39;t initialize) storage.  This makes</span>
<a name="l00075"></a>00075 <span class="comment">//  exception safety easier.</span>
<a name="l00076"></a>00076 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;
<a name="l00077"></a>00077 <span class="keyword">class </span>deque_base
<a name="l00078"></a>00078 {
<a name="l00079"></a>00079    <span class="keyword">public</span>:
<a name="l00080"></a>00080    <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::value_type              val_alloc_val;
<a name="l00081"></a>00081    <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::pointer                 val_alloc_ptr;
<a name="l00082"></a>00082    <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::const_pointer           val_alloc_cptr;
<a name="l00083"></a>00083    <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::reference               val_alloc_ref;
<a name="l00084"></a>00084    <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::const_reference         val_alloc_cref;
<a name="l00085"></a>00085    <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::value_type              val_alloc_diff;
<a name="l00086"></a>00086    <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::template rebind
<a name="l00087"></a>00087       &lt;<span class="keyword">typename</span> Alloc::pointer&gt;::other             ptr_alloc_t;
<a name="l00088"></a>00088    <span class="keyword">typedef</span> <span class="keyword">typename</span> ptr_alloc_t::value_type        ptr_alloc_val;
<a name="l00089"></a>00089    <span class="keyword">typedef</span> <span class="keyword">typename</span> ptr_alloc_t::pointer           ptr_alloc_ptr;
<a name="l00090"></a>00090    <span class="keyword">typedef</span> <span class="keyword">typename</span> ptr_alloc_t::const_pointer     ptr_alloc_cptr;
<a name="l00091"></a>00091    <span class="keyword">typedef</span> <span class="keyword">typename</span> ptr_alloc_t::reference         ptr_alloc_ref;
<a name="l00092"></a>00092    <span class="keyword">typedef</span> <span class="keyword">typename</span> ptr_alloc_t::const_reference   ptr_alloc_cref;
<a name="l00093"></a>00093    <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::template
<a name="l00094"></a>00094       rebind&lt;T&gt;::other                             allocator_type;
<a name="l00095"></a>00095    <span class="keyword">typedef</span> allocator_type                          stored_allocator_type;
<a name="l00096"></a>00096 
<a name="l00097"></a>00097    <span class="keyword">protected</span>:
<a name="l00098"></a>00098 
<a name="l00099"></a>00099    <span class="keyword">typedef</span> deque_value_traits&lt;T, Alloc&gt;            traits_t;
<a name="l00100"></a>00100    <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::template
<a name="l00101"></a>00101       rebind&lt;typename Alloc::pointer&gt;::other map_allocator_type;
<a name="l00102"></a>00102 
<a name="l00103"></a>00103    <span class="keyword">static</span> std::size_t s_buffer_size() { <span class="keywordflow">return</span> deque_buf_size(<span class="keyword">sizeof</span>(T)); }
<a name="l00104"></a>00104 
<a name="l00105"></a>00105    val_alloc_ptr priv_allocate_node() 
<a name="l00106"></a>00106       {  <span class="keywordflow">return</span> this-&gt;alloc().allocate(s_buffer_size());  }
<a name="l00107"></a>00107 
<a name="l00108"></a>00108    <span class="keywordtype">void</span> priv_deallocate_node(val_alloc_ptr p) 
<a name="l00109"></a>00109       {  this-&gt;alloc().deallocate(p, s_buffer_size());  }
<a name="l00110"></a>00110 
<a name="l00111"></a>00111    ptr_alloc_ptr priv_allocate_map(std::size_t n) 
<a name="l00112"></a>00112       { <span class="keywordflow">return</span> this-&gt;ptr_alloc().allocate(n); }
<a name="l00113"></a>00113 
<a name="l00114"></a>00114    <span class="keywordtype">void</span> priv_deallocate_map(ptr_alloc_ptr p, std::size_t n) 
<a name="l00115"></a>00115       { this-&gt;ptr_alloc().deallocate(p, n); }
<a name="l00116"></a>00116 
<a name="l00117"></a>00117  <span class="keyword">public</span>:
<a name="l00118"></a>00118    <span class="comment">// Class invariants:</span>
<a name="l00119"></a>00119    <span class="comment">//  For any nonsingular iterator i:</span>
<a name="l00120"></a>00120    <span class="comment">//    i.node is the address of an element in the map array.  The</span>
<a name="l00121"></a>00121    <span class="comment">//      contents of i.node is a pointer to the beginning of a node.</span>
<a name="l00122"></a>00122    <span class="comment">//    i.first == //(i.node) </span>
<a name="l00123"></a>00123    <span class="comment">//    i.last  == i.first + node_size</span>
<a name="l00124"></a>00124    <span class="comment">//    i.cur is a pointer in the range [i.first, i.last).  NOTE:</span>
<a name="l00125"></a>00125    <span class="comment">//      the implication of this is that i.cur is always a dereferenceable</span>
<a name="l00126"></a>00126    <span class="comment">//      pointer, even if i is a past-the-end iterator.</span>
<a name="l00127"></a>00127    <span class="comment">//  Start and Finish are always nonsingular iterators.  NOTE: this means</span>
<a name="l00128"></a>00128    <span class="comment">//    that an empty deque must have one node, and that a deque</span>
<a name="l00129"></a>00129    <span class="comment">//    with N elements, where N is the buffer size, must have two nodes.</span>
<a name="l00130"></a>00130    <span class="comment">//  For every node other than start.node and finish.node, every element</span>
<a name="l00131"></a>00131    <span class="comment">//    in the node is an initialized object.  If start.node == finish.node,</span>
<a name="l00132"></a>00132    <span class="comment">//    then [start.cur, finish.cur) are initialized objects, and</span>
<a name="l00133"></a>00133    <span class="comment">//    the elements outside that range are uninitialized storage.  Otherwise,</span>
<a name="l00134"></a>00134    <span class="comment">//    [start.cur, start.last) and [finish.first, finish.cur) are initialized</span>
<a name="l00135"></a>00135    <span class="comment">//    objects, and [start.first, start.cur) and [finish.cur, finish.last)</span>
<a name="l00136"></a>00136    <span class="comment">//    are uninitialized storage.</span>
<a name="l00137"></a>00137    <span class="comment">//  [map, map + map_size) is a valid, non-empty range.  </span>
<a name="l00138"></a>00138    <span class="comment">//  [start.node, finish.node] is a valid range contained within </span>
<a name="l00139"></a>00139    <span class="comment">//    [map, map + map_size).  </span>
<a name="l00140"></a>00140    <span class="comment">//  A pointer in the range [map, map + map_size) points to an allocated node</span>
<a name="l00141"></a>00141    <span class="comment">//    if and only if the pointer is in the range [start.node, finish.node].</span>
<a name="l00142"></a>00142    <span class="keyword">class </span>const_iterator 
<a name="l00143"></a>00143       : <span class="keyword">public</span> std::iterator&lt;std::random_access_iterator_tag, 
<a name="l00144"></a>00144                               val_alloc_val,  val_alloc_diff, 
<a name="l00145"></a>00145                               val_alloc_cptr, val_alloc_cref&gt;
<a name="l00146"></a>00146    {
<a name="l00147"></a>00147       <span class="keyword">public</span>:
<a name="l00148"></a>00148       <span class="keyword">static</span> std::size_t s_buffer_size() { <span class="keywordflow">return</span> deque_base&lt;T, Alloc&gt;::s_buffer_size(); }
<a name="l00149"></a>00149 
<a name="l00150"></a>00150       <span class="keyword">typedef</span> std::random_access_iterator_tag   iterator_category;
<a name="l00151"></a>00151       <span class="keyword">typedef</span> val_alloc_val                     value_type;
<a name="l00152"></a>00152       <span class="keyword">typedef</span> val_alloc_cptr                    pointer;
<a name="l00153"></a>00153       <span class="keyword">typedef</span> val_alloc_cref                    reference;
<a name="l00154"></a>00154       <span class="keyword">typedef</span> std::size_t                       size_type;
<a name="l00155"></a>00155       <span class="keyword">typedef</span> std::ptrdiff_t                    difference_type;
<a name="l00156"></a>00156 
<a name="l00157"></a>00157       <span class="keyword">typedef</span> ptr_alloc_ptr                     index_pointer;
<a name="l00158"></a>00158       <span class="keyword">typedef</span> const_iterator                    self_t;
<a name="l00159"></a>00159 
<a name="l00160"></a>00160       <span class="keyword">friend</span> <span class="keyword">class </span>deque&lt;T, Alloc&gt;;
<a name="l00161"></a>00161       <span class="keyword">friend</span> <span class="keyword">class </span>deque_base&lt;T, Alloc&gt;;
<a name="l00162"></a>00162 
<a name="l00163"></a>00163       <span class="keyword">protected</span>: 
<a name="l00164"></a>00164       val_alloc_ptr  m_cur;
<a name="l00165"></a>00165       val_alloc_ptr  m_first;
<a name="l00166"></a>00166       val_alloc_ptr  m_last;
<a name="l00167"></a>00167       index_pointer  m_node;
<a name="l00168"></a>00168 
<a name="l00169"></a>00169       <span class="keyword">public</span>: 
<a name="l00170"></a>00170       const_iterator(val_alloc_ptr x, index_pointer y) 
<a name="l00171"></a>00171          : m_cur(x), m_first(*y),
<a name="l00172"></a>00172            m_last(*y + s_buffer_size()), m_node(y) {}
<a name="l00173"></a>00173 
<a name="l00174"></a>00174       const_iterator() : m_cur(0), m_first(0), m_last(0), m_node(0) {}
<a name="l00175"></a>00175 
<a name="l00176"></a>00176       const_iterator(<span class="keyword">const</span> const_iterator&amp; x)
<a name="l00177"></a>00177          : m_cur(x.m_cur),   m_first(x.m_first), 
<a name="l00178"></a>00178            m_last(x.m_last), m_node(x.m_node) {}
<a name="l00179"></a>00179 
<a name="l00180"></a>00180       reference operator*()<span class="keyword"> const </span>
<a name="l00181"></a>00181 <span class="keyword">         </span>{ <span class="keywordflow">return</span> *this-&gt;m_cur; }
<a name="l00182"></a>00182 
<a name="l00183"></a>00183       pointer operator-&gt;()<span class="keyword"> const </span>
<a name="l00184"></a>00184 <span class="keyword">         </span>{ <span class="keywordflow">return</span> this-&gt;m_cur; }
<a name="l00185"></a>00185 
<a name="l00186"></a>00186       difference_type operator-(<span class="keyword">const</span> self_t&amp; x)<span class="keyword"> const </span>
<a name="l00187"></a>00187 <span class="keyword">      </span>{
<a name="l00188"></a>00188          <span class="keywordflow">if</span>(!this-&gt;m_cur &amp;&amp; !x.m_cur){
<a name="l00189"></a>00189             <span class="keywordflow">return</span> 0;
<a name="l00190"></a>00190          }
<a name="l00191"></a>00191          <span class="keywordflow">return</span> difference_type(this-&gt;s_buffer_size()) * (this-&gt;m_node - x.m_node - 1) +
<a name="l00192"></a>00192             (this-&gt;m_cur - this-&gt;m_first) + (x.m_last - x.m_cur);
<a name="l00193"></a>00193       }
<a name="l00194"></a>00194 
<a name="l00195"></a>00195       self_t&amp; operator++() 
<a name="l00196"></a>00196       {
<a name="l00197"></a>00197          ++this-&gt;m_cur;
<a name="l00198"></a>00198          <span class="keywordflow">if</span> (this-&gt;m_cur == this-&gt;m_last) {
<a name="l00199"></a>00199             this-&gt;priv_set_node(this-&gt;m_node + 1);
<a name="l00200"></a>00200             this-&gt;m_cur = this-&gt;m_first;
<a name="l00201"></a>00201          }
<a name="l00202"></a>00202          <span class="keywordflow">return</span> *<span class="keyword">this</span>; 
<a name="l00203"></a>00203       }
<a name="l00204"></a>00204 
<a name="l00205"></a>00205       self_t operator++(<span class="keywordtype">int</span>)  
<a name="l00206"></a>00206       {
<a name="l00207"></a>00207          self_t tmp = *<span class="keyword">this</span>;
<a name="l00208"></a>00208          ++*<span class="keyword">this</span>;
<a name="l00209"></a>00209          <span class="keywordflow">return</span> tmp;
<a name="l00210"></a>00210       }
<a name="l00211"></a>00211 
<a name="l00212"></a>00212       self_t&amp; operator--() 
<a name="l00213"></a>00213       {
<a name="l00214"></a>00214          <span class="keywordflow">if</span> (this-&gt;m_cur == this-&gt;m_first) {
<a name="l00215"></a>00215             this-&gt;priv_set_node(this-&gt;m_node - 1);
<a name="l00216"></a>00216             this-&gt;m_cur = this-&gt;m_last;
<a name="l00217"></a>00217          }
<a name="l00218"></a>00218          --this-&gt;m_cur;
<a name="l00219"></a>00219          <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00220"></a>00220       }
<a name="l00221"></a>00221 
<a name="l00222"></a>00222       self_t operator--(<span class="keywordtype">int</span>) 
<a name="l00223"></a>00223       {
<a name="l00224"></a>00224          self_t tmp = *<span class="keyword">this</span>;
<a name="l00225"></a>00225          --*<span class="keyword">this</span>;
<a name="l00226"></a>00226          <span class="keywordflow">return</span> tmp;
<a name="l00227"></a>00227       }
<a name="l00228"></a>00228 
<a name="l00229"></a>00229       self_t&amp; operator+=(difference_type n)
<a name="l00230"></a>00230       {
<a name="l00231"></a>00231          difference_type offset = n + (this-&gt;m_cur - this-&gt;m_first);
<a name="l00232"></a>00232          <span class="keywordflow">if</span> (offset &gt;= 0 &amp;&amp; offset &lt; difference_type(this-&gt;s_buffer_size()))
<a name="l00233"></a>00233             this-&gt;m_cur += n;
<a name="l00234"></a>00234          <span class="keywordflow">else</span> {
<a name="l00235"></a>00235             difference_type node_offset =
<a name="l00236"></a>00236             offset &gt; 0 ? offset / difference_type(this-&gt;s_buffer_size())
<a name="l00237"></a>00237                         : -difference_type((-offset - 1) / this-&gt;s_buffer_size()) - 1;
<a name="l00238"></a>00238             this-&gt;priv_set_node(this-&gt;m_node + node_offset);
<a name="l00239"></a>00239             this-&gt;m_cur = this-&gt;m_first + 
<a name="l00240"></a>00240             (offset - node_offset * difference_type(this-&gt;s_buffer_size()));
<a name="l00241"></a>00241          }
<a name="l00242"></a>00242          <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00243"></a>00243       }
<a name="l00244"></a>00244 
<a name="l00245"></a>00245       self_t operator+(difference_type n)<span class="keyword"> const</span>
<a name="l00246"></a>00246 <span class="keyword">         </span>{  self_t tmp = *<span class="keyword">this</span>; <span class="keywordflow">return</span> tmp += n;  }
<a name="l00247"></a>00247 
<a name="l00248"></a>00248       self_t&amp; operator-=(difference_type n) 
<a name="l00249"></a>00249          { <span class="keywordflow">return</span> *<span class="keyword">this</span> += -n; }
<a name="l00250"></a>00250        
<a name="l00251"></a>00251       self_t operator-(difference_type n)<span class="keyword"> const </span>
<a name="l00252"></a>00252 <span class="keyword">         </span>{  self_t tmp = *<span class="keyword">this</span>; <span class="keywordflow">return</span> tmp -= n;  }
<a name="l00253"></a>00253 
<a name="l00254"></a>00254       reference operator[](difference_type n)<span class="keyword"> const </span>
<a name="l00255"></a>00255 <span class="keyword">         </span>{ <span class="keywordflow">return</span> *(*<span class="keyword">this</span> + n); }
<a name="l00256"></a>00256 
<a name="l00257"></a>00257       <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> self_t&amp; x)<span class="keyword"> const </span>
<a name="l00258"></a>00258 <span class="keyword">         </span>{ <span class="keywordflow">return</span> this-&gt;m_cur == x.m_cur; }
<a name="l00259"></a>00259 
<a name="l00260"></a>00260       <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> self_t&amp; x)<span class="keyword"> const </span>
<a name="l00261"></a>00261 <span class="keyword">         </span>{ <span class="keywordflow">return</span> !(*<span class="keyword">this</span> == x); }
<a name="l00262"></a>00262 
<a name="l00263"></a>00263       <span class="keywordtype">bool</span> operator&lt;(<span class="keyword">const</span> self_t&amp; x)<span class="keyword"> const </span>
<a name="l00264"></a>00264 <span class="keyword">      </span>{
<a name="l00265"></a>00265          <span class="keywordflow">return</span> (this-&gt;m_node == x.m_node) ? 
<a name="l00266"></a>00266             (this-&gt;m_cur &lt; x.m_cur) : (this-&gt;m_node &lt; x.m_node);
<a name="l00267"></a>00267       }
<a name="l00268"></a>00268 
<a name="l00269"></a>00269       <span class="keywordtype">bool</span> operator&gt;(<span class="keyword">const</span> self_t&amp; x)<span class="keyword"> const  </span>
<a name="l00270"></a>00270 <span class="keyword">         </span>{ <span class="keywordflow">return</span> x &lt; *<span class="keyword">this</span>; }
<a name="l00271"></a>00271 
<a name="l00272"></a>00272       <span class="keywordtype">bool</span> operator&lt;=(<span class="keyword">const</span> self_t&amp; x)<span class="keyword"> const </span>
<a name="l00273"></a>00273 <span class="keyword">         </span>{ <span class="keywordflow">return</span> !(x &lt; *<span class="keyword">this</span>); }
<a name="l00274"></a>00274 
<a name="l00275"></a>00275       <span class="keywordtype">bool</span> operator&gt;=(<span class="keyword">const</span> self_t&amp; x)<span class="keyword"> const </span>
<a name="l00276"></a>00276 <span class="keyword">         </span>{ <span class="keywordflow">return</span> !(*<span class="keyword">this</span> &lt; x); }
<a name="l00277"></a>00277 
<a name="l00278"></a>00278       <span class="keywordtype">void</span> priv_set_node(index_pointer new_node) 
<a name="l00279"></a>00279       {
<a name="l00280"></a>00280          this-&gt;m_node = new_node;
<a name="l00281"></a>00281          this-&gt;m_first = *new_node;
<a name="l00282"></a>00282          this-&gt;m_last = this-&gt;m_first + difference_type(this-&gt;s_buffer_size());
<a name="l00283"></a>00283       }
<a name="l00284"></a>00284 
<a name="l00285"></a>00285       <span class="keyword">friend</span> const_iterator operator+(std::ptrdiff_t n, <span class="keyword">const</span> const_iterator&amp; x)
<a name="l00286"></a>00286          {  <span class="keywordflow">return</span> x + n;  }
<a name="l00287"></a>00287    };
<a name="l00288"></a>00288 
<a name="l00289"></a>00289    <span class="comment">//Deque iterator</span>
<a name="l00290"></a>00290    <span class="keyword">class </span>iterator : <span class="keyword">public</span> const_iterator
<a name="l00291"></a>00291    {
<a name="l00292"></a>00292       <span class="keyword">public</span>:
<a name="l00293"></a>00293       <span class="keyword">typedef</span> std::random_access_iterator_tag   iterator_category;
<a name="l00294"></a>00294       <span class="keyword">typedef</span> val_alloc_val                     value_type;
<a name="l00295"></a>00295       <span class="keyword">typedef</span> val_alloc_ptr                     pointer;
<a name="l00296"></a>00296       <span class="keyword">typedef</span> val_alloc_ref                     reference;
<a name="l00297"></a>00297       <span class="keyword">typedef</span> std::size_t                       size_type;
<a name="l00298"></a>00298       <span class="keyword">typedef</span> std::ptrdiff_t                    difference_type;
<a name="l00299"></a>00299       <span class="keyword">typedef</span> ptr_alloc_ptr                     index_pointer;
<a name="l00300"></a>00300       <span class="keyword">typedef</span> const_iterator                    self_t;
<a name="l00301"></a>00301 
<a name="l00302"></a>00302       <span class="keyword">friend</span> <span class="keyword">class </span>deque&lt;T, Alloc&gt;;
<a name="l00303"></a>00303       <span class="keyword">friend</span> <span class="keyword">class </span>deque_base&lt;T, Alloc&gt;;
<a name="l00304"></a>00304 
<a name="l00305"></a>00305       <span class="keyword">private</span>:
<a name="l00306"></a>00306       <span class="keyword">explicit</span> iterator(<span class="keyword">const</span> const_iterator&amp; x) : const_iterator(x){}
<a name="l00307"></a>00307 
<a name="l00308"></a>00308       <span class="keyword">public</span>:
<a name="l00309"></a>00309       <span class="comment">//Constructors</span>
<a name="l00310"></a>00310       iterator(val_alloc_ptr x, index_pointer y) : const_iterator(x, y){}
<a name="l00311"></a>00311       iterator() : const_iterator(){}
<a name="l00312"></a>00312       <span class="comment">//iterator(const const_iterator &amp;cit) : const_iterator(cit){}</span>
<a name="l00313"></a>00313       iterator(<span class="keyword">const</span> iterator&amp; x) : const_iterator(x){}
<a name="l00314"></a>00314 
<a name="l00315"></a>00315       <span class="comment">//Pointer like operators</span>
<a name="l00316"></a>00316       reference operator*()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *this-&gt;m_cur; }
<a name="l00317"></a>00317       pointer operator-&gt;()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> this-&gt;m_cur; }
<a name="l00318"></a>00318 
<a name="l00319"></a>00319       reference operator[](difference_type n)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *(*<span class="keyword">this</span> + n); }
<a name="l00320"></a>00320 
<a name="l00321"></a>00321       <span class="comment">//Increment / Decrement</span>
<a name="l00322"></a>00322       iterator&amp; operator++()  
<a name="l00323"></a>00323          { this-&gt;const_iterator::operator++(); <span class="keywordflow">return</span> *<span class="keyword">this</span>;  }
<a name="l00324"></a>00324 
<a name="l00325"></a>00325       iterator operator++(<span class="keywordtype">int</span>)
<a name="l00326"></a>00326          { iterator tmp = *<span class="keyword">this</span>; ++*<span class="keyword">this</span>; <span class="keywordflow">return</span> tmp; }
<a name="l00327"></a>00327       
<a name="l00328"></a>00328       iterator&amp; operator--()
<a name="l00329"></a>00329          {  this-&gt;const_iterator::operator--(); <span class="keywordflow">return</span> *<span class="keyword">this</span>;  }
<a name="l00330"></a>00330 
<a name="l00331"></a>00331       iterator operator--(<span class="keywordtype">int</span>)
<a name="l00332"></a>00332          {  iterator tmp = *<span class="keyword">this</span>; --*<span class="keyword">this</span>; <span class="keywordflow">return</span> tmp; }
<a name="l00333"></a>00333 
<a name="l00334"></a>00334       <span class="comment">// Arithmetic</span>
<a name="l00335"></a>00335       iterator&amp; operator+=(difference_type off)
<a name="l00336"></a>00336          {  this-&gt;const_iterator::operator+=(off); <span class="keywordflow">return</span> *<span class="keyword">this</span>;  }
<a name="l00337"></a>00337 
<a name="l00338"></a>00338       iterator operator+(difference_type off)<span class="keyword"> const</span>
<a name="l00339"></a>00339 <span class="keyword">         </span>{  <span class="keywordflow">return</span> iterator(this-&gt;const_iterator::operator+(off));  }
<a name="l00340"></a>00340 
<a name="l00341"></a>00341       <span class="keyword">friend</span> iterator operator+(difference_type off, <span class="keyword">const</span> iterator&amp; right)
<a name="l00342"></a>00342          {  <span class="keywordflow">return</span> iterator(off+static_cast&lt;const const_iterator &amp;&gt;(right)); }
<a name="l00343"></a>00343 
<a name="l00344"></a>00344       iterator&amp; operator-=(difference_type off)
<a name="l00345"></a>00345          {  this-&gt;const_iterator::operator-=(off); <span class="keywordflow">return</span> *<span class="keyword">this</span>;   }
<a name="l00346"></a>00346 
<a name="l00347"></a>00347       iterator operator-(difference_type off)<span class="keyword"> const</span>
<a name="l00348"></a>00348 <span class="keyword">         </span>{  <span class="keywordflow">return</span> iterator(this-&gt;const_iterator::operator-(off));  }
<a name="l00349"></a>00349 
<a name="l00350"></a>00350       difference_type operator-(<span class="keyword">const</span> const_iterator&amp; right)<span class="keyword"> const</span>
<a name="l00351"></a>00351 <span class="keyword">         </span>{  <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>const_iterator&amp;<span class="keyword">&gt;</span>(*this) - right;   }
<a name="l00352"></a>00352    };
<a name="l00353"></a>00353 
<a name="l00354"></a>00354    deque_base(<span class="keyword">const</span> allocator_type&amp; a, std::size_t num_elements)
<a name="l00355"></a>00355       :  members_(a)
<a name="l00356"></a>00356    { this-&gt;priv_initialize_map(num_elements); }
<a name="l00357"></a>00357 
<a name="l00358"></a>00358    deque_base(<span class="keyword">const</span> allocator_type&amp; a) 
<a name="l00359"></a>00359       :  members_(a)
<a name="l00360"></a>00360    {}
<a name="l00361"></a>00361 
<a name="l00362"></a>00362    ~deque_base()
<a name="l00363"></a>00363    {
<a name="l00364"></a>00364       <span class="keywordflow">if</span> (this-&gt;members_.m_map) {
<a name="l00365"></a>00365          this-&gt;priv_destroy_nodes(this-&gt;members_.m_start.m_node, this-&gt;members_.m_finish.m_node + 1);
<a name="l00366"></a>00366          this-&gt;priv_deallocate_map(this-&gt;members_.m_map, this-&gt;members_.m_map_size);
<a name="l00367"></a>00367       }
<a name="l00368"></a>00368    }
<a name="l00369"></a>00369 
<a name="l00370"></a>00370    <span class="keyword">private</span>:
<a name="l00371"></a>00371    deque_base(<span class="keyword">const</span> deque_base&amp;);
<a name="l00372"></a>00372   
<a name="l00373"></a>00373    <span class="keyword">protected</span>:
<a name="l00374"></a>00374 
<a name="l00375"></a>00375    <span class="keywordtype">void</span> priv_initialize_map(std::size_t num_elements)
<a name="l00376"></a>00376    {
<a name="l00377"></a>00377 <span class="comment">//      if(num_elements){</span>
<a name="l00378"></a>00378          std::size_t num_nodes = num_elements / s_buffer_size() + 1;
<a name="l00379"></a>00379 
<a name="l00380"></a>00380          this-&gt;members_.m_map_size = containers_detail::max_value((std::size_t) InitialMapSize, num_nodes + 2);
<a name="l00381"></a>00381          this-&gt;members_.m_map = this-&gt;priv_allocate_map(this-&gt;members_.m_map_size);
<a name="l00382"></a>00382 
<a name="l00383"></a>00383          ptr_alloc_ptr nstart = this-&gt;members_.m_map + (this-&gt;members_.m_map_size - num_nodes) / 2;
<a name="l00384"></a>00384          ptr_alloc_ptr nfinish = nstart + num_nodes;
<a name="l00385"></a>00385              
<a name="l00386"></a>00386          BOOST_TRY {
<a name="l00387"></a>00387             this-&gt;priv_create_nodes(nstart, nfinish);
<a name="l00388"></a>00388          }
<a name="l00389"></a>00389          BOOST_CATCH(...){
<a name="l00390"></a>00390             this-&gt;priv_deallocate_map(this-&gt;members_.m_map, this-&gt;members_.m_map_size);
<a name="l00391"></a>00391             this-&gt;members_.m_map = 0;
<a name="l00392"></a>00392             this-&gt;members_.m_map_size = 0;
<a name="l00393"></a>00393             BOOST_RETHROW
<a name="l00394"></a>00394          }
<a name="l00395"></a>00395          BOOST_CATCH_END
<a name="l00396"></a>00396 
<a name="l00397"></a>00397          this-&gt;members_.m_start.priv_set_node(nstart);
<a name="l00398"></a>00398          this-&gt;members_.m_finish.priv_set_node(nfinish - 1);
<a name="l00399"></a>00399          this-&gt;members_.m_start.m_cur = this-&gt;members_.m_start.m_first;
<a name="l00400"></a>00400          this-&gt;members_.m_finish.m_cur = this-&gt;members_.m_finish.m_first +
<a name="l00401"></a>00401                         num_elements % s_buffer_size();
<a name="l00402"></a>00402 <span class="comment">//      }</span>
<a name="l00403"></a>00403    }
<a name="l00404"></a>00404 
<a name="l00405"></a>00405    <span class="keywordtype">void</span> priv_create_nodes(ptr_alloc_ptr nstart, ptr_alloc_ptr nfinish)
<a name="l00406"></a>00406    {
<a name="l00407"></a>00407       ptr_alloc_ptr cur;
<a name="l00408"></a>00408       BOOST_TRY {
<a name="l00409"></a>00409          <span class="keywordflow">for</span> (cur = nstart; cur &lt; nfinish; ++cur)
<a name="l00410"></a>00410             *cur = this-&gt;priv_allocate_node();
<a name="l00411"></a>00411       }
<a name="l00412"></a>00412       BOOST_CATCH(...){
<a name="l00413"></a>00413          this-&gt;priv_destroy_nodes(nstart, cur);
<a name="l00414"></a>00414          BOOST_RETHROW
<a name="l00415"></a>00415       }
<a name="l00416"></a>00416       BOOST_CATCH_END
<a name="l00417"></a>00417    }
<a name="l00418"></a>00418 
<a name="l00419"></a>00419    <span class="keywordtype">void</span> priv_destroy_nodes(ptr_alloc_ptr nstart, ptr_alloc_ptr nfinish)
<a name="l00420"></a>00420    {
<a name="l00421"></a>00421       <span class="keywordflow">for</span> (ptr_alloc_ptr n = nstart; n &lt; nfinish; ++n)
<a name="l00422"></a>00422          this-&gt;priv_deallocate_node(*n);
<a name="l00423"></a>00423    }
<a name="l00424"></a>00424 
<a name="l00425"></a>00425    <span class="keyword">enum</span> { InitialMapSize = 8 };
<a name="l00426"></a>00426 
<a name="l00427"></a>00427    <span class="keyword">protected</span>:
<a name="l00428"></a>00428    <span class="keyword">struct </span>members_holder
<a name="l00429"></a>00429       :  <span class="keyword">public</span> ptr_alloc_t
<a name="l00430"></a>00430       ,  <span class="keyword">public</span> allocator_type
<a name="l00431"></a>00431    {
<a name="l00432"></a>00432       members_holder(<span class="keyword">const</span> allocator_type &amp;a)
<a name="l00433"></a>00433          :  map_allocator_type(a), allocator_type(a)
<a name="l00434"></a><a class="code" href="classboost_1_1container_1_1deque.html">00434</a>          ,  m_map(0), m_map_size(0)
<a name="l00435"></a>00435          ,  m_start(), m_finish(m_start)
<a name="l00436"></a>00436       {}
<a name="l00437"></a>00437 
<a name="l00438"></a>00438       ptr_alloc_ptr   m_map;
<a name="l00439"></a>00439       std::size_t     m_map_size;
<a name="l00440"></a>00440       iterator        m_start;
<a name="l00441"></a>00441       iterator        m_finish;
<a name="l00442"></a>00442    } members_;
<a name="l00443"></a>00443 
<a name="l00444"></a>00444    ptr_alloc_t &amp;ptr_alloc() 
<a name="l00445"></a>00445    {  <span class="keywordflow">return</span> members_;  }
<a name="l00446"></a>00446    
<a name="l00447"></a>00447    <span class="keyword">const</span> ptr_alloc_t &amp;ptr_alloc()<span class="keyword"> const </span>
<a name="l00448"></a>00448 <span class="keyword">   </span>{  <span class="keywordflow">return</span> members_;  }
<a name="l00449"></a>00449 
<a name="l00450"></a>00450    allocator_type &amp;alloc() 
<a name="l00451"></a>00451    {  <span class="keywordflow">return</span> members_;  }
<a name="l00452"></a>00452    
<a name="l00453"></a>00453    <span class="keyword">const</span> allocator_type &amp;alloc()<span class="keyword"> const </span>
<a name="l00454"></a>00454 <span class="keyword">   </span>{  <span class="keywordflow">return</span> members_;  }
<a name="l00455"></a>00455 };
<a name="l00457"></a>00457 
<a name="l00460"></a>00460 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;
<a name="l00461"></a>00461 <span class="keyword">class </span>deque : <span class="keyword">protected</span> deque_base&lt;T, Alloc&gt;
<a name="l00462"></a>00462 {
<a name="l00464"></a>00464    <span class="keyword">typedef</span> <span class="keyword">typename</span> containers_detail::
<a name="l00465"></a>00465       move_const_ref_type&lt;T&gt;::type                    insert_const_ref_type;
<a name="l00466"></a>00466   <span class="keyword">typedef</span> deque_base&lt;T, Alloc&gt; Base;
<a name="l00467"></a>00467 
<a name="l00468"></a>00468    <span class="keyword">public</span>:                         <span class="comment">// Basic types</span>
<a name="l00469"></a>00469    <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::value_type           val_alloc_val;
<a name="l00470"></a>00470    <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::pointer              val_alloc_ptr;
<a name="l00471"></a>00471    <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::const_pointer        val_alloc_cptr;
<a name="l00472"></a>00472    <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::reference            val_alloc_ref;
<a name="l00473"></a>00473    <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::const_reference      val_alloc_cref;
<a name="l00474"></a>00474    <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::template
<a name="l00475"></a>00475       rebind&lt;val_alloc_ptr&gt;::other                ptr_alloc_t;
<a name="l00476"></a>00476    <span class="keyword">typedef</span> <span class="keyword">typename</span> ptr_alloc_t::value_type       ptr_alloc_val;
<a name="l00477"></a>00477    <span class="keyword">typedef</span> <span class="keyword">typename</span> ptr_alloc_t::pointer          ptr_alloc_ptr;
<a name="l00478"></a>00478    <span class="keyword">typedef</span> <span class="keyword">typename</span> ptr_alloc_t::const_pointer    ptr_alloc_cptr;
<a name="l00479"></a>00479    <span class="keyword">typedef</span> <span class="keyword">typename</span> ptr_alloc_t::reference        ptr_alloc_ref;
<a name="l00480"></a>00480    <span class="keyword">typedef</span> <span class="keyword">typename</span> ptr_alloc_t::const_reference  ptr_alloc_cref;
<a name="l00482"></a>00482 
<a name="l00483"></a>00483    <span class="keyword">typedef</span> T                                    value_type;
<a name="l00484"></a>00484    <span class="keyword">typedef</span> val_alloc_ptr                        pointer;
<a name="l00485"></a>00485    <span class="keyword">typedef</span> val_alloc_cptr                       const_pointer;
<a name="l00486"></a>00486    <span class="keyword">typedef</span> val_alloc_ref                        reference;
<a name="l00487"></a>00487    <span class="keyword">typedef</span> val_alloc_cref                       const_reference;
<a name="l00488"></a>00488    <span class="keyword">typedef</span> std::size_t                          size_type;
<a name="l00489"></a>00489    <span class="keyword">typedef</span> std::ptrdiff_t                       difference_type;
<a name="l00490"></a>00490 
<a name="l00491"></a>00491    <span class="keyword">typedef</span> <span class="keyword">typename</span> Base::allocator_type        allocator_type;
<a name="l00492"></a>00492 
<a name="l00493"></a>00493    <span class="keyword">public</span>:                                <span class="comment">// Iterators</span>
<a name="l00494"></a>00494    <span class="keyword">typedef</span> <span class="keyword">typename</span> Base::iterator              iterator;
<a name="l00495"></a>00495    <span class="keyword">typedef</span> <span class="keyword">typename</span> Base::const_iterator        const_iterator;
<a name="l00496"></a>00496 
<a name="l00497"></a>00497    <span class="keyword">typedef</span> std::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;
<a name="l00498"></a>00498    <span class="keyword">typedef</span> std::reverse_iterator&lt;iterator&gt;      reverse_iterator;
<a name="l00499"></a>00499 
<a name="l00501"></a>00501    <span class="keyword">private</span>:                      <span class="comment">// Internal typedefs</span>
<a name="l00502"></a>00502    BOOST_MOVE_MACRO_COPYABLE_AND_MOVABLE(deque)
<a name="l00503"></a>00503    typedef ptr_alloc_ptr index_pointer;
<a name="l00504"></a>00504    static std::<span class="keywordtype">size_t</span> s_buffer_size() 
<a name="l00505"></a>00505       { <span class="keywordflow">return</span> Base::s_buffer_size(); }
<a name="l00506"></a>00506    <span class="keyword">typedef</span> containers_detail::advanced_insert_aux_int&lt;value_type, iterator&gt; advanced_insert_aux_int_t;
<a name="l00507"></a>00507    <span class="keyword">typedef</span> repeat_iterator&lt;T, difference_type&gt;  r_iterator;
<a name="l00508"></a>00508    <span class="keyword">typedef</span> BOOST_CONTAINER_MOVE_NAMESPACE::move_iterator&lt;r_iterator&gt;    move_it;
<a name="l00509"></a>00509 
<a name="l00511"></a>00511 
<a name="l00512"></a>00512    allocator_type get_allocator()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> Base::alloc(); }
<a name="l00513"></a>00513 
<a name="l00514"></a>00514    <span class="keyword">public</span>:                         <span class="comment">// Basic accessors</span>
<a name="l00515"></a>00515 
<a name="l00516"></a>00516    iterator begin() 
<a name="l00517"></a>00517       { <span class="keywordflow">return</span> this-&gt;members_.m_start; }
<a name="l00518"></a>00518 
<a name="l00519"></a>00519    iterator end() 
<a name="l00520"></a>00520       { <span class="keywordflow">return</span> this-&gt;members_.m_finish; }
<a name="l00521"></a>00521 
<a name="l00522"></a>00522    const_iterator begin()<span class="keyword"> const </span>
<a name="l00523"></a>00523 <span class="keyword">      </span>{ <span class="keywordflow">return</span> this-&gt;members_.m_start; }
<a name="l00524"></a>00524 
<a name="l00525"></a>00525    const_iterator end()<span class="keyword"> const </span>
<a name="l00526"></a>00526 <span class="keyword">      </span>{ <span class="keywordflow">return</span> this-&gt;members_.m_finish; }
<a name="l00527"></a>00527 
<a name="l00528"></a>00528    reverse_iterator rbegin() 
<a name="l00529"></a>00529       { <span class="keywordflow">return</span> reverse_iterator(this-&gt;members_.m_finish); }
<a name="l00530"></a>00530 
<a name="l00531"></a>00531    reverse_iterator rend() 
<a name="l00532"></a>00532       { <span class="keywordflow">return</span> reverse_iterator(this-&gt;members_.m_start); }
<a name="l00533"></a>00533 
<a name="l00534"></a>00534    const_reverse_iterator rbegin()<span class="keyword"> const </span>
<a name="l00535"></a>00535 <span class="keyword">      </span>{ <span class="keywordflow">return</span> const_reverse_iterator(this-&gt;members_.m_finish); }
<a name="l00536"></a>00536 
<a name="l00537"></a>00537    const_reverse_iterator rend()<span class="keyword"> const </span>
<a name="l00538"></a>00538 <span class="keyword">      </span>{ <span class="keywordflow">return</span> const_reverse_iterator(this-&gt;members_.m_start); }
<a name="l00539"></a>00539 
<a name="l00540"></a>00540    const_iterator cbegin()<span class="keyword"> const </span>
<a name="l00541"></a>00541 <span class="keyword">      </span>{ <span class="keywordflow">return</span> this-&gt;members_.m_start; }
<a name="l00542"></a>00542 
<a name="l00543"></a>00543    const_iterator cend()<span class="keyword"> const </span>
<a name="l00544"></a>00544 <span class="keyword">      </span>{ <span class="keywordflow">return</span> this-&gt;members_.m_finish; }
<a name="l00545"></a>00545 
<a name="l00546"></a>00546    const_reverse_iterator crbegin()<span class="keyword"> const </span>
<a name="l00547"></a>00547 <span class="keyword">      </span>{ <span class="keywordflow">return</span> const_reverse_iterator(this-&gt;members_.m_finish); }
<a name="l00548"></a>00548 
<a name="l00549"></a>00549    const_reverse_iterator crend()<span class="keyword"> const </span>
<a name="l00550"></a>00550 <span class="keyword">      </span>{ <span class="keywordflow">return</span> const_reverse_iterator(this-&gt;members_.m_start); }
<a name="l00551"></a>00551 
<a name="l00552"></a>00552    reference operator[](size_type n)
<a name="l00553"></a>00553       { <span class="keywordflow">return</span> this-&gt;members_.m_start[difference_type(n)]; }
<a name="l00554"></a>00554 
<a name="l00555"></a>00555    const_reference operator[](size_type n)<span class="keyword"> const </span>
<a name="l00556"></a>00556 <span class="keyword">      </span>{ <span class="keywordflow">return</span> this-&gt;members_.m_start[difference_type(n)]; }
<a name="l00557"></a>00557 
<a name="l00558"></a>00558    <span class="keywordtype">void</span> priv_range_check(size_type n)<span class="keyword"> const </span>
<a name="l00559"></a>00559 <span class="keyword">      </span>{  <span class="keywordflow">if</span> (n &gt;= this-&gt;size())  BOOST_RETHROW std::out_of_range(<span class="stringliteral">&quot;deque&quot;</span>);   }
<a name="l00560"></a>00560 
<a name="l00561"></a>00561    reference at(size_type n)
<a name="l00562"></a>00562       { this-&gt;priv_range_check(n); <span class="keywordflow">return</span> (*<span class="keyword">this</span>)[n]; }
<a name="l00563"></a>00563 
<a name="l00564"></a>00564    const_reference at(size_type n)<span class="keyword"> const</span>
<a name="l00565"></a>00565 <span class="keyword">      </span>{ this-&gt;priv_range_check(n); <span class="keywordflow">return</span> (*<span class="keyword">this</span>)[n]; }
<a name="l00566"></a>00566 
<a name="l00567"></a>00567    reference front() { <span class="keywordflow">return</span> *this-&gt;members_.m_start; }
<a name="l00568"></a>00568 
<a name="l00569"></a>00569    reference back()  {  <span class="keywordflow">return</span> *(end()-1); }
<a name="l00570"></a>00570 
<a name="l00571"></a>00571    const_reference front()<span class="keyword"> const </span>
<a name="l00572"></a>00572 <span class="keyword">      </span>{ <span class="keywordflow">return</span> *this-&gt;members_.m_start; }
<a name="l00573"></a>00573 
<a name="l00574"></a>00574    const_reference back()<span class="keyword"> const  </span>{  <span class="keywordflow">return</span> *(cend()-1);  }
<a name="l00575"></a>00575 
<a name="l00576"></a>00576    size_type size()<span class="keyword"> const </span>
<a name="l00577"></a>00577 <span class="keyword">      </span>{ <span class="keywordflow">return</span> this-&gt;members_.m_finish - this-&gt;members_.m_start; }
<a name="l00578"></a>00578 
<a name="l00579"></a>00579    size_type max_size()<span class="keyword"> const </span>
<a name="l00580"></a>00580 <span class="keyword">      </span>{ <span class="keywordflow">return</span> this-&gt;alloc().max_size(); }
<a name="l00581"></a>00581 
<a name="l00582"></a>00582    <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>
<a name="l00583"></a>00583 <span class="keyword">   </span>{ <span class="keywordflow">return</span> this-&gt;members_.m_finish == this-&gt;members_.m_start; }
<a name="l00584"></a>00584 
<a name="l00585"></a>00585    <span class="keyword">explicit</span> deque(<span class="keyword">const</span> allocator_type&amp; a = allocator_type()) 
<a name="l00586"></a>00586       : Base(a)
<a name="l00587"></a>00587    {}
<a name="l00588"></a>00588 
<a name="l00589"></a>00589    deque(<span class="keyword">const</span> deque&amp; x)
<a name="l00590"></a>00590       :  Base(x.alloc()) 
<a name="l00591"></a>00591    {
<a name="l00592"></a>00592       <span class="keywordflow">if</span>(x.size()){
<a name="l00593"></a>00593          this-&gt;priv_initialize_map(x.size());
<a name="l00594"></a>00594          std::uninitialized_copy(x.begin(), x.end(), this-&gt;members_.m_start);
<a name="l00595"></a>00595       }
<a name="l00596"></a>00596    }
<a name="l00597"></a>00597 
<a name="l00598"></a>00598    deque(BOOST_MOVE_MACRO_RV_REF(deque) mx) 
<a name="l00599"></a>00599       :  Base(mx.alloc())
<a name="l00600"></a>00600    {  this-&gt;swap(mx);   }
<a name="l00601"></a>00601 
<a name="l00602"></a>00602    deque(size_type n, <span class="keyword">const</span> value_type&amp; value,
<a name="l00603"></a>00603          <span class="keyword">const</span> allocator_type&amp; a = allocator_type()) : Base(a, n)
<a name="l00604"></a>00604    { this-&gt;priv_fill_initialize(value); }
<a name="l00605"></a>00605 
<a name="l00606"></a>00606    <span class="keyword">explicit</span> deque(size_type n) : Base(allocator_type(), n)
<a name="l00607"></a>00607    {  this-&gt;resize(n); }
<a name="l00608"></a>00608 
<a name="l00609"></a>00609    <span class="comment">// Check whether it&#39;s an integral type.  If so, it&#39;s not an iterator.</span>
<a name="l00610"></a>00610    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InpIt&gt;
<a name="l00611"></a>00611    deque(InpIt first, InpIt last, <span class="keyword">const</span> allocator_type&amp; a = allocator_type())
<a name="l00612"></a>00612       : Base(a) 
<a name="l00613"></a>00613    {
<a name="l00614"></a>00614       <span class="comment">//Dispatch depending on integer/iterator</span>
<a name="l00615"></a>00615       <span class="keyword">const</span> <span class="keywordtype">bool</span> aux_boolean = containers_detail::is_convertible&lt;InpIt, std::size_t&gt;::value;
<a name="l00616"></a>00616       <span class="keyword">typedef</span> containers_detail::bool_&lt;aux_boolean&gt; Result;
<a name="l00617"></a>00617       this-&gt;priv_initialize_dispatch(first, last, Result());
<a name="l00618"></a>00618    }
<a name="l00619"></a>00619 
<a name="l00620"></a>00620    ~deque() 
<a name="l00621"></a>00621    {
<a name="l00622"></a>00622       priv_destroy_range(this-&gt;members_.m_start, this-&gt;members_.m_finish);
<a name="l00623"></a>00623    }
<a name="l00624"></a>00624 
<a name="l00625"></a>00625    deque&amp; operator= (BOOST_MOVE_MACRO_COPY_ASSIGN_REF(deque) x) 
<a name="l00626"></a>00626    {
<a name="l00627"></a>00627       <span class="keyword">const</span> size_type len = size();
<a name="l00628"></a>00628       <span class="keywordflow">if</span> (&amp;x != <span class="keyword">this</span>) {
<a name="l00629"></a>00629          <span class="keywordflow">if</span> (len &gt;= x.size())
<a name="l00630"></a>00630             this-&gt;erase(std::copy(x.begin(), x.end(), this-&gt;members_.m_start), this-&gt;members_.m_finish);
<a name="l00631"></a>00631          <span class="keywordflow">else</span> {
<a name="l00632"></a>00632             const_iterator mid = x.begin() + difference_type(len);
<a name="l00633"></a>00633             std::copy(x.begin(), mid, this-&gt;members_.m_start);
<a name="l00634"></a>00634             this-&gt;insert(this-&gt;members_.m_finish, mid, x.end());
<a name="l00635"></a>00635          }
<a name="l00636"></a>00636       }
<a name="l00637"></a>00637       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00638"></a>00638    }        
<a name="l00639"></a>00639 
<a name="l00640"></a>00640    deque&amp; operator= (BOOST_MOVE_MACRO_RV_REF(deque) x)
<a name="l00641"></a>00641    {
<a name="l00642"></a>00642       this-&gt;clear();
<a name="l00643"></a>00643       this-&gt;swap(x);
<a name="l00644"></a>00644       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00645"></a>00645    }
<a name="l00646"></a>00646 
<a name="l00647"></a>00647    <span class="keywordtype">void</span> swap(deque &amp;x)
<a name="l00648"></a>00648    {
<a name="l00649"></a>00649       std::swap(this-&gt;members_.m_start, x.members_.m_start);
<a name="l00650"></a>00650       std::swap(this-&gt;members_.m_finish, x.members_.m_finish);
<a name="l00651"></a>00651       std::swap(this-&gt;members_.m_map, x.members_.m_map);
<a name="l00652"></a>00652       std::swap(this-&gt;members_.m_map_size, x.members_.m_map_size);
<a name="l00653"></a>00653    }
<a name="l00654"></a>00654 
<a name="l00655"></a>00655    <span class="keywordtype">void</span> assign(size_type n, <span class="keyword">const</span> T&amp; val)
<a name="l00656"></a>00656    {  this-&gt;priv_fill_assign(n, val);  }
<a name="l00657"></a>00657 
<a name="l00658"></a>00658    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InpIt&gt;
<a name="l00659"></a>00659    <span class="keywordtype">void</span> assign(InpIt first, InpIt last)
<a name="l00660"></a>00660    {
<a name="l00661"></a>00661       <span class="comment">//Dispatch depending on integer/iterator</span>
<a name="l00662"></a>00662       <span class="keyword">const</span> <span class="keywordtype">bool</span> aux_boolean = containers_detail::is_convertible&lt;InpIt, std::size_t&gt;::value;
<a name="l00663"></a>00663       <span class="keyword">typedef</span> containers_detail::bool_&lt;aux_boolean&gt; Result;
<a name="l00664"></a>00664       this-&gt;priv_assign_dispatch(first, last, Result());
<a name="l00665"></a>00665    }
<a name="l00666"></a>00666 
<a name="l00667"></a>00667 <span class="preprocessor">   #if defined(BOOST_NO_RVALUE_REFERENCES) &amp;&amp; !defined(BOOST_MOVE_DOXYGEN_INVOKED)</span>
<a name="l00668"></a>00668 <span class="preprocessor"></span>   <span class="keywordtype">void</span> push_back(T &amp;x) { push_back(const_cast&lt;const T &amp;&gt;(x)); }
<a name="l00669"></a>00669 
<a name="l00670"></a>00670    <span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt;
<a name="l00671"></a>00671    <span class="keywordtype">void</span> push_back(<span class="keyword">const</span> U &amp;u, <span class="keyword">typename</span> containers_detail::enable_if_c&lt;containers_detail::is_same&lt;T, U&gt;::value &amp;&amp; !::BOOST_CONTAINER_MOVE_NAMESPACE::is_movable&lt;U&gt;::value &gt;::type* =0)
<a name="l00672"></a>00672    { <span class="keywordflow">return</span> priv_push_back(u); }
<a name="l00673"></a>00673 <span class="preprocessor">   #endif</span>
<a name="l00674"></a>00674 <span class="preprocessor"></span>
<a name="l00675"></a>00675    <span class="keywordtype">void</span> push_back(insert_const_ref_type t)
<a name="l00676"></a>00676    {  <span class="keywordflow">return</span> priv_push_back(t);  }
<a name="l00677"></a>00677 
<a name="l00678"></a>00678    <span class="keywordtype">void</span> push_back(BOOST_MOVE_MACRO_RV_REF(value_type) t) 
<a name="l00679"></a>00679    {
<a name="l00680"></a>00680       <span class="keywordflow">if</span>(this-&gt;priv_push_back_simple_available()){
<a name="l00681"></a>00681          <span class="keyword">new</span>(this-&gt;priv_push_back_simple_pos())value_type(BOOST_CONTAINER_MOVE_NAMESPACE::move(t));
<a name="l00682"></a>00682          this-&gt;priv_push_back_simple_commit();
<a name="l00683"></a>00683       }
<a name="l00684"></a>00684       <span class="keywordflow">else</span>{
<a name="l00685"></a>00685          this-&gt;priv_insert_aux(cend(), move_it(r_iterator(t, 1)), move_it(r_iterator()));
<a name="l00686"></a>00686       }
<a name="l00687"></a>00687    }
<a name="l00688"></a>00688 
<a name="l00689"></a>00689 <span class="preprocessor">   #if defined(BOOST_NO_RVALUE_REFERENCES) &amp;&amp; !defined(BOOST_MOVE_DOXYGEN_INVOKED)</span>
<a name="l00690"></a>00690 <span class="preprocessor"></span>   <span class="keywordtype">void</span> push_front(T &amp;x) { push_front(const_cast&lt;const T &amp;&gt;(x)); }
<a name="l00691"></a>00691 
<a name="l00692"></a>00692    <span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt;
<a name="l00693"></a>00693    <span class="keywordtype">void</span> push_front(<span class="keyword">const</span> U &amp;u, <span class="keyword">typename</span> containers_detail::enable_if_c&lt;containers_detail::is_same&lt;T, U&gt;::value &amp;&amp; !::BOOST_CONTAINER_MOVE_NAMESPACE::is_movable&lt;U&gt;::value &gt;::type* =0)
<a name="l00694"></a>00694    { <span class="keywordflow">return</span> priv_push_front(u); }
<a name="l00695"></a>00695 <span class="preprocessor">   #endif</span>
<a name="l00696"></a>00696 <span class="preprocessor"></span>
<a name="l00697"></a>00697    <span class="keywordtype">void</span> push_front(insert_const_ref_type t)
<a name="l00698"></a>00698    { <span class="keywordflow">return</span> priv_push_front(t); }
<a name="l00699"></a>00699 
<a name="l00700"></a>00700    <span class="keywordtype">void</span> push_front(BOOST_MOVE_MACRO_RV_REF(value_type) t)
<a name="l00701"></a>00701    {
<a name="l00702"></a>00702       <span class="keywordflow">if</span>(this-&gt;priv_push_front_simple_available()){
<a name="l00703"></a>00703          <span class="keyword">new</span>(this-&gt;priv_push_front_simple_pos())value_type(BOOST_CONTAINER_MOVE_NAMESPACE::move(t));
<a name="l00704"></a>00704          this-&gt;priv_push_front_simple_commit();
<a name="l00705"></a>00705       }
<a name="l00706"></a>00706       <span class="keywordflow">else</span>{
<a name="l00707"></a>00707          this-&gt;priv_insert_aux(cbegin(), move_it(r_iterator(t, 1)), move_it(r_iterator()));
<a name="l00708"></a>00708       }
<a name="l00709"></a>00709    }
<a name="l00710"></a>00710 
<a name="l00711"></a>00711    <span class="keywordtype">void</span> pop_back() 
<a name="l00712"></a>00712    {
<a name="l00713"></a>00713       <span class="keywordflow">if</span> (this-&gt;members_.m_finish.m_cur != this-&gt;members_.m_finish.m_first) {
<a name="l00714"></a>00714          --this-&gt;members_.m_finish.m_cur;
<a name="l00715"></a>00715          containers_detail::get_pointer(this-&gt;members_.m_finish.m_cur)-&gt;~value_type();
<a name="l00716"></a>00716       }
<a name="l00717"></a>00717       <span class="keywordflow">else</span>
<a name="l00718"></a>00718          this-&gt;priv_pop_back_aux();
<a name="l00719"></a>00719    }
<a name="l00720"></a>00720 
<a name="l00721"></a>00721    <span class="keywordtype">void</span> pop_front() 
<a name="l00722"></a>00722    {
<a name="l00723"></a>00723       <span class="keywordflow">if</span> (this-&gt;members_.m_start.m_cur != this-&gt;members_.m_start.m_last - 1) {
<a name="l00724"></a>00724          containers_detail::get_pointer(this-&gt;members_.m_start.m_cur)-&gt;~value_type();
<a name="l00725"></a>00725          ++this-&gt;members_.m_start.m_cur;
<a name="l00726"></a>00726       }
<a name="l00727"></a>00727       <span class="keywordflow">else</span> 
<a name="l00728"></a>00728          this-&gt;priv_pop_front_aux();
<a name="l00729"></a>00729    }
<a name="l00730"></a>00730 
<a name="l00731"></a>00731 <span class="preprocessor">   #if defined(BOOST_NO_RVALUE_REFERENCES) &amp;&amp; !defined(BOOST_MOVE_DOXYGEN_INVOKED)</span>
<a name="l00732"></a>00732 <span class="preprocessor"></span>   iterator insert(const_iterator position, T &amp;x)
<a name="l00733"></a>00733    { <span class="keywordflow">return</span> this-&gt;insert(position, const_cast&lt;const T &amp;&gt;(x)); }
<a name="l00734"></a>00734 
<a name="l00735"></a>00735    <span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt;
<a name="l00736"></a>00736    iterator insert(const_iterator position, <span class="keyword">const</span> U &amp;u, <span class="keyword">typename</span> containers_detail::enable_if_c&lt;containers_detail::is_same&lt;T, U&gt;::value &amp;&amp; !::BOOST_CONTAINER_MOVE_NAMESPACE::is_movable&lt;U&gt;::value &gt;::type* =0)
<a name="l00737"></a>00737    {  <span class="keywordflow">return</span> this-&gt;priv_insert(position, u); }
<a name="l00738"></a>00738 <span class="preprocessor">   #endif</span>
<a name="l00739"></a>00739 <span class="preprocessor"></span>
<a name="l00740"></a>00740    iterator insert(const_iterator position, insert_const_ref_type x) 
<a name="l00741"></a>00741    {  <span class="keywordflow">return</span> this-&gt;priv_insert(position, x); }
<a name="l00742"></a>00742 
<a name="l00743"></a>00743    iterator insert(const_iterator position, BOOST_MOVE_MACRO_RV_REF(value_type) mx) 
<a name="l00744"></a>00744    {
<a name="l00745"></a>00745       <span class="keywordflow">if</span> (position == cbegin()) {
<a name="l00746"></a>00746          this-&gt;push_front(BOOST_CONTAINER_MOVE_NAMESPACE::move(mx));
<a name="l00747"></a>00747          <span class="keywordflow">return</span> begin();
<a name="l00748"></a>00748       }
<a name="l00749"></a>00749       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (position == cend()) {
<a name="l00750"></a>00750          this-&gt;push_back(BOOST_CONTAINER_MOVE_NAMESPACE::move(mx));
<a name="l00751"></a>00751          <span class="keywordflow">return</span>(end()-1);
<a name="l00752"></a>00752       }
<a name="l00753"></a>00753       <span class="keywordflow">else</span> {
<a name="l00754"></a>00754          <span class="comment">//Just call more general insert(pos, size, value) and return iterator</span>
<a name="l00755"></a>00755          size_type n = position - begin();
<a name="l00756"></a>00756          this-&gt;priv_insert_aux(position, move_it(r_iterator(mx, 1)), move_it(r_iterator()));
<a name="l00757"></a>00757          <span class="keywordflow">return</span> iterator(this-&gt;begin() + n);
<a name="l00758"></a>00758       }
<a name="l00759"></a>00759    }
<a name="l00760"></a>00760 
<a name="l00761"></a>00761    <span class="keywordtype">void</span> insert(const_iterator pos, size_type n, <span class="keyword">const</span> value_type&amp; x)
<a name="l00762"></a>00762    { this-&gt;priv_fill_insert(pos, n, x); }
<a name="l00763"></a>00763 
<a name="l00764"></a>00764    <span class="comment">// Check whether it&#39;s an integral type.  If so, it&#39;s not an iterator.</span>
<a name="l00765"></a>00765    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InpIt&gt;
<a name="l00766"></a>00766    <span class="keywordtype">void</span> insert(const_iterator pos, InpIt first, InpIt last) 
<a name="l00767"></a>00767    {
<a name="l00768"></a>00768       <span class="comment">//Dispatch depending on integer/iterator</span>
<a name="l00769"></a>00769       <span class="keyword">const</span> <span class="keywordtype">bool</span> aux_boolean = containers_detail::is_convertible&lt;InpIt, std::size_t&gt;::value;
<a name="l00770"></a>00770       <span class="keyword">typedef</span> containers_detail::bool_&lt;aux_boolean&gt; Result;
<a name="l00771"></a>00771       this-&gt;priv_insert_dispatch(pos, first, last, Result());
<a name="l00772"></a>00772    }
<a name="l00773"></a>00773 
<a name="l00774"></a>00774 <span class="preprocessor">   #if defined(BOOST_CONTAINERS_PERFECT_FORWARDING) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)</span>
<a name="l00775"></a>00775 <span class="preprocessor"></span>
<a name="l00776"></a>00776    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;
<a name="l00777"></a>00777    <span class="keywordtype">void</span> emplace_back(Args&amp;&amp;... args)
<a name="l00778"></a>00778    {
<a name="l00779"></a>00779       <span class="keywordflow">if</span>(this-&gt;priv_push_back_simple_available()){
<a name="l00780"></a>00780          <span class="keyword">new</span>(this-&gt;priv_push_back_simple_pos())value_type(BOOST_CONTAINER_MOVE_NAMESPACE::forward&lt;Args&gt;(args)...);
<a name="l00781"></a>00781          this-&gt;priv_push_back_simple_commit();
<a name="l00782"></a>00782       }
<a name="l00783"></a>00783       <span class="keywordflow">else</span>{
<a name="l00784"></a>00784          <span class="keyword">typedef</span> containers_detail::advanced_insert_aux_emplace&lt;T, iterator, Args...&gt; type;
<a name="l00785"></a>00785          type &amp;&amp;proxy = type(BOOST_CONTAINER_MOVE_NAMESPACE::forward&lt;Args&gt;(args)...);
<a name="l00786"></a>00786          this-&gt;priv_insert_aux_impl(this-&gt;cend(), 1, proxy);
<a name="l00787"></a>00787       }
<a name="l00788"></a>00788    }
<a name="l00789"></a>00789 
<a name="l00790"></a>00790    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;
<a name="l00791"></a>00791    <span class="keywordtype">void</span> emplace_front(Args&amp;&amp;... args)
<a name="l00792"></a>00792    {
<a name="l00793"></a>00793       <span class="keywordflow">if</span>(this-&gt;priv_push_front_simple_available()){
<a name="l00794"></a>00794          <span class="keyword">new</span>(this-&gt;priv_push_front_simple_pos())value_type(BOOST_CONTAINER_MOVE_NAMESPACE::forward&lt;Args&gt;(args)...);
<a name="l00795"></a>00795          this-&gt;priv_push_front_simple_commit();
<a name="l00796"></a>00796       }
<a name="l00797"></a>00797       <span class="keywordflow">else</span>{
<a name="l00798"></a>00798          <span class="keyword">typedef</span> containers_detail::advanced_insert_aux_emplace&lt;T, iterator, Args...&gt; type;
<a name="l00799"></a>00799          type &amp;&amp;proxy = type(BOOST_CONTAINER_MOVE_NAMESPACE::forward&lt;Args&gt;(args)...);
<a name="l00800"></a>00800          this-&gt;priv_insert_aux_impl(this-&gt;cbegin(), 1, proxy);
<a name="l00801"></a>00801       }
<a name="l00802"></a>00802    }
<a name="l00803"></a>00803 
<a name="l00804"></a>00804    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;
<a name="l00805"></a>00805    iterator emplace(const_iterator p, Args&amp;&amp;... args)
<a name="l00806"></a>00806    {
<a name="l00807"></a>00807       <span class="keywordflow">if</span>(p == this-&gt;cbegin()){
<a name="l00808"></a>00808          this-&gt;emplace_front(BOOST_CONTAINER_MOVE_NAMESPACE::forward&lt;Args&gt;(args)...);
<a name="l00809"></a>00809          <span class="keywordflow">return</span> this-&gt;begin();
<a name="l00810"></a>00810       }
<a name="l00811"></a>00811       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(p == this-&gt;cend()){
<a name="l00812"></a>00812          this-&gt;emplace_back(BOOST_CONTAINER_MOVE_NAMESPACE::forward&lt;Args&gt;(args)...);
<a name="l00813"></a>00813          <span class="keywordflow">return</span> (this-&gt;end()-1);
<a name="l00814"></a>00814       }
<a name="l00815"></a>00815       <span class="keywordflow">else</span>{
<a name="l00816"></a>00816          size_type n = p - this-&gt;cbegin();
<a name="l00817"></a>00817          <span class="keyword">typedef</span> containers_detail::advanced_insert_aux_emplace&lt;T, iterator, Args...&gt; type;
<a name="l00818"></a>00818          type &amp;&amp;proxy = type(BOOST_CONTAINER_MOVE_NAMESPACE::forward&lt;Args&gt;(args)...);
<a name="l00819"></a>00819          this-&gt;priv_insert_aux_impl(p, 1, proxy);
<a name="l00820"></a>00820          <span class="keywordflow">return</span> iterator(this-&gt;begin() + n);
<a name="l00821"></a>00821       }
<a name="l00822"></a>00822    }
<a name="l00823"></a>00823 
<a name="l00824"></a>00824 <span class="preprocessor">   #else //#ifdef BOOST_CONTAINERS_PERFECT_FORWARDING</span>
<a name="l00825"></a>00825 <span class="preprocessor"></span>
<a name="l00826"></a>00826    <span class="comment">//0 args</span>
<a name="l00827"></a>00827    <span class="keywordtype">void</span> emplace_back()
<a name="l00828"></a>00828    {
<a name="l00829"></a>00829       <span class="keywordflow">if</span>(priv_push_front_simple_available()){
<a name="l00830"></a>00830          <span class="keyword">new</span>(priv_push_front_simple_pos())value_type();
<a name="l00831"></a>00831          priv_push_front_simple_commit();
<a name="l00832"></a>00832       }
<a name="l00833"></a>00833       <span class="keywordflow">else</span>{
<a name="l00834"></a>00834          containers_detail::advanced_insert_aux_emplace&lt;T, iterator&gt; proxy;
<a name="l00835"></a>00835          priv_insert_aux_impl(cend(), 1, proxy);
<a name="l00836"></a>00836       }
<a name="l00837"></a>00837    }
<a name="l00838"></a>00838 
<a name="l00839"></a>00839    <span class="keywordtype">void</span> emplace_front()
<a name="l00840"></a>00840    {
<a name="l00841"></a>00841       <span class="keywordflow">if</span>(priv_push_front_simple_available()){
<a name="l00842"></a>00842          <span class="keyword">new</span>(priv_push_front_simple_pos())value_type();
<a name="l00843"></a>00843          priv_push_front_simple_commit();
<a name="l00844"></a>00844       }
<a name="l00845"></a>00845       <span class="keywordflow">else</span>{
<a name="l00846"></a>00846          containers_detail::advanced_insert_aux_emplace&lt;T, iterator&gt; proxy;
<a name="l00847"></a>00847          priv_insert_aux_impl(cbegin(), 1, proxy);
<a name="l00848"></a>00848       }
<a name="l00849"></a>00849    }
<a name="l00850"></a>00850 
<a name="l00851"></a>00851    iterator emplace(const_iterator p)
<a name="l00852"></a>00852    {
<a name="l00853"></a>00853       <span class="keywordflow">if</span>(p == cbegin()){
<a name="l00854"></a>00854          emplace_front();
<a name="l00855"></a>00855          <span class="keywordflow">return</span> begin();
<a name="l00856"></a>00856       }
<a name="l00857"></a>00857       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(p == cend()){
<a name="l00858"></a>00858          emplace_back();
<a name="l00859"></a>00859          <span class="keywordflow">return</span> (end()-1);
<a name="l00860"></a>00860       }
<a name="l00861"></a>00861       <span class="keywordflow">else</span>{
<a name="l00862"></a>00862          size_type n = p - cbegin();
<a name="l00863"></a>00863          containers_detail::advanced_insert_aux_emplace&lt;T, iterator&gt; proxy;
<a name="l00864"></a>00864          priv_insert_aux_impl(p, 1, proxy);
<a name="l00865"></a>00865          <span class="keywordflow">return</span> iterator(this-&gt;begin() + n);
<a name="l00866"></a>00866       }
<a name="l00867"></a>00867    }
<a name="l00868"></a>00868 
<a name="l00869"></a>00869    <span class="comment">//advanced_insert_int.hpp includes all necessary preprocessor machinery...</span>
<a name="l00870"></a>00870 <span class="preprocessor">   #define BOOST_PP_LOCAL_MACRO(n)                                                           \</span>
<a name="l00871"></a>00871 <span class="preprocessor">   template&lt;BOOST_PP_ENUM_PARAMS(n, class P)&gt;                                                \</span>
<a name="l00872"></a>00872 <span class="preprocessor">   void emplace_back(BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_LIST, _))                  \</span>
<a name="l00873"></a>00873 <span class="preprocessor">   {                                                                                         \</span>
<a name="l00874"></a>00874 <span class="preprocessor">      if(priv_push_back_simple_available()){                                                 \</span>
<a name="l00875"></a>00875 <span class="preprocessor">         new(priv_push_back_simple_pos())value_type                                          \</span>
<a name="l00876"></a>00876 <span class="preprocessor">         (BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_FORWARD, _));                         \</span>
<a name="l00877"></a>00877 <span class="preprocessor">         priv_push_back_simple_commit();                                                     \</span>
<a name="l00878"></a>00878 <span class="preprocessor">      }                                                                                      \</span>
<a name="l00879"></a>00879 <span class="preprocessor">      else{                                                                                  \</span>
<a name="l00880"></a>00880 <span class="preprocessor">         containers_detail::BOOST_PP_CAT(BOOST_PP_CAT(advanced_insert_aux_emplace, n), arg)             \</span>
<a name="l00881"></a>00881 <span class="preprocessor">            &lt;value_type, iterator, BOOST_PP_ENUM_PARAMS(n, P)&gt;                               \</span>
<a name="l00882"></a>00882 <span class="preprocessor">               proxy(BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_FORWARD, _));              \</span>
<a name="l00883"></a>00883 <span class="preprocessor">         priv_insert_aux_impl(cend(), 1, proxy);                                             \</span>
<a name="l00884"></a>00884 <span class="preprocessor">      }                                                                                      \</span>
<a name="l00885"></a>00885 <span class="preprocessor">   }                                                                                         \</span>
<a name="l00886"></a>00886 <span class="preprocessor">                                                                                             \</span>
<a name="l00887"></a>00887 <span class="preprocessor">   template&lt;BOOST_PP_ENUM_PARAMS(n, class P)&gt;                                                \</span>
<a name="l00888"></a>00888 <span class="preprocessor">   void emplace_front(BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_LIST, _))                 \</span>
<a name="l00889"></a>00889 <span class="preprocessor">   {                                                                                         \</span>
<a name="l00890"></a>00890 <span class="preprocessor">      if(priv_push_front_simple_available()){                                                \</span>
<a name="l00891"></a>00891 <span class="preprocessor">         new(priv_push_front_simple_pos())value_type                                         \</span>
<a name="l00892"></a>00892 <span class="preprocessor">            (BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_FORWARD, _));                      \</span>
<a name="l00893"></a>00893 <span class="preprocessor">         priv_push_front_simple_commit();                                                    \</span>
<a name="l00894"></a>00894 <span class="preprocessor">      }                                                                                      \</span>
<a name="l00895"></a>00895 <span class="preprocessor">      else{                                                                                  \</span>
<a name="l00896"></a>00896 <span class="preprocessor">         containers_detail::BOOST_PP_CAT(BOOST_PP_CAT(advanced_insert_aux_emplace, n), arg)             \</span>
<a name="l00897"></a>00897 <span class="preprocessor">            &lt;value_type, iterator, BOOST_PP_ENUM_PARAMS(n, P)&gt;                               \</span>
<a name="l00898"></a>00898 <span class="preprocessor">               proxy(BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_FORWARD, _));              \</span>
<a name="l00899"></a>00899 <span class="preprocessor">         priv_insert_aux_impl(cbegin(), 1, proxy);                                           \</span>
<a name="l00900"></a>00900 <span class="preprocessor">      }                                                                                      \</span>
<a name="l00901"></a>00901 <span class="preprocessor">   }                                                                                         \</span>
<a name="l00902"></a>00902 <span class="preprocessor">                                                                                             \</span>
<a name="l00903"></a>00903 <span class="preprocessor">   template&lt;BOOST_PP_ENUM_PARAMS(n, class P)&gt;                                                \</span>
<a name="l00904"></a>00904 <span class="preprocessor">   iterator emplace(const_iterator p, BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_LIST, _)) \</span>
<a name="l00905"></a>00905 <span class="preprocessor">   {                                                                                         \</span>
<a name="l00906"></a>00906 <span class="preprocessor">      if(p == this-&gt;cbegin()){                                                               \</span>
<a name="l00907"></a>00907 <span class="preprocessor">         this-&gt;emplace_front(BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_FORWARD, _));      \</span>
<a name="l00908"></a>00908 <span class="preprocessor">         return this-&gt;begin();                                                               \</span>
<a name="l00909"></a>00909 <span class="preprocessor">      }                                                                                      \</span>
<a name="l00910"></a>00910 <span class="preprocessor">      else if(p == cend()){                                                                  \</span>
<a name="l00911"></a>00911 <span class="preprocessor">         this-&gt;emplace_back(BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_FORWARD, _));       \</span>
<a name="l00912"></a>00912 <span class="preprocessor">         return (this-&gt;end()-1);                                                             \</span>
<a name="l00913"></a>00913 <span class="preprocessor">      }                                                                                      \</span>
<a name="l00914"></a>00914 <span class="preprocessor">      else{                                                                                  \</span>
<a name="l00915"></a>00915 <span class="preprocessor">         size_type pos_num = p - this-&gt;cbegin();                                             \</span>
<a name="l00916"></a>00916 <span class="preprocessor">         containers_detail::BOOST_PP_CAT(BOOST_PP_CAT(advanced_insert_aux_emplace, n), arg)             \</span>
<a name="l00917"></a>00917 <span class="preprocessor">            &lt;value_type, iterator, BOOST_PP_ENUM_PARAMS(n, P)&gt;                               \</span>
<a name="l00918"></a>00918 <span class="preprocessor">               proxy(BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_FORWARD, _));              \</span>
<a name="l00919"></a>00919 <span class="preprocessor">         this-&gt;priv_insert_aux_impl(p, 1, proxy);                                            \</span>
<a name="l00920"></a>00920 <span class="preprocessor">         return iterator(this-&gt;begin() + pos_num);                                           \</span>
<a name="l00921"></a>00921 <span class="preprocessor">      }                                                                                      \</span>
<a name="l00922"></a>00922 <span class="preprocessor">   }                                                                                         \</span>
<a name="l00923"></a>00923 <span class="preprocessor"></span>
<a name="l00924"></a>00924 <span class="preprocessor">   #define BOOST_PP_LOCAL_LIMITS (1, BOOST_CONTAINERS_MAX_CONSTRUCTOR_PARAMETERS)</span>
<a name="l00925"></a>00925 <span class="preprocessor"></span><span class="preprocessor">   #include BOOST_PP_LOCAL_ITERATE()</span>
<a name="l00926"></a>00926 <span class="preprocessor"></span>
<a name="l00927"></a>00927 <span class="preprocessor">   #endif   //#ifdef BOOST_CONTAINERS_PERFECT_FORWARDING</span>
<a name="l00928"></a>00928 <span class="preprocessor"></span>
<a name="l00929"></a>00929    <span class="keywordtype">void</span> resize(size_type new_size, <span class="keyword">const</span> value_type&amp; x) 
<a name="l00930"></a>00930    {
<a name="l00931"></a>00931       <span class="keyword">const</span> size_type len = size();
<a name="l00932"></a>00932       <span class="keywordflow">if</span> (new_size &lt; len) 
<a name="l00933"></a>00933          this-&gt;erase(this-&gt;members_.m_start + new_size, this-&gt;members_.m_finish);
<a name="l00934"></a>00934       <span class="keywordflow">else</span>
<a name="l00935"></a>00935          this-&gt;insert(this-&gt;members_.m_finish, new_size - len, x);
<a name="l00936"></a>00936    }
<a name="l00937"></a>00937 
<a name="l00938"></a>00938    <span class="keywordtype">void</span> resize(size_type new_size) 
<a name="l00939"></a>00939    {
<a name="l00940"></a>00940       <span class="keyword">const</span> size_type len = size();
<a name="l00941"></a>00941       <span class="keywordflow">if</span> (new_size &lt; len) 
<a name="l00942"></a>00942          this-&gt;erase(this-&gt;members_.m_start + new_size, this-&gt;members_.m_finish);
<a name="l00943"></a>00943       <span class="keywordflow">else</span>{
<a name="l00944"></a>00944          size_type n = new_size - this-&gt;size();
<a name="l00945"></a>00945          containers_detail::default_construct_aux_proxy&lt;T, iterator, size_type&gt; proxy(n);
<a name="l00946"></a>00946          priv_insert_aux_impl(this-&gt;cend(), n, proxy);
<a name="l00947"></a>00947       }
<a name="l00948"></a>00948    }
<a name="l00949"></a>00949 
<a name="l00950"></a>00950    iterator erase(const_iterator pos) 
<a name="l00951"></a>00951    {
<a name="l00952"></a>00952       const_iterator next = pos;
<a name="l00953"></a>00953       ++next;
<a name="l00954"></a>00954       difference_type index = pos - this-&gt;members_.m_start;
<a name="l00955"></a>00955       <span class="keywordflow">if</span> (size_type(index) &lt; (this-&gt;size() &gt;&gt; 1)) {
<a name="l00956"></a>00956          BOOST_CONTAINER_MOVE_NAMESPACE::move_backward(begin(), iterator(pos), iterator(next));
<a name="l00957"></a>00957          pop_front();
<a name="l00958"></a>00958       }
<a name="l00959"></a>00959       <span class="keywordflow">else</span> {
<a name="l00960"></a>00960          BOOST_CONTAINER_MOVE_NAMESPACE::move(iterator(next), end(), iterator(pos));
<a name="l00961"></a>00961          pop_back();
<a name="l00962"></a>00962       }
<a name="l00963"></a>00963       <span class="keywordflow">return</span> this-&gt;members_.m_start + index;
<a name="l00964"></a>00964    }
<a name="l00965"></a>00965 
<a name="l00966"></a>00966    iterator erase(const_iterator first, const_iterator last)
<a name="l00967"></a>00967    {
<a name="l00968"></a>00968       <span class="keywordflow">if</span> (first == this-&gt;members_.m_start &amp;&amp; last == this-&gt;members_.m_finish) {
<a name="l00969"></a>00969          this-&gt;clear();
<a name="l00970"></a>00970          <span class="keywordflow">return</span> this-&gt;members_.m_finish;
<a name="l00971"></a>00971       }
<a name="l00972"></a>00972       <span class="keywordflow">else</span> {
<a name="l00973"></a>00973          difference_type n = last - first;
<a name="l00974"></a>00974          difference_type elems_before = first - this-&gt;members_.m_start;
<a name="l00975"></a>00975          <span class="keywordflow">if</span> (elems_before &lt; static_cast&lt;difference_type&gt;(this-&gt;size() - n) - elems_before) {
<a name="l00976"></a>00976             BOOST_CONTAINER_MOVE_NAMESPACE::move_backward(begin(), iterator(first), iterator(last));
<a name="l00977"></a>00977             iterator new_start = this-&gt;members_.m_start + n;
<a name="l00978"></a>00978             <span class="keywordflow">if</span>(!Base::traits_t::trivial_dctr_after_move)
<a name="l00979"></a>00979                this-&gt;priv_destroy_range(this-&gt;members_.m_start, new_start);
<a name="l00980"></a>00980             this-&gt;priv_destroy_nodes(new_start.m_node, this-&gt;members_.m_start.m_node);
<a name="l00981"></a>00981             this-&gt;members_.m_start = new_start;
<a name="l00982"></a>00982          }
<a name="l00983"></a>00983          <span class="keywordflow">else</span> {
<a name="l00984"></a>00984             BOOST_CONTAINER_MOVE_NAMESPACE::move(iterator(last), end(), iterator(first));
<a name="l00985"></a>00985             iterator new_finish = this-&gt;members_.m_finish - n;
<a name="l00986"></a>00986             <span class="keywordflow">if</span>(!Base::traits_t::trivial_dctr_after_move)
<a name="l00987"></a>00987                this-&gt;priv_destroy_range(new_finish, this-&gt;members_.m_finish);
<a name="l00988"></a>00988             this-&gt;priv_destroy_nodes(new_finish.m_node + 1, this-&gt;members_.m_finish.m_node + 1);
<a name="l00989"></a>00989             this-&gt;members_.m_finish = new_finish;
<a name="l00990"></a>00990          }
<a name="l00991"></a>00991          <span class="keywordflow">return</span> this-&gt;members_.m_start + elems_before;
<a name="l00992"></a>00992       }
<a name="l00993"></a>00993    }
<a name="l00994"></a>00994 
<a name="l00995"></a>00995    <span class="keywordtype">void</span> clear()
<a name="l00996"></a>00996    {
<a name="l00997"></a>00997       <span class="keywordflow">for</span> (index_pointer node = this-&gt;members_.m_start.m_node + 1;
<a name="l00998"></a>00998             node &lt; this-&gt;members_.m_finish.m_node;
<a name="l00999"></a>00999             ++node) {
<a name="l01000"></a>01000          this-&gt;priv_destroy_range(*node, *node + this-&gt;s_buffer_size());
<a name="l01001"></a>01001          this-&gt;priv_deallocate_node(*node);
<a name="l01002"></a>01002       }
<a name="l01003"></a>01003 
<a name="l01004"></a>01004       <span class="keywordflow">if</span> (this-&gt;members_.m_start.m_node != this-&gt;members_.m_finish.m_node) {
<a name="l01005"></a>01005          this-&gt;priv_destroy_range(this-&gt;members_.m_start.m_cur, this-&gt;members_.m_start.m_last);
<a name="l01006"></a>01006          this-&gt;priv_destroy_range(this-&gt;members_.m_finish.m_first, this-&gt;members_.m_finish.m_cur);
<a name="l01007"></a>01007          this-&gt;priv_deallocate_node(this-&gt;members_.m_finish.m_first);
<a name="l01008"></a>01008       }
<a name="l01009"></a>01009       <span class="keywordflow">else</span>
<a name="l01010"></a>01010          this-&gt;priv_destroy_range(this-&gt;members_.m_start.m_cur, this-&gt;members_.m_finish.m_cur);
<a name="l01011"></a>01011 
<a name="l01012"></a>01012       this-&gt;members_.m_finish = this-&gt;members_.m_start;
<a name="l01013"></a>01013    }
<a name="l01014"></a>01014 
<a name="l01016"></a>01016    <span class="keyword">private</span>:
<a name="l01017"></a>01017 
<a name="l01018"></a>01018    iterator priv_insert(const_iterator position, <span class="keyword">const</span> value_type &amp;x) 
<a name="l01019"></a>01019    {
<a name="l01020"></a>01020       <span class="keywordflow">if</span> (position == cbegin()){
<a name="l01021"></a>01021          this-&gt;push_front(x);
<a name="l01022"></a>01022          <span class="keywordflow">return</span> begin();
<a name="l01023"></a>01023       }
<a name="l01024"></a>01024       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (position == cend()){
<a name="l01025"></a>01025          this-&gt;push_back(x);
<a name="l01026"></a>01026          <span class="keywordflow">return</span> (end()-1);
<a name="l01027"></a>01027       }
<a name="l01028"></a>01028       <span class="keywordflow">else</span> {
<a name="l01029"></a>01029          size_type n = position - cbegin();
<a name="l01030"></a>01030          this-&gt;priv_insert_aux(position, size_type(1), x);
<a name="l01031"></a>01031          <span class="keywordflow">return</span> iterator(this-&gt;begin() + n);
<a name="l01032"></a>01032       }
<a name="l01033"></a>01033    }
<a name="l01034"></a>01034 
<a name="l01035"></a>01035    <span class="keywordtype">void</span> priv_push_front(<span class="keyword">const</span> value_type &amp;t)
<a name="l01036"></a>01036    {
<a name="l01037"></a>01037       <span class="keywordflow">if</span>(this-&gt;priv_push_front_simple_available()){
<a name="l01038"></a>01038          <span class="keyword">new</span>(this-&gt;priv_push_front_simple_pos())value_type(t);
<a name="l01039"></a>01039          this-&gt;priv_push_front_simple_commit();
<a name="l01040"></a>01040       }
<a name="l01041"></a>01041       <span class="keywordflow">else</span>{
<a name="l01042"></a>01042          this-&gt;priv_insert_aux(cbegin(), size_type(1), t);
<a name="l01043"></a>01043       }
<a name="l01044"></a>01044    }
<a name="l01045"></a>01045 
<a name="l01046"></a>01046    <span class="keywordtype">void</span> priv_push_back(<span class="keyword">const</span> value_type &amp;t)
<a name="l01047"></a>01047    {
<a name="l01048"></a>01048       <span class="keywordflow">if</span>(this-&gt;priv_push_back_simple_available()){
<a name="l01049"></a>01049          <span class="keyword">new</span>(this-&gt;priv_push_back_simple_pos())value_type(t);
<a name="l01050"></a>01050          this-&gt;priv_push_back_simple_commit();
<a name="l01051"></a>01051       }
<a name="l01052"></a>01052       <span class="keywordflow">else</span>{
<a name="l01053"></a>01053          this-&gt;priv_insert_aux(cend(), size_type(1), t);
<a name="l01054"></a>01054       }
<a name="l01055"></a>01055    }
<a name="l01056"></a>01056 
<a name="l01057"></a>01057 
<a name="l01058"></a>01058    <span class="keywordtype">bool</span> priv_push_back_simple_available()<span class="keyword"> const</span>
<a name="l01059"></a>01059 <span class="keyword">   </span>{
<a name="l01060"></a>01060       <span class="keywordflow">return</span> this-&gt;members_.m_map &amp;&amp;
<a name="l01061"></a>01061          (this-&gt;members_.m_finish.m_cur != (this-&gt;members_.m_finish.m_last - 1));
<a name="l01062"></a>01062    }
<a name="l01063"></a>01063 
<a name="l01064"></a>01064    <span class="keywordtype">void</span> *priv_push_back_simple_pos()<span class="keyword"> const</span>
<a name="l01065"></a>01065 <span class="keyword">   </span>{
<a name="l01066"></a>01066       <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(containers_detail::get_pointer(this-&gt;members_.m_finish.m_cur));
<a name="l01067"></a>01067    }
<a name="l01068"></a>01068 
<a name="l01069"></a>01069    <span class="keywordtype">void</span> priv_push_back_simple_commit()
<a name="l01070"></a>01070    {
<a name="l01071"></a>01071       ++this-&gt;members_.m_finish.m_cur;
<a name="l01072"></a>01072    }
<a name="l01073"></a>01073 
<a name="l01074"></a>01074    <span class="keywordtype">bool</span> priv_push_front_simple_available()<span class="keyword"> const</span>
<a name="l01075"></a>01075 <span class="keyword">   </span>{
<a name="l01076"></a>01076       <span class="keywordflow">return</span> this-&gt;members_.m_map &amp;&amp;
<a name="l01077"></a>01077          (this-&gt;members_.m_start.m_cur != this-&gt;members_.m_start.m_first);
<a name="l01078"></a>01078    }
<a name="l01079"></a>01079 
<a name="l01080"></a>01080    <span class="keywordtype">void</span> *priv_push_front_simple_pos()<span class="keyword"> const</span>
<a name="l01081"></a>01081 <span class="keyword">   </span>{  <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keywordtype">void</span>*<span class="keyword">&gt;</span>(containers_detail::get_pointer(this-&gt;members_.m_start.m_cur) - 1);  }
<a name="l01082"></a>01082 
<a name="l01083"></a>01083    <span class="keywordtype">void</span> priv_push_front_simple_commit()
<a name="l01084"></a>01084    {  --this-&gt;members_.m_start.m_cur;   }
<a name="l01085"></a>01085 
<a name="l01086"></a>01086    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InpIt&gt;
<a name="l01087"></a>01087    <span class="keywordtype">void</span> priv_insert_aux(const_iterator pos, InpIt first, InpIt last, std::input_iterator_tag)
<a name="l01088"></a>01088    {
<a name="l01089"></a>01089       <span class="keywordflow">for</span>(;first != last; ++first){
<a name="l01090"></a>01090          this-&gt;insert(pos, BOOST_CONTAINER_MOVE_NAMESPACE::move(value_type(*first)));
<a name="l01091"></a>01091       }
<a name="l01092"></a>01092    }
<a name="l01093"></a>01093 
<a name="l01094"></a>01094    <span class="keyword">template</span> &lt;<span class="keyword">class</span> FwdIt&gt;
<a name="l01095"></a>01095    <span class="keywordtype">void</span> priv_insert_aux(const_iterator pos, FwdIt first, FwdIt last, std::forward_iterator_tag) 
<a name="l01096"></a>01096    {  this-&gt;priv_insert_aux(pos, first, last);  }
<a name="l01097"></a>01097 
<a name="l01098"></a>01098   <span class="comment">// assign(), a generalized assignment member function.  Two</span>
<a name="l01099"></a>01099   <span class="comment">// versions: one that takes a count, and one that takes a range.</span>
<a name="l01100"></a>01100   <span class="comment">// The range version is a member template, so we dispatch on whether</span>
<a name="l01101"></a>01101   <span class="comment">// or not the type is an integer.</span>
<a name="l01102"></a>01102    <span class="keywordtype">void</span> priv_fill_assign(size_type n, <span class="keyword">const</span> T&amp; val)
<a name="l01103"></a>01103    {
<a name="l01104"></a>01104       <span class="keywordflow">if</span> (n &gt; size()) {
<a name="l01105"></a>01105          std::fill(begin(), end(), val);
<a name="l01106"></a>01106          this-&gt;insert(cend(), n - size(), val);
<a name="l01107"></a>01107       }
<a name="l01108"></a>01108       <span class="keywordflow">else</span> {
<a name="l01109"></a>01109          this-&gt;erase(cbegin() + n, cend());
<a name="l01110"></a>01110          std::fill(begin(), end(), val);
<a name="l01111"></a>01111       }
<a name="l01112"></a>01112    }
<a name="l01113"></a>01113 
<a name="l01114"></a>01114    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Integer&gt;
<a name="l01115"></a>01115    <span class="keywordtype">void</span> priv_initialize_dispatch(Integer n, Integer x, containers_detail::true_) 
<a name="l01116"></a>01116    {
<a name="l01117"></a>01117       this-&gt;priv_initialize_map(n);
<a name="l01118"></a>01118       this-&gt;priv_fill_initialize(x);
<a name="l01119"></a>01119    }
<a name="l01120"></a>01120 
<a name="l01121"></a>01121    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InpIt&gt;
<a name="l01122"></a>01122    <span class="keywordtype">void</span> priv_initialize_dispatch(InpIt first, InpIt last, containers_detail::false_) 
<a name="l01123"></a>01123    {
<a name="l01124"></a>01124       <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;InpIt&gt;::iterator_category ItCat;
<a name="l01125"></a>01125       this-&gt;priv_range_initialize(first, last, ItCat());
<a name="l01126"></a>01126    }
<a name="l01127"></a>01127 
<a name="l01128"></a>01128    <span class="keywordtype">void</span> priv_destroy_range(iterator p, iterator p2)
<a name="l01129"></a>01129    {
<a name="l01130"></a>01130       <span class="keywordflow">for</span>(;p != p2; ++p)
<a name="l01131"></a>01131          containers_detail::get_pointer(&amp;*p)-&gt;~value_type();
<a name="l01132"></a>01132    }
<a name="l01133"></a>01133 
<a name="l01134"></a>01134    <span class="keywordtype">void</span> priv_destroy_range(pointer p, pointer p2)
<a name="l01135"></a>01135    {
<a name="l01136"></a>01136       <span class="keywordflow">for</span>(;p != p2; ++p)
<a name="l01137"></a>01137          containers_detail::get_pointer(&amp;*p)-&gt;~value_type();
<a name="l01138"></a>01138    }
<a name="l01139"></a>01139 
<a name="l01140"></a>01140    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Integer&gt;
<a name="l01141"></a>01141    <span class="keywordtype">void</span> priv_assign_dispatch(Integer n, Integer val, containers_detail::true_)
<a name="l01142"></a>01142       { this-&gt;priv_fill_assign((size_type) n, val); }
<a name="l01143"></a>01143 
<a name="l01144"></a>01144    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InpIt&gt;
<a name="l01145"></a>01145    <span class="keywordtype">void</span> priv_assign_dispatch(InpIt first, InpIt last, containers_detail::false_) 
<a name="l01146"></a>01146    {
<a name="l01147"></a>01147       <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;InpIt&gt;::iterator_category ItCat;
<a name="l01148"></a>01148       this-&gt;priv_assign_aux(first, last, ItCat());
<a name="l01149"></a>01149    }
<a name="l01150"></a>01150 
<a name="l01151"></a>01151    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InpIt&gt;
<a name="l01152"></a>01152    <span class="keywordtype">void</span> priv_assign_aux(InpIt first, InpIt last, std::input_iterator_tag)
<a name="l01153"></a>01153    {
<a name="l01154"></a>01154       iterator cur = begin();
<a name="l01155"></a>01155       <span class="keywordflow">for</span> ( ; first != last &amp;&amp; cur != end(); ++cur, ++first)
<a name="l01156"></a>01156          *cur = *first;
<a name="l01157"></a>01157       <span class="keywordflow">if</span> (first == last)
<a name="l01158"></a>01158          this-&gt;erase(cur, cend());
<a name="l01159"></a>01159       <span class="keywordflow">else</span>
<a name="l01160"></a>01160          this-&gt;insert(cend(), first, last);
<a name="l01161"></a>01161    }
<a name="l01162"></a>01162 
<a name="l01163"></a>01163    <span class="keyword">template</span> &lt;<span class="keyword">class</span> FwdIt&gt;
<a name="l01164"></a>01164    <span class="keywordtype">void</span> priv_assign_aux(FwdIt first, FwdIt last, std::forward_iterator_tag)
<a name="l01165"></a>01165    {
<a name="l01166"></a>01166       size_type len = std::distance(first, last);
<a name="l01167"></a>01167       <span class="keywordflow">if</span> (len &gt; size()) {
<a name="l01168"></a>01168          FwdIt mid = first;
<a name="l01169"></a>01169          std::advance(mid, size());
<a name="l01170"></a>01170          std::copy(first, mid, begin());
<a name="l01171"></a>01171          this-&gt;insert(cend(), mid, last);
<a name="l01172"></a>01172       }
<a name="l01173"></a>01173       <span class="keywordflow">else</span>
<a name="l01174"></a>01174          this-&gt;erase(std::copy(first, last, begin()), cend());
<a name="l01175"></a>01175    }
<a name="l01176"></a>01176 
<a name="l01177"></a>01177    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Integer&gt;
<a name="l01178"></a>01178    <span class="keywordtype">void</span> priv_insert_dispatch(const_iterator pos, Integer n, Integer x, containers_detail::true_) 
<a name="l01179"></a>01179    {  this-&gt;priv_fill_insert(pos, (size_type) n, x); }
<a name="l01180"></a>01180 
<a name="l01181"></a>01181    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InpIt&gt;
<a name="l01182"></a>01182    <span class="keywordtype">void</span> priv_insert_dispatch(const_iterator pos,InpIt first, InpIt last, containers_detail::false_) 
<a name="l01183"></a>01183    {
<a name="l01184"></a>01184       <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;InpIt&gt;::iterator_category ItCat;
<a name="l01185"></a>01185       this-&gt;priv_insert_aux(pos, first, last, ItCat());
<a name="l01186"></a>01186    }
<a name="l01187"></a>01187 
<a name="l01188"></a>01188    <span class="keywordtype">void</span> priv_insert_aux(const_iterator pos, size_type n, <span class="keyword">const</span> value_type&amp; x)
<a name="l01189"></a>01189    {
<a name="l01190"></a>01190       <span class="keyword">typedef</span> constant_iterator&lt;value_type, difference_type&gt; c_it;
<a name="l01191"></a>01191       this-&gt;priv_insert_aux(pos, c_it(x, n), c_it());
<a name="l01192"></a>01192    }
<a name="l01193"></a>01193 
<a name="l01194"></a>01194    <span class="comment">//Just forward all operations to priv_insert_aux_impl</span>
<a name="l01195"></a>01195    <span class="keyword">template</span> &lt;<span class="keyword">class</span> FwdIt&gt;
<a name="l01196"></a>01196    <span class="keywordtype">void</span> priv_insert_aux(const_iterator p, FwdIt first, FwdIt last)
<a name="l01197"></a>01197    {
<a name="l01198"></a>01198       containers_detail::advanced_insert_aux_proxy&lt;T, FwdIt, iterator&gt; proxy(first, last);
<a name="l01199"></a>01199       priv_insert_aux_impl(p, (size_type)std::distance(first, last), proxy);
<a name="l01200"></a>01200    }
<a name="l01201"></a>01201 
<a name="l01202"></a>01202    <span class="keywordtype">void</span> priv_insert_aux_impl(const_iterator p, size_type n, advanced_insert_aux_int_t &amp;interf)
<a name="l01203"></a>01203    {
<a name="l01204"></a>01204       iterator pos(p);
<a name="l01205"></a>01205       <span class="keywordflow">if</span>(!this-&gt;members_.m_map){
<a name="l01206"></a>01206          this-&gt;priv_initialize_map(0);
<a name="l01207"></a>01207          pos = this-&gt;begin();
<a name="l01208"></a>01208       }
<a name="l01209"></a>01209 
<a name="l01210"></a>01210       <span class="keyword">const</span> difference_type elemsbefore = pos - this-&gt;members_.m_start;
<a name="l01211"></a>01211       size_type length = this-&gt;size();
<a name="l01212"></a>01212       <span class="keywordflow">if</span> (elemsbefore &lt; static_cast&lt;difference_type&gt;(length / 2)) {
<a name="l01213"></a>01213          iterator new_start = this-&gt;priv_reserve_elements_at_front(n);
<a name="l01214"></a>01214          iterator old_start = this-&gt;members_.m_start;
<a name="l01215"></a>01215          pos = this-&gt;members_.m_start + elemsbefore;
<a name="l01216"></a>01216          <span class="keywordflow">if</span> (elemsbefore &gt;= difference_type(n)) {
<a name="l01217"></a>01217             iterator start_n = this-&gt;members_.m_start + difference_type(n); 
<a name="l01218"></a>01218             ::BOOST_CONTAINER_MOVE_NAMESPACE::uninitialized_move(this-&gt;members_.m_start, start_n, new_start);
<a name="l01219"></a>01219             this-&gt;members_.m_start = new_start;
<a name="l01220"></a>01220             BOOST_CONTAINER_MOVE_NAMESPACE::move(start_n, pos, old_start);
<a name="l01221"></a>01221             interf.copy_all_to(pos - difference_type(n));
<a name="l01222"></a>01222          }
<a name="l01223"></a>01223          <span class="keywordflow">else</span> {
<a name="l01224"></a>01224             difference_type mid_count = (difference_type(n) - elemsbefore);
<a name="l01225"></a>01225             iterator mid_start = old_start - mid_count;
<a name="l01226"></a>01226             interf.uninitialized_copy_some_and_update(mid_start, mid_count, <span class="keyword">true</span>);
<a name="l01227"></a>01227             this-&gt;members_.m_start = mid_start;
<a name="l01228"></a>01228             ::BOOST_CONTAINER_MOVE_NAMESPACE::uninitialized_move(old_start, pos, new_start);
<a name="l01229"></a>01229             this-&gt;members_.m_start = new_start;
<a name="l01230"></a>01230             interf.copy_all_to(old_start);
<a name="l01231"></a>01231          }
<a name="l01232"></a>01232       }
<a name="l01233"></a>01233       <span class="keywordflow">else</span> {
<a name="l01234"></a>01234          iterator new_finish = this-&gt;priv_reserve_elements_at_back(n);
<a name="l01235"></a>01235          iterator old_finish = this-&gt;members_.m_finish;
<a name="l01236"></a>01236          <span class="keyword">const</span> difference_type elemsafter = 
<a name="l01237"></a>01237             difference_type(length) - elemsbefore;
<a name="l01238"></a>01238          pos = this-&gt;members_.m_finish - elemsafter;
<a name="l01239"></a>01239          <span class="keywordflow">if</span> (elemsafter &gt;= difference_type(n)) {
<a name="l01240"></a>01240             iterator finish_n = this-&gt;members_.m_finish - difference_type(n);
<a name="l01241"></a>01241             ::BOOST_CONTAINER_MOVE_NAMESPACE::uninitialized_move(finish_n, this-&gt;members_.m_finish, this-&gt;members_.m_finish);
<a name="l01242"></a>01242             this-&gt;members_.m_finish = new_finish;
<a name="l01243"></a>01243             BOOST_CONTAINER_MOVE_NAMESPACE::move_backward(pos, finish_n, old_finish);
<a name="l01244"></a>01244             interf.copy_all_to(pos);
<a name="l01245"></a>01245          }
<a name="l01246"></a>01246          <span class="keywordflow">else</span> {
<a name="l01247"></a>01247             interf.uninitialized_copy_some_and_update(old_finish, elemsafter, <span class="keyword">false</span>);
<a name="l01248"></a>01248             this-&gt;members_.m_finish += n-elemsafter;
<a name="l01249"></a>01249             ::BOOST_CONTAINER_MOVE_NAMESPACE::uninitialized_move(pos, old_finish, this-&gt;members_.m_finish);
<a name="l01250"></a>01250             this-&gt;members_.m_finish = new_finish;
<a name="l01251"></a>01251             interf.copy_all_to(pos);
<a name="l01252"></a>01252          }
<a name="l01253"></a>01253       }
<a name="l01254"></a>01254    }
<a name="l01255"></a>01255 
<a name="l01256"></a>01256    <span class="keywordtype">void</span> priv_fill_insert(const_iterator pos, size_type n, <span class="keyword">const</span> value_type&amp; x)
<a name="l01257"></a>01257    {
<a name="l01258"></a>01258       <span class="keyword">typedef</span> constant_iterator&lt;value_type, difference_type&gt; c_it;
<a name="l01259"></a>01259       this-&gt;insert(pos, c_it(x, n), c_it());
<a name="l01260"></a>01260    }
<a name="l01261"></a>01261 
<a name="l01262"></a>01262    <span class="comment">// Precondition: this-&gt;members_.m_start and this-&gt;members_.m_finish have already been initialized,</span>
<a name="l01263"></a>01263    <span class="comment">// but none of the deque&#39;s elements have yet been constructed.</span>
<a name="l01264"></a>01264    <span class="keywordtype">void</span> priv_fill_initialize(<span class="keyword">const</span> value_type&amp; value) 
<a name="l01265"></a>01265    {
<a name="l01266"></a>01266       index_pointer cur;
<a name="l01267"></a>01267       BOOST_TRY {
<a name="l01268"></a>01268          <span class="keywordflow">for</span> (cur = this-&gt;members_.m_start.m_node; cur &lt; this-&gt;members_.m_finish.m_node; ++cur){
<a name="l01269"></a>01269             std::uninitialized_fill(*cur, *cur + this-&gt;s_buffer_size(), value);
<a name="l01270"></a>01270          }
<a name="l01271"></a>01271          std::uninitialized_fill(this-&gt;members_.m_finish.m_first, this-&gt;members_.m_finish.m_cur, value);
<a name="l01272"></a>01272       }
<a name="l01273"></a>01273       BOOST_CATCH(...){
<a name="l01274"></a>01274          this-&gt;priv_destroy_range(this-&gt;members_.m_start, iterator(*cur, cur));
<a name="l01275"></a>01275          BOOST_RETHROW
<a name="l01276"></a>01276       }
<a name="l01277"></a>01277       BOOST_CATCH_END
<a name="l01278"></a>01278    }
<a name="l01279"></a>01279 
<a name="l01280"></a>01280    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InpIt&gt;
<a name="l01281"></a>01281    <span class="keywordtype">void</span> priv_range_initialize(InpIt first, InpIt last, std::input_iterator_tag)
<a name="l01282"></a>01282    {
<a name="l01283"></a>01283       this-&gt;priv_initialize_map(0);
<a name="l01284"></a>01284       BOOST_TRY {
<a name="l01285"></a>01285          <span class="keywordflow">for</span> ( ; first != last; ++first)
<a name="l01286"></a>01286             this-&gt;push_back(*first);
<a name="l01287"></a>01287       }
<a name="l01288"></a>01288       BOOST_CATCH(...){
<a name="l01289"></a>01289          this-&gt;clear();
<a name="l01290"></a>01290          BOOST_RETHROW
<a name="l01291"></a>01291       }
<a name="l01292"></a>01292       BOOST_CATCH_END
<a name="l01293"></a>01293    }
<a name="l01294"></a>01294 
<a name="l01295"></a>01295    <span class="keyword">template</span> &lt;<span class="keyword">class</span> FwdIt&gt;
<a name="l01296"></a>01296    <span class="keywordtype">void</span> priv_range_initialize(FwdIt first, FwdIt last, std::forward_iterator_tag)
<a name="l01297"></a>01297    {
<a name="l01298"></a>01298       size_type n = 0;
<a name="l01299"></a>01299       n = std::distance(first, last);
<a name="l01300"></a>01300       this-&gt;priv_initialize_map(n);
<a name="l01301"></a>01301 
<a name="l01302"></a>01302       index_pointer cur_node;
<a name="l01303"></a>01303       BOOST_TRY {
<a name="l01304"></a>01304          <span class="keywordflow">for</span> (cur_node = this-&gt;members_.m_start.m_node; 
<a name="l01305"></a>01305                cur_node &lt; this-&gt;members_.m_finish.m_node; 
<a name="l01306"></a>01306                ++cur_node) {
<a name="l01307"></a>01307             FwdIt mid = first;
<a name="l01308"></a>01308             std::advance(mid, this-&gt;s_buffer_size());
<a name="l01309"></a>01309             ::BOOST_CONTAINER_MOVE_NAMESPACE::uninitialized_copy_or_move(first, mid, *cur_node);
<a name="l01310"></a>01310             first = mid;
<a name="l01311"></a>01311          }
<a name="l01312"></a>01312          ::BOOST_CONTAINER_MOVE_NAMESPACE::uninitialized_copy_or_move(first, last, this-&gt;members_.m_finish.m_first);
<a name="l01313"></a>01313       }
<a name="l01314"></a>01314       BOOST_CATCH(...){
<a name="l01315"></a>01315          this-&gt;priv_destroy_range(this-&gt;members_.m_start, iterator(*cur_node, cur_node));
<a name="l01316"></a>01316          BOOST_RETHROW
<a name="l01317"></a>01317       }
<a name="l01318"></a>01318       BOOST_CATCH_END
<a name="l01319"></a>01319    }
<a name="l01320"></a>01320 
<a name="l01321"></a>01321    <span class="comment">// Called only if this-&gt;members_.m_finish.m_cur == this-&gt;members_.m_finish.m_first.</span>
<a name="l01322"></a>01322    <span class="keywordtype">void</span> priv_pop_back_aux()
<a name="l01323"></a>01323    {
<a name="l01324"></a>01324       this-&gt;priv_deallocate_node(this-&gt;members_.m_finish.m_first);
<a name="l01325"></a>01325       this-&gt;members_.m_finish.priv_set_node(this-&gt;members_.m_finish.m_node - 1);
<a name="l01326"></a>01326       this-&gt;members_.m_finish.m_cur = this-&gt;members_.m_finish.m_last - 1;
<a name="l01327"></a>01327       containers_detail::get_pointer(this-&gt;members_.m_finish.m_cur)-&gt;~value_type();
<a name="l01328"></a>01328    }
<a name="l01329"></a>01329 
<a name="l01330"></a>01330    <span class="comment">// Called only if this-&gt;members_.m_start.m_cur == this-&gt;members_.m_start.m_last - 1.  Note that </span>
<a name="l01331"></a>01331    <span class="comment">// if the deque has at least one element (a precondition for this member </span>
<a name="l01332"></a>01332    <span class="comment">// function), and if this-&gt;members_.m_start.m_cur == this-&gt;members_.m_start.m_last, then the deque </span>
<a name="l01333"></a>01333    <span class="comment">// must have at least two nodes.</span>
<a name="l01334"></a>01334    <span class="keywordtype">void</span> priv_pop_front_aux()
<a name="l01335"></a>01335    {
<a name="l01336"></a>01336       containers_detail::get_pointer(this-&gt;members_.m_start.m_cur)-&gt;~value_type();
<a name="l01337"></a>01337       this-&gt;priv_deallocate_node(this-&gt;members_.m_start.m_first);
<a name="l01338"></a>01338       this-&gt;members_.m_start.priv_set_node(this-&gt;members_.m_start.m_node + 1);
<a name="l01339"></a>01339       this-&gt;members_.m_start.m_cur = this-&gt;members_.m_start.m_first;
<a name="l01340"></a>01340    }      
<a name="l01341"></a>01341 
<a name="l01342"></a>01342    iterator priv_reserve_elements_at_front(size_type n) 
<a name="l01343"></a>01343    {
<a name="l01344"></a>01344       size_type vacancies = this-&gt;members_.m_start.m_cur - this-&gt;members_.m_start.m_first;
<a name="l01345"></a>01345       <span class="keywordflow">if</span> (n &gt; vacancies){
<a name="l01346"></a>01346          size_type new_elems = n-vacancies;
<a name="l01347"></a>01347          size_type new_nodes = (new_elems + this-&gt;s_buffer_size() - 1) / 
<a name="l01348"></a>01348             this-&gt;s_buffer_size();
<a name="l01349"></a>01349          size_type s = (size_type)(this-&gt;members_.m_start.m_node - this-&gt;members_.m_map);
<a name="l01350"></a>01350          <span class="keywordflow">if</span> (new_nodes &gt; s){
<a name="l01351"></a>01351             this-&gt;priv_reallocate_map(new_nodes, <span class="keyword">true</span>);
<a name="l01352"></a>01352          }
<a name="l01353"></a>01353          size_type i = 1;
<a name="l01354"></a>01354          BOOST_TRY {
<a name="l01355"></a>01355             <span class="keywordflow">for</span> (; i &lt;= new_nodes; ++i)
<a name="l01356"></a>01356                *(this-&gt;members_.m_start.m_node - i) = this-&gt;priv_allocate_node();
<a name="l01357"></a>01357          }
<a name="l01358"></a>01358          BOOST_CATCH(...) {
<a name="l01359"></a>01359             <span class="keywordflow">for</span> (size_type j = 1; j &lt; i; ++j)
<a name="l01360"></a>01360                this-&gt;priv_deallocate_node(*(this-&gt;members_.m_start.m_node - j));      
<a name="l01361"></a>01361             BOOST_RETHROW
<a name="l01362"></a>01362          }
<a name="l01363"></a>01363          BOOST_CATCH_END
<a name="l01364"></a>01364       }
<a name="l01365"></a>01365       <span class="keywordflow">return</span> this-&gt;members_.m_start - difference_type(n);
<a name="l01366"></a>01366    }
<a name="l01367"></a>01367 
<a name="l01368"></a>01368    iterator priv_reserve_elements_at_back(size_type n) 
<a name="l01369"></a>01369    {
<a name="l01370"></a>01370       size_type vacancies = (this-&gt;members_.m_finish.m_last - this-&gt;members_.m_finish.m_cur) - 1;
<a name="l01371"></a>01371       <span class="keywordflow">if</span> (n &gt; vacancies){
<a name="l01372"></a>01372          size_type new_elems = n - vacancies;
<a name="l01373"></a>01373          size_type new_nodes = (new_elems + this-&gt;s_buffer_size() - 1)/s_buffer_size();
<a name="l01374"></a>01374          size_type s = (size_type)(this-&gt;members_.m_map_size - (this-&gt;members_.m_finish.m_node - this-&gt;members_.m_map));
<a name="l01375"></a>01375          <span class="keywordflow">if</span> (new_nodes + 1 &gt; s){
<a name="l01376"></a>01376             this-&gt;priv_reallocate_map(new_nodes, <span class="keyword">false</span>);
<a name="l01377"></a>01377          }
<a name="l01378"></a>01378          size_type i;
<a name="l01379"></a>01379          BOOST_TRY {
<a name="l01380"></a>01380             <span class="keywordflow">for</span> (i = 1; i &lt;= new_nodes; ++i)
<a name="l01381"></a>01381                *(this-&gt;members_.m_finish.m_node + i) = this-&gt;priv_allocate_node();
<a name="l01382"></a>01382          }
<a name="l01383"></a>01383          BOOST_CATCH(...) {
<a name="l01384"></a>01384             <span class="keywordflow">for</span> (size_type j = 1; j &lt; i; ++j)
<a name="l01385"></a>01385                this-&gt;priv_deallocate_node(*(this-&gt;members_.m_finish.m_node + j));      
<a name="l01386"></a>01386             BOOST_RETHROW
<a name="l01387"></a>01387          }
<a name="l01388"></a>01388          BOOST_CATCH_END
<a name="l01389"></a>01389       }
<a name="l01390"></a>01390       <span class="keywordflow">return</span> this-&gt;members_.m_finish + difference_type(n);
<a name="l01391"></a>01391    }
<a name="l01392"></a>01392 
<a name="l01393"></a>01393    <span class="keywordtype">void</span> priv_reallocate_map(size_type nodes_to_add, <span class="keywordtype">bool</span> add_at_front)
<a name="l01394"></a>01394    {
<a name="l01395"></a>01395       size_type old_num_nodes = this-&gt;members_.m_finish.m_node - this-&gt;members_.m_start.m_node + 1;
<a name="l01396"></a>01396       size_type new_num_nodes = old_num_nodes + nodes_to_add;
<a name="l01397"></a>01397 
<a name="l01398"></a>01398       index_pointer new_nstart;
<a name="l01399"></a>01399       <span class="keywordflow">if</span> (this-&gt;members_.m_map_size &gt; 2 * new_num_nodes) {
<a name="l01400"></a>01400          new_nstart = this-&gt;members_.m_map + (this-&gt;members_.m_map_size - new_num_nodes) / 2 
<a name="l01401"></a>01401                            + (add_at_front ? nodes_to_add : 0);
<a name="l01402"></a>01402          <span class="keywordflow">if</span> (new_nstart &lt; this-&gt;members_.m_start.m_node)
<a name="l01403"></a>01403             BOOST_CONTAINER_MOVE_NAMESPACE::move(this-&gt;members_.m_start.m_node, this-&gt;members_.m_finish.m_node + 1, new_nstart);
<a name="l01404"></a>01404          <span class="keywordflow">else</span>
<a name="l01405"></a>01405             BOOST_CONTAINER_MOVE_NAMESPACE::move_backward
<a name="l01406"></a>01406                (this-&gt;members_.m_start.m_node, this-&gt;members_.m_finish.m_node + 1, new_nstart + old_num_nodes);
<a name="l01407"></a>01407       }
<a name="l01408"></a>01408       <span class="keywordflow">else</span> {
<a name="l01409"></a>01409          size_type new_map_size = 
<a name="l01410"></a>01410             this-&gt;members_.m_map_size + containers_detail::max_value(this-&gt;members_.m_map_size, nodes_to_add) + 2;
<a name="l01411"></a>01411 
<a name="l01412"></a>01412          index_pointer new_map = this-&gt;priv_allocate_map(new_map_size);
<a name="l01413"></a>01413          new_nstart = new_map + (new_map_size - new_num_nodes) / 2
<a name="l01414"></a>01414                               + (add_at_front ? nodes_to_add : 0);
<a name="l01415"></a>01415          BOOST_CONTAINER_MOVE_NAMESPACE::move(this-&gt;members_.m_start.m_node, this-&gt;members_.m_finish.m_node + 1, new_nstart);
<a name="l01416"></a>01416          this-&gt;priv_deallocate_map(this-&gt;members_.m_map, this-&gt;members_.m_map_size);
<a name="l01417"></a>01417 
<a name="l01418"></a>01418          this-&gt;members_.m_map = new_map;
<a name="l01419"></a>01419          this-&gt;members_.m_map_size = new_map_size;
<a name="l01420"></a>01420       }
<a name="l01421"></a>01421 
<a name="l01422"></a>01422       this-&gt;members_.m_start.priv_set_node(new_nstart);
<a name="l01423"></a>01423       this-&gt;members_.m_finish.priv_set_node(new_nstart + old_num_nodes - 1);
<a name="l01424"></a>01424    }
<a name="l01426"></a>01426 };
<a name="l01427"></a>01427 
<a name="l01428"></a>01428 <span class="comment">// Nonmember functions.</span>
<a name="l01429"></a>01429 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;
<a name="l01430"></a>01430 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> deque&lt;T, Alloc&gt;&amp; x,
<a name="l01431"></a>01431                        <span class="keyword">const</span> deque&lt;T, Alloc&gt;&amp; y)
<a name="l01432"></a>01432 {
<a name="l01433"></a>01433    <span class="keywordflow">return</span> x.size() == y.size() &amp;&amp; equal(x.begin(), x.end(), y.begin());
<a name="l01434"></a>01434 }
<a name="l01435"></a>01435 
<a name="l01436"></a>01436 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;
<a name="l01437"></a>01437 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&lt;(const deque&lt;T, Alloc&gt;&amp; x,
<a name="l01438"></a>01438                       <span class="keyword">const</span> deque&lt;T, Alloc&gt;&amp; y) 
<a name="l01439"></a>01439 {
<a name="l01440"></a>01440    <span class="keywordflow">return</span> lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
<a name="l01441"></a>01441 }
<a name="l01442"></a>01442 
<a name="l01443"></a>01443 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;
<a name="l01444"></a>01444 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> deque&lt;T, Alloc&gt;&amp; x,
<a name="l01445"></a>01445                        <span class="keyword">const</span> deque&lt;T, Alloc&gt;&amp; y) 
<a name="l01446"></a>01446    {  <span class="keywordflow">return</span> !(x == y);   }
<a name="l01447"></a>01447 
<a name="l01448"></a>01448 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;
<a name="l01449"></a>01449 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&gt;(<span class="keyword">const</span> deque&lt;T, Alloc&gt;&amp; x,
<a name="l01450"></a>01450                       <span class="keyword">const</span> deque&lt;T, Alloc&gt;&amp; y) 
<a name="l01451"></a>01451    {  <span class="keywordflow">return</span> y &lt; x; }
<a name="l01452"></a>01452 
<a name="l01453"></a>01453 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;
<a name="l01454"></a>01454 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&lt;=(const deque&lt;T, Alloc&gt;&amp; x,
<a name="l01455"></a>01455                        <span class="keyword">const</span> deque&lt;T, Alloc&gt;&amp; y) 
<a name="l01456"></a>01456    {  <span class="keywordflow">return</span> !(y &lt; x); }
<a name="l01457"></a>01457 
<a name="l01458"></a>01458 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Alloc&gt;
<a name="l01459"></a>01459 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&gt;=(<span class="keyword">const</span> deque&lt;T, Alloc&gt;&amp; x,
<a name="l01460"></a>01460                        <span class="keyword">const</span> deque&lt;T, Alloc&gt;&amp; y) 
<a name="l01461"></a>01461    {  <span class="keywordflow">return</span> !(x &lt; y); }
<a name="l01462"></a>01462 
<a name="l01463"></a>01463 
<a name="l01464"></a>01464 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> A&gt;
<a name="l01465"></a>01465 <span class="keyword">inline</span> <span class="keywordtype">void</span> swap(deque&lt;T, A&gt;&amp; x, deque&lt;T, A&gt;&amp; y)
<a name="l01466"></a>01466 {  x.swap(y);  }
<a name="l01467"></a>01467 
<a name="l01468"></a>01468 }}
<a name="l01469"></a>01469 
<a name="l01471"></a>01471 
<a name="l01472"></a>01472 <span class="keyword">namespace </span>boost {
<a name="l01473"></a>01473 <span class="comment">/*</span>
<a name="l01476"></a>01476 <span class="comment">template &lt;class T, class A&gt;</span>
<a name="l01477"></a>01477 <span class="comment">struct has_trivial_destructor_after_move&lt;boost::container::deque&lt;T, A&gt; &gt;</span>
<a name="l01478"></a>01478 <span class="comment">{</span>
<a name="l01479"></a>01479 <span class="comment">   enum {   value = has_trivial_destructor&lt;A&gt;::value  };</span>
<a name="l01480"></a>01480 <span class="comment">};</span>
<a name="l01481"></a>01481 <span class="comment">*/</span>
<a name="l01482"></a>01482 }
<a name="l01483"></a>01483 
<a name="l01485"></a>01485 
<a name="l01486"></a>01486 <span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_CONFIG_END_HPP</span>
<a name="l01487"></a>01487 <span class="preprocessor"></span>
<a name="l01488"></a>01488 <span class="preprocessor">#endif //   #ifndef  BOOST_CONTAINERS_DEQUE_HPP</span>
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Apr 27 2011 00:50:03 for Nutcracker by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
