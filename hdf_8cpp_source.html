<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nutcracker: hdf.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script src="http://www.mathjax.org/mathjax/MathJax.js">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Nutcracker</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>hdf.cpp</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//@+leo-ver=5-thin</span>
<a name="l00002"></a>00002 <span class="comment">//@+node:gcross.20110511141322.2209: * @file hdf.cpp</span>
<a name="l00003"></a>00003 <span class="comment">//@@language cplusplus</span>
<a name="l00004"></a>00004 
<a name="l00005"></a>00005 <span class="comment">//@+&lt;&lt; License &gt;&gt;</span>
<a name="l00006"></a>00006 <span class="comment">//@+node:gcross.20110511141322.2213: ** &lt;&lt; License &gt;&gt;</span>
<a name="l00007"></a>00007 <span class="comment">//@+at</span>
<a name="l00008"></a>00008 <span class="comment">// Copyright (c) 2011, Gregory Crosswhite</span>
<a name="l00009"></a>00009 <span class="comment">// All rights reserved.</span>
<a name="l00010"></a>00010 <span class="comment">// </span>
<a name="l00011"></a>00011 <span class="comment">// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00012"></a>00012 <span class="comment">// </span>
<a name="l00013"></a>00013 <span class="comment">//     * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00014"></a>00014 <span class="comment">//     * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00015"></a>00015 <span class="comment">// </span>
<a name="l00016"></a>00016 <span class="comment">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00017"></a>00017 <span class="comment">//@@c</span>
<a name="l00018"></a>00018 <span class="comment">//@-&lt;&lt; License &gt;&gt;</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="comment">//@+&lt;&lt; Documentation &gt;&gt;</span>
<a name="l00021"></a>00021 <span class="comment">//@+node:gcross.20110511141322.2211: ** &lt;&lt; Documentation &gt;&gt;</span>
<a name="l00026"></a>00026 <span class="comment"></span><span class="comment">//@-&lt;&lt; Documentation &gt;&gt;</span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="comment">//@+&lt;&lt; Includes &gt;&gt;</span>
<a name="l00029"></a>00029 <span class="comment">//@+node:gcross.20110511141322.2214: ** &lt;&lt; Includes &gt;&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;boost/algorithm/string/trim.hpp&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;boost/assign/list_of.hpp&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;boost/bind.hpp&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;boost/filesystem.hpp&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;boost/function.hpp&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;boost/move/move.hpp&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;boost/range/adaptor/indirected.hpp&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;boost/signals/trackable.hpp&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;complex&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;hdf++/container.hpp&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;hdf++/dataspace.hpp&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;hdf++/file.hpp&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;iomanip&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;ostream&gt;</span>
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 <span class="preprocessor">#include &quot;chain.hpp&quot;</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include &quot;hdf.hpp&quot;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &quot;io.hpp&quot;</span>
<a name="l00048"></a>00048 <span class="comment">//@-&lt;&lt; Includes &gt;&gt;</span>
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="comment">//@+&lt;&lt; Usings &gt;&gt;</span>
<a name="l00051"></a>00051 <span class="comment">//@+node:gcross.20110511141322.2215: ** &lt;&lt; Usings &gt;&gt;</span>
<a name="l00052"></a>00052 <span class="keyword">using</span> boost::adaptors::indirected;
<a name="l00053"></a>00053 <span class="keyword">using</span> boost::algorithm::trim_if;
<a name="l00054"></a>00054 <span class="keyword">using</span> boost::assign::list_of;
<a name="l00055"></a>00055 <span class="keyword">using</span> boost::bind;
<a name="l00056"></a>00056 <span class="keyword">using</span> boost::filesystem::exists;
<a name="l00057"></a>00057 <span class="keyword">using</span> boost::filesystem::path;
<a name="l00058"></a>00058 <span class="keyword">using</span> boost::function;
<a name="l00059"></a>00059 <span class="keyword">using</span> boost::none;
<a name="l00060"></a>00060 <span class="keyword">using</span> boost::signals::trackable;
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 <span class="keyword">using</span> std::complex;
<a name="l00063"></a>00063 <span class="keyword">using</span> std::endl;
<a name="l00064"></a>00064 <span class="keyword">using</span> std::ostringstream;
<a name="l00065"></a>00065 <span class="keyword">using</span> std::setw;
<a name="l00066"></a>00066 
<a name="l00067"></a>00067 <span class="keyword">using</span> HDF::assertSuccess;
<a name="l00068"></a>00068 <span class="keyword">using</span> HDF::Container;
<a name="l00069"></a>00069 <span class="keyword">using</span> HDF::DatasetCreationProperties;
<a name="l00070"></a>00070 <span class="keyword">using</span> HDF::Dataspace;
<a name="l00071"></a>00071 <span class="keyword">using</span> HDF::datatypeOf;
<a name="l00072"></a>00072 <span class="keyword">using</span> HDF::FailIfFileExisting;
<a name="l00073"></a>00073 <span class="keyword">using</span> HDF::File;
<a name="l00074"></a>00074 <span class="keyword">using</span> HDF::LinkCreationProperties;
<a name="l00075"></a>00075 <span class="keyword">using</span> HDF::Location;
<a name="l00076"></a>00076 <span class="keyword">using</span> HDF::LocationIterator;
<a name="l00077"></a>00077 <span class="keyword">using</span> HDF::OpenReadOnly;
<a name="l00078"></a>00078 <span class="keyword">using</span> HDF::OpenReadWrite;
<a name="l00079"></a>00079 <span class="keyword">using</span> HDF::rangeOf;
<a name="l00080"></a>00080 <span class="comment">//@-&lt;&lt; Usings &gt;&gt;</span>
<a name="l00081"></a>00081 
<a name="l00082"></a>00082 <span class="keyword">namespace </span>Nutcracker { <span class="keyword">namespace </span>HDF {
<a name="l00083"></a>00083 
<a name="l00084"></a>00084 <span class="comment">//@+others</span>
<a name="l00085"></a>00085 <span class="comment">//@+node:gcross.20110511190907.3646: ** Formats</span>
<a name="l00086"></a>00086 <span class="comment">//@+others</span>
<a name="l00087"></a>00087 <span class="comment">//@+node:gcross.20110511190907.3650: *3* Input</span>
<a name="l00088"></a>00088 <span class="keyword">static</span> Operator readOperator(optional&lt;string&gt; <span class="keyword">const</span>&amp; maybe_filename, optional&lt;string&gt; <span class="keyword">const</span>&amp; maybe_location) {
<a name="l00089"></a>00089     assert(maybe_filename);
<a name="l00090"></a>00090     File file(maybe_filename-&gt;c_str(),OpenReadOnly);
<a name="l00091"></a>00091 
<a name="l00092"></a>00092     Location location = file.getLocation();
<a name="l00093"></a>00093 
<a name="l00094"></a>00094     <span class="keywordflow">if</span>(maybe_location) {
<a name="l00095"></a>00095         BOOST_FOREACH(<span class="keywordtype">string</span> <span class="keyword">const</span>&amp; name, <a class="code" href="structNutcracker_1_1LocationSlashTokenizer.html">LocationSlashTokenizer</a>(maybe_location.get())) {
<a name="l00096"></a>00096             location /= name;
<a name="l00097"></a>00097         }
<a name="l00098"></a>00098     }
<a name="l00099"></a>00099 
<a name="l00100"></a>00100     Operator hamiltonian;
<a name="l00101"></a>00101     location &gt;&gt; hamiltonian;
<a name="l00102"></a>00102     <span class="keywordflow">return</span> boost::move(hamiltonian);
<a name="l00103"></a>00103 }
<a name="l00104"></a>00104 <span class="comment">//@+node:gcross.20110511190907.3673: *3* Output</span>
<a name="l00105"></a><a class="code" href="structNutcracker_1_1HDF_1_1Outputter.html">00105</a> <span class="keyword">struct </span><a class="code" href="structNutcracker_1_1HDF_1_1Outputter.html">Outputter</a> : <span class="keyword">public</span> <a class="code" href="structNutcracker_1_1Destructable.html">Destructable</a>, <span class="keyword">public</span> trackable {
<a name="l00106"></a>00106     <a class="code" href="classNutcracker_1_1Chain.html">Chain</a> <span class="keyword">const</span>&amp; chain;
<a name="l00107"></a>00107     File file;
<a name="l00108"></a>00108 
<a name="l00109"></a>00109     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_of_levels;
<a name="l00110"></a>00110 
<a name="l00111"></a>00111     Location levels_location;
<a name="l00112"></a>00112     optional&lt;Location&gt; maybe_states_location;
<a name="l00113"></a>00113 
<a name="l00114"></a>00114     <a class="code" href="structNutcracker_1_1HDF_1_1Outputter.html">Outputter</a>(
<a name="l00115"></a>00115         optional&lt;string&gt; <span class="keyword">const</span>&amp; maybe_filename
<a name="l00116"></a>00116       , optional&lt;string&gt; <span class="keyword">const</span>&amp; maybe_location
<a name="l00117"></a>00117       , <span class="keywordtype">bool</span> output_states
<a name="l00118"></a>00118       , <span class="keywordtype">bool</span> overwrite
<a name="l00119"></a>00119       , <a class="code" href="classNutcracker_1_1Chain.html">Chain</a>&amp; chain
<a name="l00120"></a>00120     )
<a name="l00121"></a>00121       : chain(chain)
<a name="l00122"></a>00122       , number_of_levels(0)
<a name="l00123"></a>00123     {
<a name="l00124"></a>00124         assert(maybe_filename);
<a name="l00125"></a>00125         <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; filename = *maybe_filename;
<a name="l00126"></a>00126 
<a name="l00127"></a>00127         <span class="keywordflow">if</span>(exists(path(filename))) {
<a name="l00128"></a>00128             file = File(filename.c_str(),OpenReadWrite);
<a name="l00129"></a>00129         } <span class="keywordflow">else</span> {
<a name="l00130"></a>00130             file = File(filename.c_str(),FailIfFileExisting);
<a name="l00131"></a>00131         }
<a name="l00132"></a>00132 
<a name="l00133"></a>00133         Location location = file.getLocation();
<a name="l00134"></a>00134         <span class="keywordflow">if</span>(maybe_location) {
<a name="l00135"></a>00135             location /= *maybe_location;
<a name="l00136"></a>00136         }
<a name="l00137"></a>00137 
<a name="l00138"></a>00138         Container group(createAt(location),LinkCreationProperties().createMissingIntermediateGroups());
<a name="l00139"></a>00139 
<a name="l00140"></a>00140         Location
<a name="l00141"></a>00141             configuration_location = location / <span class="stringliteral">&quot;configuration&quot;</span>,
<a name="l00142"></a>00142             states_location = location / <span class="stringliteral">&quot;states&quot;</span>;
<a name="l00143"></a>00143 
<a name="l00144"></a>00144         levels_location = location / <span class="stringliteral">&quot;levels&quot;</span>;
<a name="l00145"></a>00145 
<a name="l00146"></a>00146         <span class="keywordflow">if</span>(!overwrite &amp;&amp; (
<a name="l00147"></a>00147                configuration_location.exists()
<a name="l00148"></a>00148             || levels_location.exists()
<a name="l00149"></a>00149             || states_location.exists()
<a name="l00150"></a>00150         )) <span class="keywordflow">throw</span> <a class="code" href="structNutcracker_1_1OutputLocationAlreadyExists.html">OutputLocationAlreadyExists</a>(filename,*maybe_location);
<a name="l00151"></a>00151 
<a name="l00152"></a>00152         {
<a name="l00153"></a>00153             <span class="keywordflow">if</span>(configuration_location.exists()) group.remove(<span class="stringliteral">&quot;configuration&quot;</span>);
<a name="l00154"></a>00154             Group configuration(createAt(configuration_location));
<a name="l00155"></a>00155             configuration[<span class="stringliteral">&quot;site convergence tolerance&quot;</span>] = chain.options.site_convergence_threshold;
<a name="l00156"></a>00156             configuration[<span class="stringliteral">&quot;sweep convergence tolerance&quot;</span>] = chain.options.sweep_convergence_threshold;
<a name="l00157"></a>00157             configuration[<span class="stringliteral">&quot;chain convergence tolerance&quot;</span>] = chain.options.chain_convergence_threshold;
<a name="l00158"></a>00158             configuration[<span class="stringliteral">&quot;sanity check tolerance&quot;</span>] = chain.options.sanity_check_threshold;
<a name="l00159"></a>00159         }
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 
<a name="l00162"></a>00162         {        
<a name="l00163"></a>00163             <span class="keywordflow">if</span>(levels_location.exists()) group.remove(<span class="stringliteral">&quot;levels&quot;</span>);
<a name="l00164"></a>00164 
<a name="l00165"></a>00165             Dataset(
<a name="l00166"></a>00166                 createAt(levels_location),
<a name="l00167"></a>00167                 datatypeOf&lt;double&gt;::get(),
<a name="l00168"></a>00168                 Dataspace(0,H5S_UNLIMITED),
<a name="l00169"></a>00169                 none,
<a name="l00170"></a>00170                 DatasetCreationProperties().setChunk(16)
<a name="l00171"></a>00171             );
<a name="l00172"></a>00172         }
<a name="l00173"></a>00173 
<a name="l00174"></a>00174         <span class="keywordflow">if</span>(output_states) {
<a name="l00175"></a>00175             <span class="keywordflow">if</span>(states_location.exists()) group.remove(<span class="stringliteral">&quot;states&quot;</span>);
<a name="l00176"></a>00176             Group(createAt(states_location))[<span class="stringliteral">&quot;size&quot;</span>] = 0u;
<a name="l00177"></a>00177             maybe_states_location = states_location;
<a name="l00178"></a>00178         } <span class="keywordflow">else</span> maybe_states_location = none;
<a name="l00179"></a>00179 
<a name="l00180"></a>00180         chain.signalChainOptimized.connect(boost::bind(&amp;Outputter::reactToChainOptimizedSignal,<span class="keyword">this</span>));
<a name="l00181"></a>00181     }
<a name="l00182"></a>00182 
<a name="l00183"></a>00183     <span class="keyword">virtual</span> ~<a class="code" href="structNutcracker_1_1HDF_1_1Outputter.html">Outputter</a>() {}
<a name="l00184"></a>00184 
<a name="l00185"></a>00185     <span class="keywordtype">void</span> reactToChainOptimizedSignal() {
<a name="l00186"></a>00186         hsize_t <span class="keyword">const</span> index = number_of_levels;
<a name="l00187"></a>00187         ++number_of_levels;
<a name="l00188"></a>00188 
<a name="l00189"></a>00189         {
<a name="l00190"></a>00190             <span class="keywordtype">double</span> <span class="keyword">const</span> energy = chain.getEnergy();
<a name="l00191"></a>00191 
<a name="l00192"></a>00192             Dataset levels(levels_location);
<a name="l00193"></a>00193             levels.resize(number_of_levels);
<a name="l00194"></a>00194 
<a name="l00195"></a>00195             Dataspace levels_space(levels);
<a name="l00196"></a>00196             assertSuccess(
<a name="l00197"></a>00197                 <span class="stringliteral">&quot;selecting last (new) entry in the levels list&quot;</span>,
<a name="l00198"></a>00198                 H5Sselect_elements(
<a name="l00199"></a>00199                     levels_space.getId(),
<a name="l00200"></a>00200                     H5S_SELECT_SET,
<a name="l00201"></a>00201                     1,
<a name="l00202"></a>00202                     &amp;index
<a name="l00203"></a>00203                 )
<a name="l00204"></a>00204             );
<a name="l00205"></a>00205 
<a name="l00206"></a>00206             hsize_t <span class="keyword">const</span> one = 1;
<a name="l00207"></a>00207             Dataspace memory_space(1,&amp;one);
<a name="l00208"></a>00208 
<a name="l00209"></a>00209             levels.write(
<a name="l00210"></a>00210                 &amp;energy,
<a name="l00211"></a>00211                 Dataspace(1),
<a name="l00212"></a>00212                 levels_space
<a name="l00213"></a>00213             );
<a name="l00214"></a>00214         }
<a name="l00215"></a>00215 
<a name="l00216"></a>00216         <span class="keywordflow">if</span>(maybe_states_location) {
<a name="l00217"></a>00217             Location <span class="keyword">const</span>&amp; states_location = *maybe_states_location;
<a name="l00218"></a>00218             GroupArray states(states_location);
<a name="l00219"></a>00219             {
<a name="l00220"></a>00220                 GroupArray state(createAt(states.begin()[index]));
<a name="l00221"></a>00221                 LocationIterator state_sites = state.begin();
<a name="l00222"></a>00222                 chain.writeStateTo(state_sites);
<a name="l00223"></a>00223                 state[<span class="stringliteral">&quot;size&quot;</span>] = chain.number_of_sites;
<a name="l00224"></a>00224             }
<a name="l00225"></a>00225             states[<span class="stringliteral">&quot;size&quot;</span>] = number_of_levels;
<a name="l00226"></a>00226         }
<a name="l00227"></a>00227 
<a name="l00228"></a>00228         file.flush();
<a name="l00229"></a>00229     }
<a name="l00230"></a>00230 };
<a name="l00231"></a>00231 
<a name="l00232"></a>00232 auto_ptr&lt;Destructable const&gt; connectToChain(
<a name="l00233"></a>00233     optional&lt;string&gt; <span class="keyword">const</span>&amp; maybe_filename
<a name="l00234"></a>00234   , optional&lt;string&gt; <span class="keyword">const</span>&amp; maybe_location
<a name="l00235"></a>00235   , <span class="keywordtype">bool</span> output_states
<a name="l00236"></a>00236   , <span class="keywordtype">bool</span> overwrite
<a name="l00237"></a>00237   , <a class="code" href="classNutcracker_1_1Chain.html">Chain</a>&amp; chain
<a name="l00238"></a>00238 ) {
<a name="l00239"></a>00239     <span class="keywordflow">return</span> auto_ptr&lt;Destructable const&gt;(<span class="keyword">new</span> <a class="code" href="structNutcracker_1_1HDF_1_1Outputter.html">Outputter</a>(maybe_filename,maybe_location,output_states,overwrite,chain));
<a name="l00240"></a>00240 }
<a name="l00241"></a>00241 <span class="comment">//@-others</span>
<a name="l00242"></a>00242 
<a name="l00243"></a>00243 <span class="keywordtype">void</span> installFormat() {
<a name="l00244"></a>00244     <span class="keyword">static</span> <a class="code" href="structNutcracker_1_1InputFormat.html">InputFormat</a> input_format(<span class="stringliteral">&quot;hdf&quot;</span>,<span class="stringliteral">&quot;HDF format&quot;</span>,<span class="keyword">false</span>,<span class="keyword">true</span>,list_of(<span class="stringliteral">&quot;hdf&quot;</span>)(<span class="stringliteral">&quot;hdf5&quot;</span>)(<span class="stringliteral">&quot;h5&quot;</span>),readOperator);
<a name="l00245"></a>00245     <span class="keyword">static</span> <a class="code" href="structNutcracker_1_1OutputFormat.html">OutputFormat</a> output_format(<span class="stringliteral">&quot;hdf&quot;</span>,<span class="stringliteral">&quot;HDF format&quot;</span>,<span class="keyword">false</span>,<span class="keyword">true</span>,list_of(<span class="stringliteral">&quot;hdf&quot;</span>)(<span class="stringliteral">&quot;hdf5&quot;</span>)(<span class="stringliteral">&quot;h5&quot;</span>),<span class="keyword">true</span>,connectToChain);
<a name="l00246"></a>00246 }
<a name="l00247"></a>00247 <span class="comment">//@-others</span>
<a name="l00248"></a>00248 
<a name="l00249"></a>00249 } }
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 <span class="comment">//@+&lt;&lt; Outside namespace &gt;&gt;</span>
<a name="l00252"></a>00252 <span class="comment">//@+node:gcross.20110524225044.2432: ** &lt;&lt; Outside namespace &gt;&gt;</span>
<a name="l00253"></a>00253 <span class="keyword">using namespace </span>HDF;
<a name="l00254"></a>00254 <span class="keyword">using namespace </span>Nutcracker;
<a name="l00255"></a>00255 
<a name="l00256"></a>00256 <span class="comment">//@+others</span>
<a name="l00257"></a>00257 <span class="comment">//@+node:gcross.20110511190907.2301: *3* I/O Operators</span>
<a name="l00258"></a>00258 <span class="comment">//@+node:gcross.20110511190907.3531: *4* Operator</span>
<a name="l00259"></a>00259 <span class="comment">//@+node:gcross.20110511190907.3532: *5* &gt;&gt;</span>
<a name="l00260"></a>00260 <span class="keywordtype">void</span> operator &gt;&gt; (Location <span class="keyword">const</span>&amp; location, Operator&amp; operator_sites) {
<a name="l00261"></a>00261     operator_sites = constructOperatorFrom(
<a name="l00262"></a>00262         readUniqueOperatorSites(GroupArray(location / <span class="stringliteral">&quot;sites&quot;</span>)),
<a name="l00263"></a>00263         Dataset(location / <span class="stringliteral">&quot;sequence&quot;</span>).readVector&lt;unsigned int&gt;()
<a name="l00264"></a>00264     );
<a name="l00265"></a>00265 }
<a name="l00266"></a>00266 <span class="comment">//@+node:gcross.20110511190907.3533: *5* &lt;&lt;</span>
<a name="l00267"></a>00267 Container operator &lt;&lt; (Location <span class="keyword">const</span>&amp; location, Operator <span class="keyword">const</span>&amp; operator_sites) {
<a name="l00268"></a>00268     Container group(createAt(location));
<a name="l00269"></a>00269 
<a name="l00270"></a>00270     vector&lt;shared_ptr&lt;OperatorSite const&gt; &gt; unique_operator_sites;
<a name="l00271"></a>00271     vector&lt;unsigned int&gt; sequence;
<a name="l00272"></a>00272 
<a name="l00273"></a>00273     deconstructOperatorTo(operator_sites,unique_operator_sites,sequence);
<a name="l00274"></a>00274 
<a name="l00275"></a>00275     GroupArray(createAt(location / <span class="stringliteral">&quot;sites&quot;</span>)) &lt;&lt; rangeOf(unique_operator_sites | indirected);
<a name="l00276"></a>00276 
<a name="l00277"></a>00277     Dataset(
<a name="l00278"></a>00278         createAt(location / <span class="stringliteral">&quot;sequence&quot;</span>),
<a name="l00279"></a>00279         sequence.size(),
<a name="l00280"></a>00280         &amp;sequence.front()
<a name="l00281"></a>00281     );
<a name="l00282"></a>00282 
<a name="l00283"></a>00283     <span class="keywordflow">return</span> group;
<a name="l00284"></a>00284 }
<a name="l00285"></a>00285 <span class="comment">//@+node:gcross.20110511190907.2302: *4* OperatorSite</span>
<a name="l00286"></a>00286 <span class="comment">//@+node:gcross.20110511190907.2304: *5* &lt;&lt;</span>
<a name="l00287"></a>00287 Group operator&lt;&lt;(Location <span class="keyword">const</span>&amp; location, <a class="code" href="classNutcracker_1_1OperatorSite.html">OperatorSite</a> <span class="keyword">const</span>&amp; operator_site_tensor) {
<a name="l00288"></a>00288     Group object(createAt(location));
<a name="l00289"></a>00289     <span class="keywordtype">object</span>[<span class="stringliteral">&quot;left dimension&quot;</span>] = operator_site_tensor.leftDimension(<a class="code" href="group__DummyArguments.html#ga459369c1daac7db1a7a794f684e97f03" title="The singleton instance of AsUnsignedInteger.">as_unsigned_integer</a>);
<a name="l00290"></a>00290     <span class="keywordtype">object</span>[<span class="stringliteral">&quot;right dimension&quot;</span>] = operator_site_tensor.rightDimension(<a class="code" href="group__DummyArguments.html#ga459369c1daac7db1a7a794f684e97f03" title="The singleton instance of AsUnsignedInteger.">as_unsigned_integer</a>);
<a name="l00291"></a>00291     Dataset(
<a name="l00292"></a>00292         createAt(location / <span class="stringliteral">&quot;matrices&quot;</span>),
<a name="l00293"></a>00293         rangeOf(operator_site_tensor.<a class="code" href="classNutcracker_1_1OperatorSite.html#a6a32c3897496b858b6c111a5758fcf08" title="Returns a vector with the dimensions of the matrix data stored in this tensor in row-major order...">matrixDataDimensions</a>()),
<a name="l00294"></a>00294         (complex&lt;double&gt; <span class="keyword">const</span>*)operator_site_tensor
<a name="l00295"></a>00295     );
<a name="l00296"></a>00296     Dataset(
<a name="l00297"></a>00297         createAt(location / &quot;indices&quot;),
<a name="l00298"></a>00298         rangeOf(operator_site_tensor.indexDataDimensions()),
<a name="l00299"></a>00299         (uint32_t const*)operator_site_tensor
<a name="l00300"></a>00300     );
<a name="l00301"></a>00301     return <span class="keywordtype">object</span>;
<a name="l00302"></a>00302 }
<a name="l00303"></a>00303 <span class="comment">//@+node:gcross.20110511190907.2311: *5* &gt;&gt;</span>
<a name="l00304"></a>00304 Group operator&gt;&gt;(Location const&amp; location, <a class="code" href="classNutcracker_1_1OperatorSite.html">OperatorSite</a>&amp; operator_site_tensor) {
<a name="l00305"></a>00305     Group object(location);
<a name="l00306"></a>00306     Dataset <span class="keyword">const</span>
<a name="l00307"></a>00307         matrices_dataset(location / <span class="stringliteral">&quot;matrices&quot;</span>),
<a name="l00308"></a>00308         indices_dataset(location / <span class="stringliteral">&quot;indices&quot;</span>);
<a name="l00309"></a>00309 
<a name="l00310"></a>00310     std::vector&lt;hsize_t&gt; matrices_dimensions = matrices_dataset.dimensionsWithAssertedRank(3);
<a name="l00311"></a>00311     std::vector&lt;hsize_t&gt; indices_dimensions = indices_dataset.dimensionsWithAssertedRank(2);
<a name="l00312"></a>00312 
<a name="l00313"></a>00313     <span class="keywordflow">if</span>(matrices_dimensions[0] != indices_dimensions[0]
<a name="l00314"></a>00314     || matrices_dimensions[1] != matrices_dimensions[2]
<a name="l00315"></a>00315     || indices_dimensions[1] != 2
<a name="l00316"></a>00316     ) <span class="keywordflow">throw</span> <a class="code" href="structNutcracker_1_1HDF_1_1InconsistentTensorDimensions.html">Nutcracker::HDF::InconsistentTensorDimensions</a>();
<a name="l00317"></a>00317 
<a name="l00318"></a>00318     {
<a name="l00319"></a>00319         <a class="code" href="classNutcracker_1_1OperatorSite.html">OperatorSite</a> new_operator_site_tensor(
<a name="l00320"></a>00320             matrices_dimensions[0],
<a name="l00321"></a>00321             <a class="code" href="classNutcracker_1_1Dimension.html">PhysicalDimension</a>(matrices_dimensions[1]),
<a name="l00322"></a>00322             <a class="code" href="classNutcracker_1_1Dimension.html">LeftDimension</a>(<span class="keywordtype">object</span>[<span class="stringliteral">&quot;left dimension&quot;</span>]),
<a name="l00323"></a>00323             <a class="code" href="classNutcracker_1_1Dimension.html">RightDimension</a>(<span class="keywordtype">object</span>[<span class="stringliteral">&quot;right dimension&quot;</span>])
<a name="l00324"></a>00324         );
<a name="l00325"></a>00325         operator_site_tensor = boost::move(new_operator_site_tensor);
<a name="l00326"></a>00326     }
<a name="l00327"></a>00327 
<a name="l00328"></a>00328     matrices_dataset.read&lt;complex&lt;double&gt; &gt;(operator_site_tensor);
<a name="l00329"></a>00329     indices_dataset.read&lt;uint32_t&gt;(operator_site_tensor);
<a name="l00330"></a>00330 
<a name="l00331"></a>00331     <span class="keywordflow">return</span> object;
<a name="l00332"></a>00332 }
<a name="l00333"></a>00333 <span class="comment">//@+node:gcross.20110511190907.3512: *4* State</span>
<a name="l00334"></a>00334 <span class="comment">//@+node:gcross.20110511190907.3513: *5* &lt;&lt;</span>
<a name="l00335"></a>00335 GroupArray operator&lt;&lt;(Location <span class="keyword">const</span>&amp; location, <a class="code" href="structNutcracker_1_1State.html" title="Matrix product state in canonical form.">State</a> <span class="keyword">const</span>&amp; state) {
<a name="l00336"></a>00336     GroupArray group(createAt(location));
<a name="l00337"></a>00337     group[<span class="stringliteral">&quot;size&quot;</span>] = state.<a class="code" href="structNutcracker_1_1State.html#a19a838dd46cce8df6dfd1e0515b8d18b" title="Returns the number of sites in this matrix product state;.">numberOfSites</a>();
<a name="l00338"></a>00338     LocationIterator iter(group);
<a name="l00339"></a>00339     iter &lt;&lt; state.<a class="code" href="structNutcracker_1_1State.html#a87cf4008a50464000020c5a547598bee" title="Returns the left-most site.">getFirstSite</a>() &lt;&lt; rangeOf(state.<a class="code" href="structNutcracker_1_1State.html#af0d51fb41943a889b81762da20cb7e4a" title="Returns the vector of sites after the left-most site.">getRestSites</a>());
<a name="l00340"></a>00340     <span class="keywordflow">return</span> group;
<a name="l00341"></a>00341 }
<a name="l00342"></a>00342 <span class="comment">//@+node:gcross.20110511190907.3516: *5* &gt;&gt;</span>
<a name="l00343"></a>00343 GroupArray operator&gt;&gt;(Location <span class="keyword">const</span>&amp; location, <a class="code" href="structNutcracker_1_1State.html" title="Matrix product state in canonical form.">State</a>&amp; state) {
<a name="l00344"></a>00344     GroupArray group(location);
<a name="l00345"></a>00345     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> size = group[<span class="stringliteral">&quot;size&quot;</span>];
<a name="l00346"></a>00346     LocationIterator iter(group);
<a name="l00347"></a>00347 
<a name="l00348"></a>00348     <a class="code" href="classNutcracker_1_1StateSite.html">StateSite&lt;Middle&gt;</a> first_site;
<a name="l00349"></a>00349     iter &gt;&gt; first_site;
<a name="l00350"></a>00350 
<a name="l00351"></a>00351     vector&lt;StateSite&lt;Right&gt; &gt; rest_sites(size-1);
<a name="l00352"></a>00352     for_each(rest_sites,lambda::var(iter) &gt;&gt; lambda::_1);
<a name="l00353"></a>00353 
<a name="l00354"></a>00354     state = <a class="code" href="structNutcracker_1_1State.html" title="Matrix product state in canonical form.">State</a>(boost::move(first_site),boost::move(rest_sites));
<a name="l00355"></a>00355 
<a name="l00356"></a>00356     <span class="keywordflow">return</span> group;
<a name="l00357"></a>00357 }
<a name="l00358"></a>00358 <span class="comment">//@-others</span>
<a name="l00359"></a>00359 <span class="comment">//@-&lt;&lt; Outside namespace &gt;&gt;</span>
<a name="l00360"></a>00360 <span class="comment">//@-leo</span>
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Tue May 31 2011 17:02:18 for Nutcracker by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
