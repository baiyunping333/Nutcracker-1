<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nutcracker: sgtree.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>sgtree.hpp</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00002"></a>00002 <span class="comment">//</span>
<a name="l00003"></a>00003 <span class="comment">// (C) Copyright Ion Gaztanaga 2007-2009</span>
<a name="l00004"></a>00004 <span class="comment">//</span>
<a name="l00005"></a>00005 <span class="comment">// Distributed under the Boost Software License, Version 1.0.</span>
<a name="l00006"></a>00006 <span class="comment">//    (See accompanying file LICENSE_1_0.txt or copy at</span>
<a name="l00007"></a>00007 <span class="comment">//          http://www.boost.org/LICENSE_1_0.txt)</span>
<a name="l00008"></a>00008 <span class="comment">//</span>
<a name="l00009"></a>00009 <span class="comment">// See http://www.boost.org/libs/intrusive for documentation.</span>
<a name="l00010"></a>00010 <span class="comment">//</span>
<a name="l00012"></a>00012 <span class="comment"></span><span class="comment">//</span>
<a name="l00013"></a>00013 <span class="comment">// The option that yields to non-floating point 1/sqrt(2) alpha is taken</span>
<a name="l00014"></a>00014 <span class="comment">// from the scapegoat tree implementation of the PSPP library.</span>
<a name="l00015"></a>00015 <span class="comment">//</span>
<a name="l00017"></a>00017 <span class="comment"></span>
<a name="l00018"></a>00018 <span class="preprocessor">#ifndef BOOST_INTRUSIVE_SGTREE_HPP</span>
<a name="l00019"></a>00019 <span class="preprocessor"></span><span class="preprocessor">#define BOOST_INTRUSIVE_SGTREE_HPP</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;boost/intrusive/detail/config_begin.hpp&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;cstddef&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;functional&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;iterator&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;utility&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;cmath&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;cstddef&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;boost/intrusive/detail/assert.hpp&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;boost/static_assert.hpp&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;boost/intrusive/intrusive_fwd.hpp&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;boost/intrusive/bs_set_hook.hpp&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;boost/intrusive/detail/tree_node.hpp&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;boost/intrusive/detail/ebo_functor_holder.hpp&gt;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &lt;boost/intrusive/detail/pointer_to_other.hpp&gt;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;boost/intrusive/detail/clear_on_destructor_base.hpp&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;boost/intrusive/detail/mpl.hpp&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;boost/intrusive/options.hpp&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;boost/intrusive/sgtree_algorithms.hpp&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;boost/intrusive/link_mode.hpp&gt;</span>
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="keyword">namespace </span>boost {
<a name="l00043"></a>00043 <span class="keyword">namespace </span>intrusive {
<a name="l00044"></a>00044 
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="keyword">namespace </span>detail{
<a name="l00048"></a>00048 
<a name="l00053"></a>00053 <span class="keyword">inline</span> std::size_t calculate_h_sqrt2 (std::size_t n)
<a name="l00054"></a>00054 {
<a name="l00055"></a>00055    std::size_t f_log2 = detail::floor_log2(n);
<a name="l00056"></a>00056    <span class="keywordflow">return</span> (2*f_log2) + (n &gt;= detail::sqrt2_pow_2xplus1 (f_log2));
<a name="l00057"></a>00057 }
<a name="l00058"></a>00058 
<a name="l00059"></a>00059 <span class="keyword">struct </span>h_alpha_sqrt2_t
<a name="l00060"></a>00060 {
<a name="l00061"></a>00061    h_alpha_sqrt2_t(<span class="keywordtype">void</span>){}
<a name="l00062"></a>00062    std::size_t operator()(std::size_t n)<span class="keyword"> const</span>
<a name="l00063"></a>00063 <span class="keyword">   </span>{  <span class="keywordflow">return</span> calculate_h_sqrt2(n);  }
<a name="l00064"></a>00064 };
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 <span class="keyword">struct </span>alpha_0_75_by_max_size_t
<a name="l00067"></a>00067 {
<a name="l00068"></a>00068    alpha_0_75_by_max_size_t(<span class="keywordtype">void</span>){}
<a name="l00069"></a>00069    std::size_t operator()(std::size_t max_tree_size)<span class="keyword"> const</span>
<a name="l00070"></a>00070 <span class="keyword">   </span>{
<a name="l00071"></a>00071       <span class="keyword">const</span> std::size_t max_tree_size_limit = ((~std::size_t(0))/std::size_t(3));
<a name="l00072"></a>00072       <span class="keywordflow">return</span> max_tree_size &gt; max_tree_size_limit ? max_tree_size/4*3 : max_tree_size*3/4;
<a name="l00073"></a>00073    }
<a name="l00074"></a>00074 };
<a name="l00075"></a>00075 
<a name="l00076"></a>00076 <span class="keyword">struct </span>h_alpha_t
<a name="l00077"></a>00077 {
<a name="l00078"></a>00078    h_alpha_t(<span class="keywordtype">float</span> inv_minus_logalpha)
<a name="l00079"></a>00079       :  inv_minus_logalpha_(inv_minus_logalpha)
<a name="l00080"></a>00080    {}
<a name="l00081"></a>00081 
<a name="l00082"></a>00082    std::size_t operator()(std::size_t n)<span class="keyword"> const</span>
<a name="l00083"></a>00083 <span class="keyword">   </span>{
<a name="l00084"></a>00084       <span class="comment">//Returns floor(log1/alpha(n)) -&gt;</span>
<a name="l00085"></a>00085       <span class="comment">// floor(log(n)/log(1/alpha)) -&gt;</span>
<a name="l00086"></a>00086       <span class="comment">// floor(log(n)/(-log(alpha)))</span>
<a name="l00087"></a>00087       <span class="comment">//return static_cast&lt;std::size_t&gt;(std::log(float(n))*inv_minus_logalpha_);</span>
<a name="l00088"></a>00088       <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span>(detail::fast_log2(<span class="keywordtype">float</span>(n))*inv_minus_logalpha_);
<a name="l00089"></a>00089    }
<a name="l00090"></a>00090 
<a name="l00091"></a>00091    <span class="keyword">private</span>:
<a name="l00092"></a>00092    <span class="comment">//Since the function will be repeatedly called</span>
<a name="l00093"></a>00093    <span class="comment">//precalculate constant data to avoid repeated</span>
<a name="l00094"></a>00094    <span class="comment">//calls to log and division.</span>
<a name="l00095"></a>00095    <span class="comment">//This will store 1/(-std::log(alpha_))</span>
<a name="l00096"></a>00096    <span class="keywordtype">float</span> inv_minus_logalpha_;
<a name="l00097"></a>00097 };
<a name="l00098"></a>00098 
<a name="l00099"></a>00099 <span class="keyword">struct </span>alpha_by_max_size_t
<a name="l00100"></a>00100 {
<a name="l00101"></a>00101    alpha_by_max_size_t(<span class="keywordtype">float</span> alpha)
<a name="l00102"></a>00102       :  alpha_(alpha)
<a name="l00103"></a>00103    {}
<a name="l00104"></a>00104    
<a name="l00105"></a>00105    <span class="keywordtype">float</span> operator()(std::size_t max_tree_size)<span class="keyword"> const</span>
<a name="l00106"></a>00106 <span class="keyword">   </span>{  <span class="keywordflow">return</span> float(max_tree_size)*alpha_;   }
<a name="l00107"></a>00107 
<a name="l00108"></a>00108    <span class="keyword">private</span>:
<a name="l00109"></a>00109    <span class="keywordtype">float</span> alpha_;
<a name="l00110"></a>00110    <span class="keywordtype">float</span> inv_minus_logalpha_;
<a name="l00111"></a>00111 };
<a name="l00112"></a>00112 
<a name="l00113"></a>00113 <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> Activate&gt;
<a name="l00114"></a>00114 <span class="keyword">struct </span>alpha_holder
<a name="l00115"></a>00115 {
<a name="l00116"></a>00116    <span class="keyword">typedef</span> boost::intrusive::detail::h_alpha_t           h_alpha_t;
<a name="l00117"></a>00117    <span class="keyword">typedef</span> boost::intrusive::detail::alpha_by_max_size_t multiply_by_alpha_t;
<a name="l00118"></a>00118 
<a name="l00119"></a>00119    alpha_holder()
<a name="l00120"></a>00120    {  set_alpha(0.7f);   }
<a name="l00121"></a>00121 
<a name="l00122"></a>00122    <span class="keywordtype">float</span> get_alpha()<span class="keyword"> const</span>
<a name="l00123"></a>00123 <span class="keyword">   </span>{  <span class="keywordflow">return</span> alpha_;  }
<a name="l00124"></a>00124 
<a name="l00125"></a>00125    <span class="keywordtype">void</span> set_alpha(<span class="keywordtype">float</span> alpha)
<a name="l00126"></a>00126    { 
<a name="l00127"></a>00127       alpha_ = alpha;
<a name="l00128"></a>00128       inv_minus_logalpha_ = 1/(-detail::fast_log2(alpha));
<a name="l00129"></a>00129    }
<a name="l00130"></a>00130 
<a name="l00131"></a>00131    h_alpha_t get_h_alpha_t()<span class="keyword"> const</span>
<a name="l00132"></a>00132 <span class="keyword">   </span>{  <span class="keywordflow">return</span> h_alpha_t(inv_minus_logalpha_);  }
<a name="l00133"></a>00133 
<a name="l00134"></a>00134    multiply_by_alpha_t get_multiply_by_alpha_t()<span class="keyword"> const</span>
<a name="l00135"></a>00135 <span class="keyword">   </span>{  <span class="keywordflow">return</span> multiply_by_alpha_t(alpha_);  }
<a name="l00136"></a>00136 
<a name="l00137"></a>00137    <span class="keyword">private</span>:
<a name="l00138"></a>00138    <span class="keywordtype">float</span> alpha_;
<a name="l00139"></a>00139    <span class="keywordtype">float</span> inv_minus_logalpha_;
<a name="l00140"></a>00140 };
<a name="l00141"></a>00141 
<a name="l00142"></a>00142 <span class="keyword">template</span>&lt;&gt;
<a name="l00143"></a>00143 <span class="keyword">struct </span>alpha_holder&lt;false&gt;
<a name="l00144"></a>00144 {
<a name="l00145"></a>00145    <span class="comment">//This specialization uses alpha = 1/sqrt(2)</span>
<a name="l00146"></a>00146    <span class="comment">//without using floating point operations</span>
<a name="l00147"></a>00147    <span class="comment">//Downside: alpha CAN&#39;t be changed.</span>
<a name="l00148"></a>00148    <span class="keyword">typedef</span> boost::intrusive::detail::h_alpha_sqrt2_t           h_alpha_t;
<a name="l00149"></a>00149    <span class="keyword">typedef</span> boost::intrusive::detail::alpha_0_75_by_max_size_t  multiply_by_alpha_t;
<a name="l00150"></a>00150 
<a name="l00151"></a>00151    <span class="keywordtype">float</span> get_alpha()<span class="keyword"> const</span>
<a name="l00152"></a>00152 <span class="keyword">   </span>{  <span class="keywordflow">return</span> 0.70710677f;  }
<a name="l00153"></a>00153 
<a name="l00154"></a>00154    <span class="keywordtype">void</span> set_alpha(<span class="keywordtype">float</span>)
<a name="l00155"></a>00155    {  <span class="comment">//alpha CAN&#39;t be changed.</span>
<a name="l00156"></a>00156       BOOST_INTRUSIVE_INVARIANT_ASSERT(0);
<a name="l00157"></a>00157    }
<a name="l00158"></a>00158 
<a name="l00159"></a>00159    h_alpha_t get_h_alpha_t()<span class="keyword"> const</span>
<a name="l00160"></a>00160 <span class="keyword">   </span>{  <span class="keywordflow">return</span> h_alpha_t();  }
<a name="l00161"></a>00161 
<a name="l00162"></a>00162    multiply_by_alpha_t get_multiply_by_alpha_t()<span class="keyword"> const</span>
<a name="l00163"></a>00163 <span class="keyword">   </span>{  <span class="keywordflow">return</span> multiply_by_alpha_t();  }
<a name="l00164"></a>00164 };
<a name="l00165"></a>00165 
<a name="l00166"></a>00166 }  <span class="comment">//namespace detail{</span>
<a name="l00167"></a>00167 
<a name="l00168"></a>00168 <span class="keyword">template</span> &lt;<span class="keyword">class</span> ValueTraits, <span class="keyword">class</span> Compare, <span class="keyword">class</span> SizeType, <span class="keywordtype">bool</span> FloatingPo<span class="keywordtype">int</span>&gt;
<a name="l00169"></a>00169 <span class="keyword">struct </span>sg_setopt
<a name="l00170"></a>00170 {
<a name="l00171"></a>00171    <span class="keyword">typedef</span> ValueTraits  value_traits;
<a name="l00172"></a>00172    <span class="keyword">typedef</span> Compare      compare;
<a name="l00173"></a>00173    <span class="keyword">typedef</span> SizeType     size_type;
<a name="l00174"></a>00174    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> floating_point = FloatingPoint;
<a name="l00175"></a>00175 };
<a name="l00176"></a>00176 
<a name="l00177"></a>00177 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00178"></a>00178 <span class="keyword">struct </span>sg_set_defaults
<a name="l00179"></a>00179    :  pack_options
<a name="l00180"></a>00180       &lt; none
<a name="l00181"></a>00181       , base_hook&lt;detail::default_bs_set_hook&gt;
<a name="l00182"></a>00182       , floating_point&lt;true&gt;
<a name="l00183"></a>00183       , size_type&lt;std::size_t&gt;
<a name="l00184"></a>00184       , compare&lt;std::less&lt;T&gt; &gt;
<a name="l00185"></a>00185       &gt;::type
<a name="l00186"></a>00186 {};
<a name="l00187"></a>00187 
<a name="l00189"></a>00189 
<a name="l00203"></a>00203 <span class="preprocessor">#if defined(BOOST_INTRUSIVE_DOXYGEN_INVOKED)</span>
<a name="l00204"></a>00204 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class </span>T, <span class="keyword">class </span>...Options&gt;
<a name="l00205"></a>00205 <span class="preprocessor">#else</span>
<a name="l00206"></a>00206 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class</span> Config&gt;
<a name="l00207"></a>00207 <span class="preprocessor">#endif</span>
<a name="l00208"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html">00208</a> <span class="preprocessor"></span><span class="keyword">class </span><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html">sgtree_impl</a>
<a name="l00209"></a>00209    :  <span class="keyword">private</span> detail::clear_on_destructor_base&lt;sgtree_impl&lt;Config&gt; &gt;
<a name="l00210"></a>00210 {
<a name="l00211"></a>00211    <span class="keyword">template</span>&lt;<span class="keyword">class</span> C&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classboost_1_1intrusive_1_1detail_1_1clear__on__destructor__base.html">detail::clear_on_destructor_base</a>;
<a name="l00212"></a>00212    <span class="keyword">public</span>:
<a name="l00213"></a>00213    <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::value_traits                             value_traits;
<a name="l00215"></a>00215    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> external_value_traits =
<a name="l00216"></a>00216       <a class="code" href="structboost_1_1intrusive_1_1detail_1_1external__value__traits__is__true.html">detail::external_value_traits_is_true&lt;value_traits&gt;::value</a>;
<a name="l00217"></a>00217    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structboost_1_1intrusive_1_1detail_1_1eval__if__c.html">detail::eval_if_c</a>
<a name="l00218"></a>00218       &lt; external_value_traits
<a name="l00219"></a>00219       , detail::eval_value_traits&lt;value_traits&gt;
<a name="l00220"></a>00220       , <a class="code" href="structboost_1_1intrusive_1_1detail_1_1identity.html">detail::identity&lt;value_traits&gt;</a>
<a name="l00221"></a>00221       &gt;::type                                                        real_value_traits;
<a name="l00223"></a>00223    <span class="keyword">typedef</span> <span class="keyword">typename</span> real_value_traits::pointer                       pointer;
<a name="l00224"></a>00224    <span class="keyword">typedef</span> <span class="keyword">typename</span> real_value_traits::const_pointer                 const_pointer;
<a name="l00225"></a>00225    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;pointer&gt;::value_type        value_type;
<a name="l00226"></a>00226    <span class="keyword">typedef</span> value_type                                                key_type;
<a name="l00227"></a>00227    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;pointer&gt;::reference         reference;
<a name="l00228"></a>00228    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;const_pointer&gt;::reference   const_reference;
<a name="l00229"></a>00229    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;pointer&gt;::difference_type   difference_type;
<a name="l00230"></a>00230    <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::size_type                                size_type;
<a name="l00231"></a>00231    <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::compare                                  value_compare;
<a name="l00232"></a>00232    <span class="keyword">typedef</span> value_compare                                             key_compare;
<a name="l00233"></a>00233    <span class="keyword">typedef</span> <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">tree_iterator&lt;sgtree_impl, false&gt;</a>                         <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>;
<a name="l00234"></a>00234    <span class="keyword">typedef</span> <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">tree_iterator&lt;sgtree_impl, true&gt;</a>                          <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>;
<a name="l00235"></a>00235    <span class="keyword">typedef</span> std::reverse_iterator&lt;iterator&gt;                           reverse_iterator;
<a name="l00236"></a>00236    <span class="keyword">typedef</span> std::reverse_iterator&lt;const_iterator&gt;                     const_reverse_iterator;
<a name="l00237"></a>00237    <span class="keyword">typedef</span> <span class="keyword">typename</span> real_value_traits::node_traits                   node_traits;
<a name="l00238"></a>00238    <span class="keyword">typedef</span> <span class="keyword">typename</span> node_traits::node                                node;
<a name="l00239"></a>00239    <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::pointer_to_other
<a name="l00240"></a>00240       &lt;pointer, node&gt;::type                                          node_ptr;
<a name="l00241"></a>00241    <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::pointer_to_other
<a name="l00242"></a>00242       &lt;node_ptr, <span class="keyword">const</span> node&gt;::type                                   const_node_ptr;
<a name="l00243"></a>00243    <span class="keyword">typedef</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html">sgtree_algorithms&lt;node_traits&gt;</a>                            <a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html">node_algorithms</a>;
<a name="l00244"></a>00244 
<a name="l00245"></a>00245    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="structboost_1_1intrusive_1_1floating__point.html">floating_point</a>    = Config::floating_point;
<a name="l00246"></a>00246    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="structboost_1_1intrusive_1_1constant__time__size.html">constant_time_size</a>    = <span class="keyword">true</span>;
<a name="l00247"></a>00247    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> stateful_value_traits = <a class="code" href="structboost_1_1intrusive_1_1detail_1_1is__stateful__value__traits.html">detail::is_stateful_value_traits&lt;real_value_traits&gt;::value</a>;
<a name="l00248"></a>00248 
<a name="l00250"></a>00250    <span class="keyword">private</span>:
<a name="l00251"></a>00251    <span class="keyword">typedef</span> <a class="code" href="structboost_1_1intrusive_1_1detail_1_1size__holder.html">detail::size_holder&lt;true, size_type&gt;</a>          size_traits;
<a name="l00252"></a>00252    <span class="keyword">typedef</span> detail::alpha_holder&lt;floating_point&gt;      alpha_traits;
<a name="l00253"></a>00253    <span class="keyword">typedef</span> <span class="keyword">typename</span> alpha_traits::h_alpha_t              h_alpha_t;
<a name="l00254"></a>00254    <span class="keyword">typedef</span> <span class="keyword">typename</span> alpha_traits::multiply_by_alpha_t    multiply_by_alpha_t;
<a name="l00255"></a>00255 
<a name="l00256"></a>00256    <span class="comment">//noncopyable</span>
<a name="l00257"></a>00257    <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a8246ea323aea53f94eab22ce4adffbc7">sgtree_impl</a> (<span class="keyword">const</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html">sgtree_impl</a>&amp;);
<a name="l00258"></a>00258    <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html">sgtree_impl</a> operator =(<span class="keyword">const</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html">sgtree_impl</a>&amp;);
<a name="l00259"></a>00259 
<a name="l00260"></a>00260    <span class="keyword">enum</span> { safemode_or_autounlink  = 
<a name="l00261"></a>00261             (int)real_value_traits::link_mode == (<span class="keywordtype">int</span>)auto_unlink   ||
<a name="l00262"></a>00262             (int)real_value_traits::link_mode == (<span class="keywordtype">int</span>)safe_link     };
<a name="l00263"></a>00263 
<a name="l00264"></a>00264    BOOST_STATIC_ASSERT(((<span class="keywordtype">int</span>)real_value_traits::link_mode != (<span class="keywordtype">int</span>)auto_unlink));
<a name="l00265"></a>00265 
<a name="l00266"></a>00266    <span class="comment">//BOOST_STATIC_ASSERT((</span>
<a name="l00267"></a>00267    <span class="comment">//                     (int)real_value_traits::link_mode != (int)auto_unlink ||</span>
<a name="l00268"></a>00268    <span class="comment">//                     !floating_point</span>
<a name="l00269"></a>00269    <span class="comment">//                   ));</span>
<a name="l00270"></a>00270 
<a name="l00271"></a>00271    <span class="keyword">struct </span>header_plus_alpha : <span class="keyword">public</span> alpha_traits
<a name="l00272"></a>00272    {  node header_;  };
<a name="l00273"></a>00273 
<a name="l00274"></a>00274    <span class="keyword">struct </span>node_plus_pred_t : <span class="keyword">public</span> detail::ebo_functor_holder&lt;value_compare&gt;
<a name="l00275"></a>00275    {
<a name="l00276"></a>00276       node_plus_pred_t(<span class="keyword">const</span> value_compare &amp;comp)
<a name="l00277"></a>00277          :  <a class="code" href="classboost_1_1intrusive_1_1detail_1_1ebo__functor__holder.html">detail::ebo_functor_holder&lt;value_compare&gt;</a>(comp)
<a name="l00278"></a>00278       {}
<a name="l00279"></a>00279       header_plus_alpha header_plus_alpha_;
<a name="l00280"></a>00280       size_traits size_traits_;
<a name="l00281"></a>00281    };
<a name="l00282"></a>00282 
<a name="l00283"></a>00283    <span class="keyword">struct </span>data_t : <span class="keyword">public</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html">sgtree_impl</a>::value_traits
<a name="l00284"></a>00284    {
<a name="l00285"></a>00285       <span class="keyword">typedef</span> <span class="keyword">typename</span> sgtree_impl::value_traits value_traits;
<a name="l00286"></a>00286       data_t(<span class="keyword">const</span> value_compare &amp; comp, <span class="keyword">const</span> value_traits &amp;val_traits)
<a name="l00287"></a>00287          :  value_traits(val_traits), node_plus_pred_(comp)
<a name="l00288"></a>00288          ,  max_tree_size_(0)
<a name="l00289"></a>00289       {}
<a name="l00290"></a>00290       node_plus_pred_t node_plus_pred_;
<a name="l00291"></a>00291       size_type max_tree_size_;
<a name="l00292"></a>00292    } data_;
<a name="l00293"></a>00293 
<a name="l00294"></a>00294    <span class="keywordtype">float</span> priv_alpha()<span class="keyword"> const</span>
<a name="l00295"></a>00295 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;priv_alpha_traits().get_alpha();  }
<a name="l00296"></a>00296 
<a name="l00297"></a>00297    <span class="keywordtype">void</span> priv_alpha(<span class="keywordtype">float</span> alpha)
<a name="l00298"></a>00298    {  <span class="keywordflow">return</span> this-&gt;priv_alpha_traits().set_alpha(alpha);  }
<a name="l00299"></a>00299   
<a name="l00300"></a>00300    <span class="keyword">const</span> value_compare &amp;priv_comp()<span class="keyword"> const</span>
<a name="l00301"></a>00301 <span class="keyword">   </span>{  <span class="keywordflow">return</span> data_.node_plus_pred_.get();  }
<a name="l00302"></a>00302 
<a name="l00303"></a>00303    value_compare &amp;priv_comp()
<a name="l00304"></a>00304    {  <span class="keywordflow">return</span> data_.node_plus_pred_.get();  }
<a name="l00305"></a>00305 
<a name="l00306"></a>00306    <span class="keyword">const</span> node &amp;priv_header()<span class="keyword"> const</span>
<a name="l00307"></a>00307 <span class="keyword">   </span>{  <span class="keywordflow">return</span> data_.node_plus_pred_.header_plus_alpha_.header_;  }
<a name="l00308"></a>00308 
<a name="l00309"></a>00309    node &amp;priv_header()
<a name="l00310"></a>00310    {  <span class="keywordflow">return</span> data_.node_plus_pred_.header_plus_alpha_.header_;  }
<a name="l00311"></a>00311 
<a name="l00312"></a>00312    <span class="keyword">static</span> node_ptr uncast(const_node_ptr ptr)
<a name="l00313"></a>00313    {  <span class="keywordflow">return</span> node_ptr(const_cast&lt;node*&gt;(detail::boost_intrusive_get_pointer(ptr)));  }
<a name="l00314"></a>00314 
<a name="l00315"></a>00315    size_traits &amp;priv_size_traits()
<a name="l00316"></a>00316    {  <span class="keywordflow">return</span> data_.node_plus_pred_.size_traits_;  }
<a name="l00317"></a>00317 
<a name="l00318"></a>00318    <span class="keyword">const</span> size_traits &amp;priv_size_traits()<span class="keyword"> const</span>
<a name="l00319"></a>00319 <span class="keyword">   </span>{  <span class="keywordflow">return</span> data_.node_plus_pred_.size_traits_;  }
<a name="l00320"></a>00320 
<a name="l00321"></a>00321    alpha_traits &amp;priv_alpha_traits()
<a name="l00322"></a>00322    {  <span class="keywordflow">return</span> data_.node_plus_pred_.header_plus_alpha_;  }
<a name="l00323"></a>00323 
<a name="l00324"></a>00324    <span class="keyword">const</span> alpha_traits &amp;priv_alpha_traits()<span class="keyword"> const</span>
<a name="l00325"></a>00325 <span class="keyword">   </span>{  <span class="keywordflow">return</span> data_.node_plus_pred_.header_plus_alpha_;  }
<a name="l00326"></a>00326 
<a name="l00327"></a>00327    <span class="keyword">const</span> real_value_traits &amp;get_real_value_traits(<a class="code" href="structboost_1_1intrusive_1_1detail_1_1bool__.html">detail::bool_&lt;false&gt;</a>)<span class="keyword"> const</span>
<a name="l00328"></a>00328 <span class="keyword">   </span>{  <span class="keywordflow">return</span> data_;  }
<a name="l00329"></a>00329 
<a name="l00330"></a>00330    <span class="keyword">const</span> real_value_traits &amp;get_real_value_traits(<a class="code" href="structboost_1_1intrusive_1_1detail_1_1bool__.html">detail::bool_&lt;true&gt;</a>)<span class="keyword"> const</span>
<a name="l00331"></a>00331 <span class="keyword">   </span>{  <span class="keywordflow">return</span> data_.get_value_traits(*<span class="keyword">this</span>);  }
<a name="l00332"></a>00332 
<a name="l00333"></a>00333    real_value_traits &amp;get_real_value_traits(<a class="code" href="structboost_1_1intrusive_1_1detail_1_1bool__.html">detail::bool_&lt;false&gt;</a>)
<a name="l00334"></a>00334    {  <span class="keywordflow">return</span> data_;  }
<a name="l00335"></a>00335 
<a name="l00336"></a>00336    real_value_traits &amp;get_real_value_traits(<a class="code" href="structboost_1_1intrusive_1_1detail_1_1bool__.html">detail::bool_&lt;true&gt;</a>)
<a name="l00337"></a>00337    {  <span class="keywordflow">return</span> data_.get_value_traits(*<span class="keyword">this</span>);  }
<a name="l00338"></a>00338 
<a name="l00339"></a>00339    h_alpha_t get_h_alpha_func()<span class="keyword"> const</span>
<a name="l00340"></a>00340 <span class="keyword">   </span>{  <span class="keywordflow">return</span> priv_alpha_traits().get_h_alpha_t();  }
<a name="l00341"></a>00341 
<a name="l00342"></a>00342    multiply_by_alpha_t get_alpha_by_max_size_func()<span class="keyword"> const</span>
<a name="l00343"></a>00343 <span class="keyword">   </span>{  <span class="keywordflow">return</span> priv_alpha_traits().get_multiply_by_alpha_t(); }
<a name="l00344"></a>00344 
<a name="l00346"></a>00346 
<a name="l00347"></a>00347    <span class="keyword">public</span>:
<a name="l00348"></a>00348 
<a name="l00349"></a>00349    <span class="keyword">const</span> real_value_traits &amp;get_real_value_traits()<span class="keyword"> const</span>
<a name="l00350"></a>00350 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;get_real_value_traits(<a class="code" href="structboost_1_1intrusive_1_1detail_1_1bool__.html">detail::bool_&lt;external_value_traits&gt;</a>());  }
<a name="l00351"></a>00351 
<a name="l00352"></a>00352    real_value_traits &amp;get_real_value_traits()
<a name="l00353"></a>00353    {  <span class="keywordflow">return</span> this-&gt;get_real_value_traits(<a class="code" href="structboost_1_1intrusive_1_1detail_1_1bool__.html">detail::bool_&lt;external_value_traits&gt;</a>());  }
<a name="l00354"></a>00354 
<a name="l00355"></a>00355    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structboost_1_1intrusive_1_1sgtree__algorithms_1_1insert__commit__data.html">node_algorithms::insert_commit_data</a> <a class="code" href="structboost_1_1intrusive_1_1sgtree__algorithms_1_1insert__commit__data.html">insert_commit_data</a>;
<a name="l00356"></a>00356 
<a name="l00364"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a8246ea323aea53f94eab22ce4adffbc7">00364</a>    <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a8246ea323aea53f94eab22ce4adffbc7">sgtree_impl</a>( <span class="keyword">const</span> value_compare &amp;cmp     = value_compare()
<a name="l00365"></a>00365               , <span class="keyword">const</span> value_traits &amp;v_traits = value_traits()) 
<a name="l00366"></a>00366       :  data_(cmp, v_traits)
<a name="l00367"></a>00367    {  
<a name="l00368"></a>00368       <a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#a03ed1468c62cbfe13b9c92cdbea92207">node_algorithms::init_header</a>(&amp;priv_header());  
<a name="l00369"></a>00369       this-&gt;priv_size_traits().set_size(size_type(0));
<a name="l00370"></a>00370    }
<a name="l00371"></a>00371 
<a name="l00384"></a>00384    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;
<a name="l00385"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ab2c6f012fbd8510994c75e8d348f0202">00385</a>    <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a8246ea323aea53f94eab22ce4adffbc7">sgtree_impl</a>( <span class="keywordtype">bool</span> unique, Iterator b, Iterator e
<a name="l00386"></a>00386               , <span class="keyword">const</span> value_compare &amp;cmp     = value_compare()
<a name="l00387"></a>00387               , <span class="keyword">const</span> value_traits &amp;v_traits = value_traits())
<a name="l00388"></a>00388       : data_(cmp, v_traits)
<a name="l00389"></a>00389    {
<a name="l00390"></a>00390       <a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#a03ed1468c62cbfe13b9c92cdbea92207">node_algorithms::init_header</a>(&amp;priv_header());
<a name="l00391"></a>00391       this-&gt;priv_size_traits().set_size(size_type(0));
<a name="l00392"></a>00392       <span class="keywordflow">if</span>(unique)
<a name="l00393"></a>00393          this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ab8fec331dad7c719d9cf63eafd3181c2">insert_unique</a>(b, e);
<a name="l00394"></a>00394       <span class="keywordflow">else</span>
<a name="l00395"></a>00395          this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a66bdb7afe7ff7cf5a71b29dab7ae818e">insert_equal</a>(b, e);
<a name="l00396"></a>00396    }
<a name="l00397"></a>00397 
<a name="l00405"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ab77e88e1352847d1220f4bbae81cd955">00405</a>    <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ab77e88e1352847d1220f4bbae81cd955">~sgtree_impl</a>() 
<a name="l00406"></a>00406    {}
<a name="l00407"></a>00407 
<a name="l00413"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a5af7d7ea4b5987bcb8bc809be31fdf8c">00413</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a5af7d7ea4b5987bcb8bc809be31fdf8c">begin</a>()
<a name="l00414"></a>00414    {  <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> (node_traits::get_left(node_ptr(&amp;priv_header())), <span class="keyword">this</span>);   }
<a name="l00415"></a>00415 
<a name="l00421"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ae950b0b67224df9c5fa717f47cf2821a">00421</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a5af7d7ea4b5987bcb8bc809be31fdf8c">begin</a>()<span class="keyword"> const</span>
<a name="l00422"></a>00422 <span class="keyword">   </span>{  <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a95fb30fc403d9affec1390f9eeafe9e2">cbegin</a>();   }
<a name="l00423"></a>00423 
<a name="l00429"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a95fb30fc403d9affec1390f9eeafe9e2">00429</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a95fb30fc403d9affec1390f9eeafe9e2">cbegin</a>()<span class="keyword"> const</span>
<a name="l00430"></a>00430 <span class="keyword">   </span>{  <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> (node_traits::get_left(const_node_ptr(&amp;priv_header())), <span class="keyword">this</span>);   }
<a name="l00431"></a>00431 
<a name="l00437"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ab059089e12e3c67ad90df29d1c8383e2">00437</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ab059089e12e3c67ad90df29d1c8383e2">end</a>()
<a name="l00438"></a>00438    {  <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> (node_ptr(&amp;priv_header()), <span class="keyword">this</span>);  }
<a name="l00439"></a>00439 
<a name="l00445"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ac8ea18a297130bfbefb434622b22b4c6">00445</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ab059089e12e3c67ad90df29d1c8383e2">end</a>()<span class="keyword"> const</span>
<a name="l00446"></a>00446 <span class="keyword">   </span>{  <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ac216bdae3d8746f9c7b1db0fb9f56995">cend</a>();  }
<a name="l00447"></a>00447 
<a name="l00453"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ac216bdae3d8746f9c7b1db0fb9f56995">00453</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ac216bdae3d8746f9c7b1db0fb9f56995">cend</a>()<span class="keyword"> const</span>
<a name="l00454"></a>00454 <span class="keyword">   </span>{  <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> (uncast(const_node_ptr(&amp;priv_header())), <span class="keyword">this</span>);  }
<a name="l00455"></a>00455 
<a name="l00462"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ae7c74d940cea1564f0cdf1d6f854dd82">00462</a>    reverse_iterator <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ae7c74d940cea1564f0cdf1d6f854dd82">rbegin</a>()
<a name="l00463"></a>00463    {  <span class="keywordflow">return</span> reverse_iterator(<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ab059089e12e3c67ad90df29d1c8383e2">end</a>());  }
<a name="l00464"></a>00464 
<a name="l00471"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a4a0ab63124278a502ed8fe071c686652">00471</a>    const_reverse_iterator <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ae7c74d940cea1564f0cdf1d6f854dd82">rbegin</a>()<span class="keyword"> const</span>
<a name="l00472"></a>00472 <span class="keyword">   </span>{  <span class="keywordflow">return</span> const_reverse_iterator(<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ab059089e12e3c67ad90df29d1c8383e2">end</a>());  }
<a name="l00473"></a>00473 
<a name="l00480"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a2d28df7318c6d6514ea10fde5cf284a1">00480</a>    const_reverse_iterator <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a2d28df7318c6d6514ea10fde5cf284a1">crbegin</a>()<span class="keyword"> const</span>
<a name="l00481"></a>00481 <span class="keyword">   </span>{  <span class="keywordflow">return</span> const_reverse_iterator(<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ab059089e12e3c67ad90df29d1c8383e2">end</a>());  }
<a name="l00482"></a>00482 
<a name="l00489"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a9b9ae19245201ae0ffe9d68b305c0fd6">00489</a>    reverse_iterator <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a9b9ae19245201ae0ffe9d68b305c0fd6">rend</a>()
<a name="l00490"></a>00490    {  <span class="keywordflow">return</span> reverse_iterator(<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a5af7d7ea4b5987bcb8bc809be31fdf8c">begin</a>());   }
<a name="l00491"></a>00491 
<a name="l00498"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ae87e0f85deaf02cd295be1be1a4fbaf7">00498</a>    const_reverse_iterator <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a9b9ae19245201ae0ffe9d68b305c0fd6">rend</a>()<span class="keyword"> const</span>
<a name="l00499"></a>00499 <span class="keyword">   </span>{  <span class="keywordflow">return</span> const_reverse_iterator(<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a5af7d7ea4b5987bcb8bc809be31fdf8c">begin</a>());   }
<a name="l00500"></a>00500 
<a name="l00507"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a1e2d683a58108024631f958364916e33">00507</a>    const_reverse_iterator <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a1e2d683a58108024631f958364916e33">crend</a>()<span class="keyword"> const</span>
<a name="l00508"></a>00508 <span class="keyword">   </span>{  <span class="keywordflow">return</span> const_reverse_iterator(<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a5af7d7ea4b5987bcb8bc809be31fdf8c">begin</a>());   }
<a name="l00509"></a>00509 
<a name="l00518"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a31423c43a815f168fc89310dfd9758ad">00518</a>    <span class="keyword">static</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html">sgtree_impl</a> &amp;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a31423c43a815f168fc89310dfd9758ad">container_from_end_iterator</a>(<a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> end_iterator)
<a name="l00519"></a>00519    {  <span class="keywordflow">return</span> priv_container_from_end_iterator(end_iterator);   }
<a name="l00520"></a>00520 
<a name="l00529"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a6734ddfd498a71a922f25ae49b32bcdd">00529</a>    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html">sgtree_impl</a> &amp;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a31423c43a815f168fc89310dfd9758ad">container_from_end_iterator</a>(<a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> end_iterator)
<a name="l00530"></a>00530    {  <span class="keywordflow">return</span> priv_container_from_end_iterator(end_iterator);   }
<a name="l00531"></a>00531 
<a name="l00540"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a081ba569cd906de830fad074554cf541">00540</a>    <span class="keyword">static</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html">sgtree_impl</a> &amp;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a081ba569cd906de830fad074554cf541">container_from_iterator</a>(<a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> it)
<a name="l00541"></a>00541    {  <span class="keywordflow">return</span> priv_container_from_iterator(it);   }
<a name="l00542"></a>00542 
<a name="l00551"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a9855860ce8ff6161acf87197f052bff8">00551</a>    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html">sgtree_impl</a> &amp;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a081ba569cd906de830fad074554cf541">container_from_iterator</a>(<a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> it)
<a name="l00552"></a>00552    {  <span class="keywordflow">return</span> priv_container_from_iterator(it);   }
<a name="l00553"></a>00553 
<a name="l00559"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a1c38aa6df9920176c79adb600bb2af55">00559</a>    value_compare <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a1c38aa6df9920176c79adb600bb2af55">value_comp</a>()<span class="keyword"> const</span>
<a name="l00560"></a>00560 <span class="keyword">   </span>{  <span class="keywordflow">return</span> priv_comp();   }
<a name="l00561"></a>00561 
<a name="l00567"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a9cf00cf3596d8355fb7a625d445f8497">00567</a>    <span class="keywordtype">bool</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a9cf00cf3596d8355fb7a625d445f8497">empty</a>()<span class="keyword"> const</span>
<a name="l00568"></a>00568 <span class="keyword">   </span>{  <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#a40a362af6041bfc43edf0456d3f3d94f">node_algorithms::unique</a>(const_node_ptr(&amp;priv_header()));   }
<a name="l00569"></a>00569 
<a name="l00576"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a8f293d3b93e9cbbc198353171d85f99c">00576</a>    size_type <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a8f293d3b93e9cbbc198353171d85f99c">size</a>()<span class="keyword"> const</span>
<a name="l00577"></a>00577 <span class="keyword">   </span>{
<a name="l00578"></a>00578       <span class="keywordflow">if</span>(<a class="code" href="structboost_1_1intrusive_1_1constant__time__size.html">constant_time_size</a>)
<a name="l00579"></a>00579          <span class="keywordflow">return</span> this-&gt;priv_size_traits().get_size();
<a name="l00580"></a>00580       <span class="keywordflow">else</span>{
<a name="l00581"></a>00581          <span class="keywordflow">return</span> (size_type)<a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#a9ac5bdff75ccc619ff4c3ac82e4c38a6">node_algorithms::size</a>(const_node_ptr(&amp;priv_header()));
<a name="l00582"></a>00582       }
<a name="l00583"></a>00583    }
<a name="l00584"></a>00584 
<a name="l00590"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a7f33d3c43a7bddb8e8c7151abc03a2ce">00590</a>    <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a7f33d3c43a7bddb8e8c7151abc03a2ce">swap</a>(<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html">sgtree_impl</a>&amp; other)
<a name="l00591"></a>00591    {
<a name="l00592"></a>00592       <span class="comment">//This can throw</span>
<a name="l00593"></a>00593       <span class="keyword">using</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a7f33d3c43a7bddb8e8c7151abc03a2ce">std::swap</a>;
<a name="l00594"></a>00594       <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a7f33d3c43a7bddb8e8c7151abc03a2ce">swap</a>(priv_comp(), priv_comp());
<a name="l00595"></a>00595       <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a7f33d3c43a7bddb8e8c7151abc03a2ce">swap</a>(priv_alpha_traits(), priv_alpha_traits());
<a name="l00596"></a>00596       <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a7f33d3c43a7bddb8e8c7151abc03a2ce">swap</a>(data_.max_tree_size_, other.data_.max_tree_size_);
<a name="l00597"></a>00597       <span class="comment">//These can&#39;t throw</span>
<a name="l00598"></a>00598       <a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#a091da965abb8b3b6e56ad42b9e184b58">node_algorithms::swap_tree</a>(node_ptr(&amp;priv_header()), node_ptr(&amp;other.priv_header()));
<a name="l00599"></a>00599       <span class="keywordflow">if</span>(<a class="code" href="structboost_1_1intrusive_1_1constant__time__size.html">constant_time_size</a>){
<a name="l00600"></a>00600          size_type backup = this-&gt;priv_size_traits().get_size();
<a name="l00601"></a>00601          this-&gt;priv_size_traits().set_size(other.priv_size_traits().get_size());
<a name="l00602"></a>00602          other.priv_size_traits().set_size(backup);
<a name="l00603"></a>00603       }
<a name="l00604"></a>00604    }
<a name="l00605"></a>00605 
<a name="l00617"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a66bdb7afe7ff7cf5a71b29dab7ae818e">00617</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a66bdb7afe7ff7cf5a71b29dab7ae818e">insert_equal</a>(reference value)
<a name="l00618"></a>00618    {
<a name="l00619"></a>00619       <a class="code" href="structboost_1_1intrusive_1_1detail_1_1key__nodeptr__comp.html">detail::key_nodeptr_comp&lt;value_compare, sgtree_impl&gt;</a>
<a name="l00620"></a>00620          key_node_comp(priv_comp(), <span class="keyword">this</span>);
<a name="l00621"></a>00621       node_ptr to_insert(get_real_value_traits().to_node_ptr(value));
<a name="l00622"></a>00622       <span class="keywordflow">if</span>(safemode_or_autounlink)
<a name="l00623"></a>00623          BOOST_INTRUSIVE_SAFE_HOOK_DEFAULT_ASSERT(<a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#a40a362af6041bfc43edf0456d3f3d94f">node_algorithms::unique</a>(to_insert));
<a name="l00624"></a>00624       this-&gt;priv_size_traits().increment();
<a name="l00625"></a>00625       std::size_t max_tree_size = (std::size_t)data_.max_tree_size_;
<a name="l00626"></a>00626       node_ptr p = <a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#a2201e008bfb9e6ffc71f851922c0c886">node_algorithms::insert_equal_upper_bound</a>
<a name="l00627"></a>00627          (node_ptr(&amp;priv_header()), to_insert, key_node_comp
<a name="l00628"></a>00628          , (size_type)this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a8f293d3b93e9cbbc198353171d85f99c">size</a>(), this-&gt;get_h_alpha_func(), max_tree_size);
<a name="l00629"></a>00629       data_.max_tree_size_ = (size_type)max_tree_size;
<a name="l00630"></a>00630       <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>(p, <span class="keyword">this</span>);
<a name="l00631"></a>00631    }
<a name="l00632"></a>00632 
<a name="l00647"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a2efac32b6f807f7290f2c2430e8929cf">00647</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a66bdb7afe7ff7cf5a71b29dab7ae818e">insert_equal</a>(<a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> hint, reference value)
<a name="l00648"></a>00648    {
<a name="l00649"></a>00649       <a class="code" href="structboost_1_1intrusive_1_1detail_1_1key__nodeptr__comp.html">detail::key_nodeptr_comp&lt;value_compare, sgtree_impl&gt;</a>
<a name="l00650"></a>00650          key_node_comp(priv_comp(), <span class="keyword">this</span>);
<a name="l00651"></a>00651       node_ptr to_insert(get_real_value_traits().to_node_ptr(value));
<a name="l00652"></a>00652       <span class="keywordflow">if</span>(safemode_or_autounlink)
<a name="l00653"></a>00653          BOOST_INTRUSIVE_SAFE_HOOK_DEFAULT_ASSERT(<a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#a40a362af6041bfc43edf0456d3f3d94f">node_algorithms::unique</a>(to_insert));
<a name="l00654"></a>00654       this-&gt;priv_size_traits().increment();
<a name="l00655"></a>00655       std::size_t max_tree_size = (std::size_t)data_.max_tree_size_;
<a name="l00656"></a>00656       node_ptr p = <a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#aa325c4d7b3b14fced285681c51737bef">node_algorithms::insert_equal</a>
<a name="l00657"></a>00657          (node_ptr(&amp;priv_header()), hint.pointed_node(), to_insert, key_node_comp
<a name="l00658"></a>00658          , (std::size_t)this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a8f293d3b93e9cbbc198353171d85f99c">size</a>(), this-&gt;get_h_alpha_func(), max_tree_size);
<a name="l00659"></a>00659       data_.max_tree_size_ = (size_type)max_tree_size;
<a name="l00660"></a>00660       <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>(p, <span class="keyword">this</span>);
<a name="l00661"></a>00661    }
<a name="l00662"></a>00662 
<a name="l00677"></a>00677    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;
<a name="l00678"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a5c975eadf58a66e7625360571a9f77b4">00678</a>    <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a66bdb7afe7ff7cf5a71b29dab7ae818e">insert_equal</a>(Iterator b, Iterator e)
<a name="l00679"></a>00679    {
<a name="l00680"></a>00680       <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ab059089e12e3c67ad90df29d1c8383e2">end</a>(this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ab059089e12e3c67ad90df29d1c8383e2">end</a>());
<a name="l00681"></a>00681       <span class="keywordflow">for</span> (; b != e; ++b)
<a name="l00682"></a>00682          this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a66bdb7afe7ff7cf5a71b29dab7ae818e">insert_equal</a>(end, *b);
<a name="l00683"></a>00683    }
<a name="l00684"></a>00684 
<a name="l00697"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ab8fec331dad7c719d9cf63eafd3181c2">00697</a>    std::pair&lt;iterator, bool&gt; <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ab8fec331dad7c719d9cf63eafd3181c2">insert_unique</a>(reference value)
<a name="l00698"></a>00698    {
<a name="l00699"></a>00699       <a class="code" href="structboost_1_1intrusive_1_1sgtree__algorithms_1_1insert__commit__data.html">insert_commit_data</a> commit_data;
<a name="l00700"></a>00700       std::pair&lt;iterator, bool&gt; ret = <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#aacc349cb7f118ac5c34d2de159f8dd81">insert_unique_check</a>(value, priv_comp(), commit_data);
<a name="l00701"></a>00701       <span class="keywordflow">if</span>(!ret.second)
<a name="l00702"></a>00702          <span class="keywordflow">return</span> ret;
<a name="l00703"></a>00703       <span class="keywordflow">return</span> std::pair&lt;iterator, bool&gt; (<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a14939df01fd4f692a129f408adfd6d7e">insert_unique_commit</a>(value, commit_data), <span class="keyword">true</span>);
<a name="l00704"></a>00704    }
<a name="l00705"></a>00705 
<a name="l00720"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#af81a0c8213d257076f5c8d8406308d18">00720</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ab8fec331dad7c719d9cf63eafd3181c2">insert_unique</a>(<a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> hint, reference value)
<a name="l00721"></a>00721    {
<a name="l00722"></a>00722       <a class="code" href="structboost_1_1intrusive_1_1sgtree__algorithms_1_1insert__commit__data.html">insert_commit_data</a> commit_data;
<a name="l00723"></a>00723       std::pair&lt;iterator, bool&gt; ret = <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#aacc349cb7f118ac5c34d2de159f8dd81">insert_unique_check</a>(hint, value, priv_comp(), commit_data);
<a name="l00724"></a>00724       <span class="keywordflow">if</span>(!ret.second)
<a name="l00725"></a>00725          <span class="keywordflow">return</span> ret.first;
<a name="l00726"></a>00726       <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a14939df01fd4f692a129f408adfd6d7e">insert_unique_commit</a>(value, commit_data);
<a name="l00727"></a>00727    }
<a name="l00728"></a>00728 
<a name="l00742"></a>00742    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;
<a name="l00743"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a6c3a5f61638e5a96a8362e87a375a261">00743</a>    <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ab8fec331dad7c719d9cf63eafd3181c2">insert_unique</a>(Iterator b, Iterator e)
<a name="l00744"></a>00744    {
<a name="l00745"></a>00745       <span class="keywordflow">if</span>(this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a9cf00cf3596d8355fb7a625d445f8497">empty</a>()){
<a name="l00746"></a>00746          <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ab059089e12e3c67ad90df29d1c8383e2">end</a>(this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ab059089e12e3c67ad90df29d1c8383e2">end</a>());
<a name="l00747"></a>00747          <span class="keywordflow">for</span> (; b != e; ++b)
<a name="l00748"></a>00748             this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ab8fec331dad7c719d9cf63eafd3181c2">insert_unique</a>(end, *b);
<a name="l00749"></a>00749       }
<a name="l00750"></a>00750       <span class="keywordflow">else</span>{
<a name="l00751"></a>00751          <span class="keywordflow">for</span> (; b != e; ++b)
<a name="l00752"></a>00752             this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ab8fec331dad7c719d9cf63eafd3181c2">insert_unique</a>(*b);
<a name="l00753"></a>00753       }
<a name="l00754"></a>00754    }
<a name="l00755"></a>00755 
<a name="l00786"></a>00786    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyValueCompare&gt;
<a name="l00787"></a>00787    std::pair&lt;iterator, bool&gt; <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#aacc349cb7f118ac5c34d2de159f8dd81">insert_unique_check</a>
<a name="l00788"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#aacc349cb7f118ac5c34d2de159f8dd81">00788</a>       (<span class="keyword">const</span> KeyType &amp;key, KeyValueCompare key_value_comp, <a class="code" href="structboost_1_1intrusive_1_1sgtree__algorithms_1_1insert__commit__data.html">insert_commit_data</a> &amp;commit_data)
<a name="l00789"></a>00789    {
<a name="l00790"></a>00790       <a class="code" href="structboost_1_1intrusive_1_1detail_1_1key__nodeptr__comp.html">detail::key_nodeptr_comp&lt;KeyValueCompare, sgtree_impl&gt;</a>
<a name="l00791"></a>00791          comp(key_value_comp, <span class="keyword">this</span>);
<a name="l00792"></a>00792       std::pair&lt;node_ptr, bool&gt; ret = 
<a name="l00793"></a>00793          (<a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#aa2f403aa85750b3db18e7346e77d4be3">node_algorithms::insert_unique_check</a>
<a name="l00794"></a>00794             (node_ptr(&amp;priv_header()), key, comp, commit_data));
<a name="l00795"></a>00795       <span class="keywordflow">return</span> std::pair&lt;iterator, bool&gt;(<a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>(ret.first, <span class="keyword">this</span>), ret.second);
<a name="l00796"></a>00796    }
<a name="l00797"></a>00797 
<a name="l00830"></a>00830    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyValueCompare&gt;
<a name="l00831"></a>00831    std::pair&lt;iterator, bool&gt; <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#aacc349cb7f118ac5c34d2de159f8dd81">insert_unique_check</a>
<a name="l00832"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a2f6679bca52760aff9c2169ba9a44929">00832</a>       (<a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> hint, <span class="keyword">const</span> KeyType &amp;key
<a name="l00833"></a>00833       ,KeyValueCompare key_value_comp, <a class="code" href="structboost_1_1intrusive_1_1sgtree__algorithms_1_1insert__commit__data.html">insert_commit_data</a> &amp;commit_data)
<a name="l00834"></a>00834    {
<a name="l00835"></a>00835       <a class="code" href="structboost_1_1intrusive_1_1detail_1_1key__nodeptr__comp.html">detail::key_nodeptr_comp&lt;KeyValueCompare, sgtree_impl&gt;</a>
<a name="l00836"></a>00836          comp(key_value_comp, <span class="keyword">this</span>);
<a name="l00837"></a>00837       std::pair&lt;node_ptr, bool&gt; ret = 
<a name="l00838"></a>00838          (<a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#aa2f403aa85750b3db18e7346e77d4be3">node_algorithms::insert_unique_check</a>
<a name="l00839"></a>00839             (node_ptr(&amp;priv_header()), hint.pointed_node(), key, comp, commit_data));
<a name="l00840"></a>00840       <span class="keywordflow">return</span> std::pair&lt;iterator, bool&gt;(<a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>(ret.first, <span class="keyword">this</span>), ret.second);
<a name="l00841"></a>00841    }
<a name="l00842"></a>00842 
<a name="l00860"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a14939df01fd4f692a129f408adfd6d7e">00860</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a14939df01fd4f692a129f408adfd6d7e">insert_unique_commit</a>(reference value, <span class="keyword">const</span> <a class="code" href="structboost_1_1intrusive_1_1sgtree__algorithms_1_1insert__commit__data.html">insert_commit_data</a> &amp;commit_data)
<a name="l00861"></a>00861    {
<a name="l00862"></a>00862       node_ptr to_insert(get_real_value_traits().to_node_ptr(value));
<a name="l00863"></a>00863       <span class="keywordflow">if</span>(safemode_or_autounlink)
<a name="l00864"></a>00864          BOOST_INTRUSIVE_SAFE_HOOK_DEFAULT_ASSERT(<a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#a40a362af6041bfc43edf0456d3f3d94f">node_algorithms::unique</a>(to_insert));
<a name="l00865"></a>00865       this-&gt;priv_size_traits().increment();
<a name="l00866"></a>00866       std::size_t max_tree_size = (std::size_t)data_.max_tree_size_;
<a name="l00867"></a>00867       <a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#af5a721f41e6e84e7c5a1e7cbaad4eafc">node_algorithms::insert_unique_commit</a>
<a name="l00868"></a>00868          ( node_ptr(&amp;priv_header()), to_insert, commit_data
<a name="l00869"></a>00869          , (std::size_t)this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a8f293d3b93e9cbbc198353171d85f99c">size</a>(), this-&gt;get_h_alpha_func(), max_tree_size);
<a name="l00870"></a>00870       data_.max_tree_size_ = (size_type)max_tree_size;
<a name="l00871"></a>00871       <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>(to_insert, <span class="keyword">this</span>);
<a name="l00872"></a>00872    }
<a name="l00873"></a>00873 
<a name="l00888"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a33f0b0182f41dcbde743690a56ece6fa">00888</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a33f0b0182f41dcbde743690a56ece6fa">insert_before</a>(<a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> pos, reference value)
<a name="l00889"></a>00889    {
<a name="l00890"></a>00890       node_ptr to_insert(get_real_value_traits().to_node_ptr(value));
<a name="l00891"></a>00891       <span class="keywordflow">if</span>(safemode_or_autounlink)
<a name="l00892"></a>00892          BOOST_INTRUSIVE_SAFE_HOOK_DEFAULT_ASSERT(<a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#a40a362af6041bfc43edf0456d3f3d94f">node_algorithms::unique</a>(to_insert));
<a name="l00893"></a>00893       this-&gt;priv_size_traits().increment();
<a name="l00894"></a>00894       std::size_t max_tree_size = (std::size_t)data_.max_tree_size_;
<a name="l00895"></a>00895       node_ptr p = <a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#a19be4aadcbc8698151dd6360eaebb00b">node_algorithms::insert_before</a>
<a name="l00896"></a>00896          ( node_ptr(&amp;priv_header()), pos.pointed_node(), to_insert
<a name="l00897"></a>00897          , (size_type)this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a8f293d3b93e9cbbc198353171d85f99c">size</a>(), this-&gt;get_h_alpha_func(), max_tree_size);
<a name="l00898"></a>00898       data_.max_tree_size_ = (size_type)max_tree_size;
<a name="l00899"></a>00899       <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>(p, <span class="keyword">this</span>);
<a name="l00900"></a>00900    }
<a name="l00901"></a>00901 
<a name="l00916"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ab359e2855ab22a2bfeb232999aba8a9a">00916</a>    <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ab359e2855ab22a2bfeb232999aba8a9a">push_back</a>(reference value)
<a name="l00917"></a>00917    {
<a name="l00918"></a>00918       node_ptr to_insert(get_real_value_traits().to_node_ptr(value));
<a name="l00919"></a>00919       <span class="keywordflow">if</span>(safemode_or_autounlink)
<a name="l00920"></a>00920          BOOST_INTRUSIVE_SAFE_HOOK_DEFAULT_ASSERT(<a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#a40a362af6041bfc43edf0456d3f3d94f">node_algorithms::unique</a>(to_insert));
<a name="l00921"></a>00921       this-&gt;priv_size_traits().increment();
<a name="l00922"></a>00922       std::size_t max_tree_size = (std::size_t)data_.max_tree_size_;
<a name="l00923"></a>00923       <a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#a055fe46171453b371cfe80a856e413d4">node_algorithms::push_back</a>
<a name="l00924"></a>00924          ( node_ptr(&amp;priv_header()), to_insert 
<a name="l00925"></a>00925          , (size_type)this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a8f293d3b93e9cbbc198353171d85f99c">size</a>(), this-&gt;get_h_alpha_func(), max_tree_size);
<a name="l00926"></a>00926       data_.max_tree_size_ = (size_type)max_tree_size;
<a name="l00927"></a>00927    }
<a name="l00928"></a>00928 
<a name="l00943"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a23bee95e908b8f4017e7c19e5f3240cb">00943</a>    <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a23bee95e908b8f4017e7c19e5f3240cb">push_front</a>(reference value)
<a name="l00944"></a>00944    {
<a name="l00945"></a>00945       node_ptr to_insert(get_real_value_traits().to_node_ptr(value));
<a name="l00946"></a>00946       <span class="keywordflow">if</span>(safemode_or_autounlink)
<a name="l00947"></a>00947          BOOST_INTRUSIVE_SAFE_HOOK_DEFAULT_ASSERT(<a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#a40a362af6041bfc43edf0456d3f3d94f">node_algorithms::unique</a>(to_insert));
<a name="l00948"></a>00948       this-&gt;priv_size_traits().increment();
<a name="l00949"></a>00949       std::size_t max_tree_size = (std::size_t)data_.max_tree_size_;
<a name="l00950"></a>00950       <a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#a0e5731d055d5809f1db9904369726c3a">node_algorithms::push_front</a>
<a name="l00951"></a>00951          ( node_ptr(&amp;priv_header()), to_insert
<a name="l00952"></a>00952          , (size_type)this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a8f293d3b93e9cbbc198353171d85f99c">size</a>(), this-&gt;get_h_alpha_func(), max_tree_size);
<a name="l00953"></a>00953       data_.max_tree_size_ = (size_type)max_tree_size;
<a name="l00954"></a>00954    }
<a name="l00955"></a>00955 
<a name="l00964"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a65fef004b3dfd1c638b4df2ed9def5ca">00964</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a65fef004b3dfd1c638b4df2ed9def5ca">erase</a>(<a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> i)
<a name="l00965"></a>00965    {
<a name="l00966"></a>00966       <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> ret(i);
<a name="l00967"></a>00967       ++ret;
<a name="l00968"></a>00968       node_ptr to_erase(i.pointed_node());
<a name="l00969"></a>00969       <span class="keywordflow">if</span>(safemode_or_autounlink)
<a name="l00970"></a>00970          BOOST_INTRUSIVE_SAFE_HOOK_DEFAULT_ASSERT(!<a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#a40a362af6041bfc43edf0456d3f3d94f">node_algorithms::unique</a>(to_erase));
<a name="l00971"></a>00971       std::size_t max_tree_size = data_.max_tree_size_;
<a name="l00972"></a>00972       <a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#ab4140aa52882d22a21eaba0f7f1d83d1">node_algorithms::erase</a>
<a name="l00973"></a>00973          ( &amp;priv_header(), to_erase, (std::size_t)this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a8f293d3b93e9cbbc198353171d85f99c">size</a>()
<a name="l00974"></a>00974          , max_tree_size, this-&gt;get_alpha_by_max_size_func());
<a name="l00975"></a>00975       data_.max_tree_size_ = (size_type)max_tree_size;
<a name="l00976"></a>00976       this-&gt;priv_size_traits().decrement();
<a name="l00977"></a>00977       <span class="keywordflow">if</span>(safemode_or_autounlink)
<a name="l00978"></a>00978          <a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#adb6058455f3d118603f1d677c887bfef">node_algorithms::init</a>(to_erase);
<a name="l00979"></a>00979       <span class="keywordflow">return</span> ret.unconst();
<a name="l00980"></a>00980    }
<a name="l00981"></a>00981 
<a name="l00991"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a5356c4dd8a22e79a880abc564d30a58b">00991</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a65fef004b3dfd1c638b4df2ed9def5ca">erase</a>(<a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> b, <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> e)
<a name="l00992"></a>00992    {  size_type n;   <span class="keywordflow">return</span> private_erase(b, e, n);   }
<a name="l00993"></a>00993 
<a name="l01004"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a0941621c1f5bee0d43f75f8624c06d0f">01004</a>    size_type <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a65fef004b3dfd1c638b4df2ed9def5ca">erase</a>(const_reference value)
<a name="l01005"></a>01005    {  <span class="keywordflow">return</span> this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a0941621c1f5bee0d43f75f8624c06d0f">erase</a>(value, priv_comp());   }
<a name="l01006"></a>01006 
<a name="l01018"></a>01018    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyValueCompare&gt;
<a name="l01019"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a3cf996eb14dd5568185530bee632e94c">01019</a>    size_type <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a65fef004b3dfd1c638b4df2ed9def5ca">erase</a>(<span class="keyword">const</span> KeyType&amp; key, KeyValueCompare comp                  
<a name="l01021"></a>01021                   , <span class="keyword">typename</span> <a class="code" href="structboost_1_1intrusive_1_1detail_1_1enable__if__c.html">detail::enable_if_c</a>&lt;!<a class="code" href="classboost_1_1intrusive_1_1detail_1_1is__convertible.html">detail::is_convertible&lt;KeyValueCompare, const_iterator&gt;::value</a> &gt;::type * = 0
<a name="l01023"></a>01023                   )
<a name="l01024"></a>01024    {
<a name="l01025"></a>01025       std::pair&lt;iterator,iterator&gt; p = this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a97e642db7704888a037e9258a557617b">equal_range</a>(key, comp);
<a name="l01026"></a>01026       size_type n;
<a name="l01027"></a>01027       private_erase(p.first, p.second, n);
<a name="l01028"></a>01028       <span class="keywordflow">return</span> n;
<a name="l01029"></a>01029    }
<a name="l01030"></a>01030 
<a name="l01042"></a>01042    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Disposer&gt;
<a name="l01043"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a3bfe0691f0b3f97824eee31c2330b7b5">01043</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a3bfe0691f0b3f97824eee31c2330b7b5">erase_and_dispose</a>(<a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> i, Disposer disposer)
<a name="l01044"></a>01044    {
<a name="l01045"></a>01045       node_ptr to_erase(i.pointed_node());
<a name="l01046"></a>01046       <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> ret(this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a65fef004b3dfd1c638b4df2ed9def5ca">erase</a>(i));
<a name="l01047"></a>01047       disposer(get_real_value_traits().to_value_ptr(to_erase));
<a name="l01048"></a>01048       <span class="keywordflow">return</span> ret;
<a name="l01049"></a>01049    }
<a name="l01050"></a>01050 
<a name="l01051"></a>01051 <span class="preprocessor">   #if !defined(BOOST_INTRUSIVE_DOXYGEN_INVOKED)</span>
<a name="l01052"></a>01052 <span class="preprocessor"></span>   <span class="keyword">template</span>&lt;<span class="keyword">class</span> Disposer&gt;
<a name="l01053"></a>01053    iterator <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a3bfe0691f0b3f97824eee31c2330b7b5">erase_and_dispose</a>(iterator i, Disposer disposer)
<a name="l01054"></a>01054    {  <span class="keywordflow">return</span> this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a3bfe0691f0b3f97824eee31c2330b7b5">erase_and_dispose</a>(const_iterator(i), disposer);   }
<a name="l01055"></a>01055 <span class="preprocessor">   #endif</span>
<a name="l01056"></a>01056 <span class="preprocessor"></span>
<a name="l01069"></a>01069    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Disposer&gt;
<a name="l01070"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ada19db3083dc3475e0c5745cf8d91c7a">01070</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a3bfe0691f0b3f97824eee31c2330b7b5">erase_and_dispose</a>(<a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> b, <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> e, Disposer disposer)
<a name="l01071"></a>01071    {  size_type n;   <span class="keywordflow">return</span> private_erase(b, e, n, disposer);   }
<a name="l01072"></a>01072 
<a name="l01086"></a>01086    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Disposer&gt;
<a name="l01087"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#addcbe552d334976ff18bfbd0f8f8614e">01087</a>    size_type <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a3bfe0691f0b3f97824eee31c2330b7b5">erase_and_dispose</a>(const_reference value, Disposer disposer)
<a name="l01088"></a>01088    {
<a name="l01089"></a>01089       std::pair&lt;iterator,iterator&gt; p = this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a97e642db7704888a037e9258a557617b">equal_range</a>(value);
<a name="l01090"></a>01090       size_type n;
<a name="l01091"></a>01091       private_erase(p.first, p.second, n, disposer);
<a name="l01092"></a>01092       <span class="keywordflow">return</span> n;
<a name="l01093"></a>01093    }
<a name="l01094"></a>01094 
<a name="l01109"></a>01109    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyValueCompare, <span class="keyword">class</span> Disposer&gt;
<a name="l01110"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#aba3a410341540c81b98c30605320b33b">01110</a>    size_type <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a3bfe0691f0b3f97824eee31c2330b7b5">erase_and_dispose</a>(<span class="keyword">const</span> KeyType&amp; key, KeyValueCompare comp, Disposer disposer
<a name="l01112"></a>01112                   , <span class="keyword">typename</span> <a class="code" href="structboost_1_1intrusive_1_1detail_1_1enable__if__c.html">detail::enable_if_c</a>&lt;!<a class="code" href="classboost_1_1intrusive_1_1detail_1_1is__convertible.html">detail::is_convertible&lt;KeyValueCompare, const_iterator&gt;::value</a> &gt;::type * = 0
<a name="l01114"></a>01114                   )
<a name="l01115"></a>01115    {
<a name="l01116"></a>01116       std::pair&lt;iterator,iterator&gt; p = this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a97e642db7704888a037e9258a557617b">equal_range</a>(key, comp);
<a name="l01117"></a>01117       size_type n;
<a name="l01118"></a>01118       private_erase(p.first, p.second, n, disposer);
<a name="l01119"></a>01119       <span class="keywordflow">return</span> n;
<a name="l01120"></a>01120    }
<a name="l01121"></a>01121 
<a name="l01131"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a75aef93d4cd09d54f6b971ae9581a106">01131</a>    <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a75aef93d4cd09d54f6b971ae9581a106">clear</a>()
<a name="l01132"></a>01132    {
<a name="l01133"></a>01133       <span class="keywordflow">if</span>(safemode_or_autounlink){
<a name="l01134"></a>01134          this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a042ff4ed3bacbe840a7248b412395f51">clear_and_dispose</a>(<a class="code" href="classboost_1_1intrusive_1_1detail_1_1null__disposer.html">detail::null_disposer</a>());
<a name="l01135"></a>01135       }
<a name="l01136"></a>01136       <span class="keywordflow">else</span>{
<a name="l01137"></a>01137          <a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#a03ed1468c62cbfe13b9c92cdbea92207">node_algorithms::init_header</a>(&amp;priv_header());
<a name="l01138"></a>01138          this-&gt;priv_size_traits().set_size(0);
<a name="l01139"></a>01139       }
<a name="l01140"></a>01140    }
<a name="l01141"></a>01141 
<a name="l01151"></a>01151    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Disposer&gt;
<a name="l01152"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a042ff4ed3bacbe840a7248b412395f51">01152</a>    <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a042ff4ed3bacbe840a7248b412395f51">clear_and_dispose</a>(Disposer disposer)
<a name="l01153"></a>01153    {
<a name="l01154"></a>01154       <a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#a3f864b1b84f6b522c1ad614c963b2db3">node_algorithms::clear_and_dispose</a>(node_ptr(&amp;priv_header())
<a name="l01155"></a>01155          , <a class="code" href="structboost_1_1intrusive_1_1detail_1_1node__disposer.html">detail::node_disposer&lt;Disposer, sgtree_impl&gt;</a>(disposer, <span class="keyword">this</span>));
<a name="l01156"></a>01156       this-&gt;priv_size_traits().set_size(0);
<a name="l01157"></a>01157    }
<a name="l01158"></a>01158 
<a name="l01165"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#acf7307b3ba66483ab31f7c1054b72976">01165</a>    size_type <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#acf7307b3ba66483ab31f7c1054b72976">count</a>(const_reference value)<span class="keyword"> const</span>
<a name="l01166"></a>01166 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#acf7307b3ba66483ab31f7c1054b72976">count</a>(value, priv_comp());   }
<a name="l01167"></a>01167 
<a name="l01174"></a>01174    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyValueCompare&gt;
<a name="l01175"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a591e64dd688863eccf78f39a6c8aefec">01175</a>    size_type <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#acf7307b3ba66483ab31f7c1054b72976">count</a>(<span class="keyword">const</span> KeyType &amp;key, KeyValueCompare comp)<span class="keyword"> const</span>
<a name="l01176"></a>01176 <span class="keyword">   </span>{
<a name="l01177"></a>01177       std::pair&lt;const_iterator, const_iterator&gt; ret = this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a97e642db7704888a037e9258a557617b">equal_range</a>(key, comp);
<a name="l01178"></a>01178       <span class="keywordflow">return</span> std::distance(ret.first, ret.second);
<a name="l01179"></a>01179    }
<a name="l01180"></a>01180 
<a name="l01187"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ad9e79116ad08629c48b2c5a3de29dd04">01187</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ad9e79116ad08629c48b2c5a3de29dd04">lower_bound</a>(const_reference value)
<a name="l01188"></a>01188    {  <span class="keywordflow">return</span> this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ad9e79116ad08629c48b2c5a3de29dd04">lower_bound</a>(value, priv_comp());   }
<a name="l01189"></a>01189 
<a name="l01196"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ae91171f9718a5cad7d2ad293411c3b6a">01196</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ad9e79116ad08629c48b2c5a3de29dd04">lower_bound</a>(const_reference value)<span class="keyword"> const</span>
<a name="l01197"></a>01197 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ae91171f9718a5cad7d2ad293411c3b6a">lower_bound</a>(value, priv_comp());   }
<a name="l01198"></a>01198 
<a name="l01205"></a>01205    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyValueCompare&gt;
<a name="l01206"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a97a5a104a839cf9ac9ccc62ec2f1e693">01206</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ad9e79116ad08629c48b2c5a3de29dd04">lower_bound</a>(<span class="keyword">const</span> KeyType &amp;key, KeyValueCompare comp)
<a name="l01207"></a>01207    {
<a name="l01208"></a>01208       <a class="code" href="structboost_1_1intrusive_1_1detail_1_1key__nodeptr__comp.html">detail::key_nodeptr_comp&lt;KeyValueCompare, sgtree_impl&gt;</a>
<a name="l01209"></a>01209          key_node_comp(comp, <span class="keyword">this</span>);
<a name="l01210"></a>01210       <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>(<a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#ae3d0c69f4a8a7adb33014d98591c9155">node_algorithms::lower_bound</a>
<a name="l01211"></a>01211          (const_node_ptr(&amp;priv_header()), key, key_node_comp), <span class="keyword">this</span>);
<a name="l01212"></a>01212    }
<a name="l01213"></a>01213 
<a name="l01220"></a>01220    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyValueCompare&gt;
<a name="l01221"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a17daad489965ea57549aaa0d0ce19379">01221</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ad9e79116ad08629c48b2c5a3de29dd04">lower_bound</a>(<span class="keyword">const</span> KeyType &amp;key, KeyValueCompare comp)<span class="keyword"> const</span>
<a name="l01222"></a>01222 <span class="keyword">   </span>{
<a name="l01223"></a>01223       <a class="code" href="structboost_1_1intrusive_1_1detail_1_1key__nodeptr__comp.html">detail::key_nodeptr_comp&lt;KeyValueCompare, sgtree_impl&gt;</a>
<a name="l01224"></a>01224          key_node_comp(comp, <span class="keyword">this</span>);
<a name="l01225"></a>01225       <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>(<a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#ae3d0c69f4a8a7adb33014d98591c9155">node_algorithms::lower_bound</a>
<a name="l01226"></a>01226          (const_node_ptr(&amp;priv_header()), key, key_node_comp), <span class="keyword">this</span>);
<a name="l01227"></a>01227    }
<a name="l01228"></a>01228 
<a name="l01235"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a9cb10740b8099f551092f765264ff5f1">01235</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a9cb10740b8099f551092f765264ff5f1">upper_bound</a>(const_reference value)
<a name="l01236"></a>01236    {  <span class="keywordflow">return</span> this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a9cb10740b8099f551092f765264ff5f1">upper_bound</a>(value, priv_comp());   }
<a name="l01237"></a>01237 
<a name="l01245"></a>01245    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyValueCompare&gt;
<a name="l01246"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a2625af97b6fbf860630c2ce170490dee">01246</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a9cb10740b8099f551092f765264ff5f1">upper_bound</a>(<span class="keyword">const</span> KeyType &amp;key, KeyValueCompare comp)
<a name="l01247"></a>01247    {
<a name="l01248"></a>01248       <a class="code" href="structboost_1_1intrusive_1_1detail_1_1key__nodeptr__comp.html">detail::key_nodeptr_comp&lt;KeyValueCompare, sgtree_impl&gt;</a>
<a name="l01249"></a>01249          key_node_comp(comp, <span class="keyword">this</span>);
<a name="l01250"></a>01250       <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>(<a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#a6129b435044492f78fe30c4de4861443">node_algorithms::upper_bound</a>
<a name="l01251"></a>01251          (const_node_ptr(&amp;priv_header()), key, key_node_comp), <span class="keyword">this</span>);
<a name="l01252"></a>01252    }
<a name="l01253"></a>01253 
<a name="l01260"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a708cbf34a458d4261031a4bd4e796846">01260</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a9cb10740b8099f551092f765264ff5f1">upper_bound</a>(const_reference value)<span class="keyword"> const</span>
<a name="l01261"></a>01261 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a708cbf34a458d4261031a4bd4e796846">upper_bound</a>(value, priv_comp());   }
<a name="l01262"></a>01262 
<a name="l01270"></a>01270    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyValueCompare&gt;
<a name="l01271"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ad9018eb71530d3ecb4618ad6e97d8fbf">01271</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a9cb10740b8099f551092f765264ff5f1">upper_bound</a>(<span class="keyword">const</span> KeyType &amp;key, KeyValueCompare comp)<span class="keyword"> const</span>
<a name="l01272"></a>01272 <span class="keyword">   </span>{
<a name="l01273"></a>01273       <a class="code" href="structboost_1_1intrusive_1_1detail_1_1key__nodeptr__comp.html">detail::key_nodeptr_comp&lt;KeyValueCompare, sgtree_impl&gt;</a>
<a name="l01274"></a>01274          key_node_comp(comp, <span class="keyword">this</span>);
<a name="l01275"></a>01275       <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>(<a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#a6129b435044492f78fe30c4de4861443">node_algorithms::upper_bound</a>
<a name="l01276"></a>01276          (const_node_ptr(&amp;priv_header()), key, key_node_comp), <span class="keyword">this</span>);
<a name="l01277"></a>01277    }
<a name="l01278"></a>01278 
<a name="l01285"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a8a991fa77c3fc3199b0fffdecf227291">01285</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a8a991fa77c3fc3199b0fffdecf227291">find</a>(const_reference value)
<a name="l01286"></a>01286    {  <span class="keywordflow">return</span> this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a8a991fa77c3fc3199b0fffdecf227291">find</a>(value, priv_comp()); }
<a name="l01287"></a>01287 
<a name="l01294"></a>01294    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyValueCompare&gt;
<a name="l01295"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a740682d3c29776a4f457fa69a14cfd08">01295</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a8a991fa77c3fc3199b0fffdecf227291">find</a>(<span class="keyword">const</span> KeyType &amp;key, KeyValueCompare comp)
<a name="l01296"></a>01296    {
<a name="l01297"></a>01297       <a class="code" href="structboost_1_1intrusive_1_1detail_1_1key__nodeptr__comp.html">detail::key_nodeptr_comp&lt;KeyValueCompare, sgtree_impl&gt;</a>
<a name="l01298"></a>01298          key_node_comp(comp, <span class="keyword">this</span>);
<a name="l01299"></a>01299       <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>
<a name="l01300"></a>01300          (<a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#a6c9544c271a1ecad194f0596fe2002a6">node_algorithms::find</a>(const_node_ptr(&amp;priv_header()), key, key_node_comp), <span class="keyword">this</span>);
<a name="l01301"></a>01301    }
<a name="l01302"></a>01302 
<a name="l01309"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a93e6cfb1673b37582700b656234583ff">01309</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a8a991fa77c3fc3199b0fffdecf227291">find</a>(const_reference value)<span class="keyword"> const</span>
<a name="l01310"></a>01310 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a93e6cfb1673b37582700b656234583ff">find</a>(value, priv_comp()); }
<a name="l01311"></a>01311 
<a name="l01318"></a>01318    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyValueCompare&gt;
<a name="l01319"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a4810b144276018692907ddb37b6d5b0a">01319</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a8a991fa77c3fc3199b0fffdecf227291">find</a>(<span class="keyword">const</span> KeyType &amp;key, KeyValueCompare comp)<span class="keyword"> const</span>
<a name="l01320"></a>01320 <span class="keyword">   </span>{
<a name="l01321"></a>01321       <a class="code" href="structboost_1_1intrusive_1_1detail_1_1key__nodeptr__comp.html">detail::key_nodeptr_comp&lt;KeyValueCompare, sgtree_impl&gt;</a>
<a name="l01322"></a>01322          key_node_comp(comp, <span class="keyword">this</span>);
<a name="l01323"></a>01323       <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>
<a name="l01324"></a>01324          (<a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#a6c9544c271a1ecad194f0596fe2002a6">node_algorithms::find</a>(const_node_ptr(&amp;priv_header()), key, key_node_comp), <span class="keyword">this</span>);
<a name="l01325"></a>01325    }
<a name="l01326"></a>01326 
<a name="l01334"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a97e642db7704888a037e9258a557617b">01334</a>    std::pair&lt;iterator,iterator&gt; <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a97e642db7704888a037e9258a557617b">equal_range</a>(const_reference value)
<a name="l01335"></a>01335    {  <span class="keywordflow">return</span> this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a97e642db7704888a037e9258a557617b">equal_range</a>(value, priv_comp());   }
<a name="l01336"></a>01336 
<a name="l01344"></a>01344    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyValueCompare&gt;
<a name="l01345"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#afc24cac097f33ce26938a2adda9c9ea6">01345</a>    std::pair&lt;iterator,iterator&gt; <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a97e642db7704888a037e9258a557617b">equal_range</a>(<span class="keyword">const</span> KeyType &amp;key, KeyValueCompare comp)
<a name="l01346"></a>01346    {
<a name="l01347"></a>01347       <a class="code" href="structboost_1_1intrusive_1_1detail_1_1key__nodeptr__comp.html">detail::key_nodeptr_comp&lt;KeyValueCompare, sgtree_impl&gt;</a>
<a name="l01348"></a>01348          key_node_comp(comp, <span class="keyword">this</span>);
<a name="l01349"></a>01349       std::pair&lt;node_ptr, node_ptr&gt; ret
<a name="l01350"></a>01350          (<a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#aa21871df4546e6e48818813c95571e6b">node_algorithms::equal_range</a>(const_node_ptr(&amp;priv_header()), key, key_node_comp));
<a name="l01351"></a>01351       <span class="keywordflow">return</span> std::pair&lt;iterator, iterator&gt;(<a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>(ret.first, <span class="keyword">this</span>), <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>(ret.second, <span class="keyword">this</span>));
<a name="l01352"></a>01352    }
<a name="l01353"></a>01353 
<a name="l01361"></a>01361    std::pair&lt;const_iterator, const_iterator&gt;
<a name="l01362"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a916f8f13f9c2c3c4fb64743ad5a8a025">01362</a>       <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a97e642db7704888a037e9258a557617b">equal_range</a>(const_reference value)<span class="keyword"> const</span>
<a name="l01363"></a>01363 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a916f8f13f9c2c3c4fb64743ad5a8a025">equal_range</a>(value, priv_comp());   }
<a name="l01364"></a>01364 
<a name="l01372"></a>01372    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyValueCompare&gt;
<a name="l01373"></a>01373    std::pair&lt;const_iterator, const_iterator&gt;
<a name="l01374"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#aedec49a5622bbf078a0285c3b7a0c8a1">01374</a>       <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a97e642db7704888a037e9258a557617b">equal_range</a>(<span class="keyword">const</span> KeyType &amp;key, KeyValueCompare comp)<span class="keyword"> const</span>
<a name="l01375"></a>01375 <span class="keyword">   </span>{
<a name="l01376"></a>01376       <a class="code" href="structboost_1_1intrusive_1_1detail_1_1key__nodeptr__comp.html">detail::key_nodeptr_comp&lt;KeyValueCompare, sgtree_impl&gt;</a>
<a name="l01377"></a>01377          key_node_comp(comp, <span class="keyword">this</span>);
<a name="l01378"></a>01378       std::pair&lt;node_ptr, node_ptr&gt; ret
<a name="l01379"></a>01379          (<a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#aa21871df4546e6e48818813c95571e6b">node_algorithms::equal_range</a>(const_node_ptr(&amp;priv_header()), key, key_node_comp));
<a name="l01380"></a>01380       <span class="keywordflow">return</span> std::pair&lt;const_iterator, const_iterator&gt;(<a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>(ret.first, <span class="keyword">this</span>), <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>(ret.second, <span class="keyword">this</span>));
<a name="l01381"></a>01381    }
<a name="l01382"></a>01382 
<a name="l01397"></a>01397    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Cloner, <span class="keyword">class</span> Disposer&gt;
<a name="l01398"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ab46a85b17ff13e99203a52fa7d1e8e6b">01398</a>    <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#ab46a85b17ff13e99203a52fa7d1e8e6b">clone_from</a>(<span class="keyword">const</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html">sgtree_impl</a> &amp;src, Cloner cloner, Disposer disposer)
<a name="l01399"></a>01399    {
<a name="l01400"></a>01400       this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a042ff4ed3bacbe840a7248b412395f51">clear_and_dispose</a>(disposer);
<a name="l01401"></a>01401       <span class="keywordflow">if</span>(!src.<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a9cf00cf3596d8355fb7a625d445f8497">empty</a>()){
<a name="l01402"></a>01402          <a class="code" href="classboost_1_1intrusive_1_1detail_1_1exception__disposer.html">detail::exception_disposer&lt;sgtree_impl, Disposer&gt;</a>
<a name="l01403"></a>01403             rollback(*<span class="keyword">this</span>, disposer);
<a name="l01404"></a>01404          <a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#ac26cf7c2381463e3504e815267f9c632">node_algorithms::clone</a>
<a name="l01405"></a>01405             (const_node_ptr(&amp;src.priv_header())
<a name="l01406"></a>01406             ,node_ptr(&amp;this-&gt;priv_header())
<a name="l01407"></a>01407             ,<a class="code" href="structboost_1_1intrusive_1_1detail_1_1node__cloner.html">detail::node_cloner&lt;Cloner, sgtree_impl&gt;</a>(cloner, <span class="keyword">this</span>)
<a name="l01408"></a>01408             ,<a class="code" href="structboost_1_1intrusive_1_1detail_1_1node__disposer.html">detail::node_disposer&lt;Disposer, sgtree_impl&gt;</a>(disposer, <span class="keyword">this</span>));
<a name="l01409"></a>01409          this-&gt;priv_size_traits().set_size(src.priv_size_traits().get_size());
<a name="l01410"></a>01410          this-&gt;priv_comp() = src.priv_comp();
<a name="l01411"></a>01411          rollback.release();
<a name="l01412"></a>01412       }
<a name="l01413"></a>01413    }
<a name="l01414"></a>01414 
<a name="l01425"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a09ea70721fca52928d915d46e47909d0">01425</a>    pointer <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a09ea70721fca52928d915d46e47909d0">unlink_leftmost_without_rebalance</a>()
<a name="l01426"></a>01426    {
<a name="l01427"></a>01427       node_ptr to_be_disposed(<a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#a66ea086108eae72968e2dda150781ed8">node_algorithms::unlink_leftmost_without_rebalance</a>
<a name="l01428"></a>01428                            (node_ptr(&amp;priv_header())));
<a name="l01429"></a>01429       <span class="keywordflow">if</span>(!to_be_disposed)
<a name="l01430"></a>01430          <span class="keywordflow">return</span> 0;
<a name="l01431"></a>01431       this-&gt;priv_size_traits().decrement();
<a name="l01432"></a>01432       <span class="keywordflow">if</span>(safemode_or_autounlink)<span class="comment">//If this is commented does not work with normal_link</span>
<a name="l01433"></a>01433          <a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#adb6058455f3d118603f1d677c887bfef">node_algorithms::init</a>(to_be_disposed);
<a name="l01434"></a>01434       <span class="keywordflow">return</span> get_real_value_traits().to_value_ptr(to_be_disposed);
<a name="l01435"></a>01435    }
<a name="l01436"></a>01436 
<a name="l01451"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a289a8bfd2c93c52d8d75b33b5fed037b">01451</a>    <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a289a8bfd2c93c52d8d75b33b5fed037b">replace_node</a>(<a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> replace_this, reference with_this)
<a name="l01452"></a>01452    {
<a name="l01453"></a>01453       <a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#afc73c2509a33a7e42f0a2cb133a64414">node_algorithms::replace_node</a>( get_real_value_traits().to_node_ptr(*replace_this)
<a name="l01454"></a>01454                                    , node_ptr(&amp;priv_header())
<a name="l01455"></a>01455                                    , get_real_value_traits().to_node_ptr(with_this));
<a name="l01456"></a>01456    }
<a name="l01457"></a>01457 
<a name="l01470"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a63f374ed7d4cac63477aab237d12806c">01470</a>    <span class="keyword">static</span> <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a63f374ed7d4cac63477aab237d12806c">s_iterator_to</a>(reference value)
<a name="l01471"></a>01471    {
<a name="l01472"></a>01472       BOOST_STATIC_ASSERT((!stateful_value_traits));
<a name="l01473"></a>01473       <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> (value_traits::to_node_ptr(value), 0);
<a name="l01474"></a>01474    }
<a name="l01475"></a>01475 
<a name="l01488"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a287ce8c6e9534db7f6bca6c5667d4ed8">01488</a>    <span class="keyword">static</span> <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a63f374ed7d4cac63477aab237d12806c">s_iterator_to</a>(const_reference value) 
<a name="l01489"></a>01489    {
<a name="l01490"></a>01490       BOOST_STATIC_ASSERT((!stateful_value_traits));
<a name="l01491"></a>01491       <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> (value_traits::to_node_ptr(const_cast&lt;reference&gt; (value)), 0);
<a name="l01492"></a>01492    }
<a name="l01493"></a>01493 
<a name="l01503"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#abb51f4e8c6038a71e68d287b945f1dee">01503</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#abb51f4e8c6038a71e68d287b945f1dee">iterator_to</a>(reference value)
<a name="l01504"></a>01504    {  <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> (value_traits::to_node_ptr(value), <span class="keyword">this</span>); }
<a name="l01505"></a>01505 
<a name="l01515"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#aa14d36aa74591144f7e10e858ab7e8f9">01515</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#abb51f4e8c6038a71e68d287b945f1dee">iterator_to</a>(const_reference value)<span class="keyword"> const</span>
<a name="l01516"></a>01516 <span class="keyword">   </span>{  <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> (value_traits::to_node_ptr(const_cast&lt;reference&gt; (value)), <span class="keyword">this</span>); }
<a name="l01517"></a>01517 
<a name="l01529"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a2040ee009321cfe7f0bc7da2452d618f">01529</a>    <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a2040ee009321cfe7f0bc7da2452d618f">init_node</a>(reference value)
<a name="l01530"></a>01530    { <a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#adb6058455f3d118603f1d677c887bfef">node_algorithms::init</a>(value_traits::to_node_ptr(value)); }
<a name="l01531"></a>01531 
<a name="l01537"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a3d0435cb7cdaf0ea635da7169c662b34">01537</a>    <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a3d0435cb7cdaf0ea635da7169c662b34">rebalance</a>()
<a name="l01538"></a>01538    {  <a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#abd7a3b8cbf1cb0873fc05376b623eab5">node_algorithms::rebalance</a>(node_ptr(&amp;priv_header())); }
<a name="l01539"></a>01539 
<a name="l01549"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#aa1dff6eb5a66b9ea4e9df1b5ff7b4a47">01549</a>    <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#aa1dff6eb5a66b9ea4e9df1b5ff7b4a47">rebalance_subtree</a>(<a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> root)
<a name="l01550"></a>01550    {  <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>(<a class="code" href="classboost_1_1intrusive_1_1sgtree__algorithms.html#a4813731d6d86560cb3ea6db578b48c3b">node_algorithms::rebalance_subtree</a>(root.pointed_node()), <span class="keyword">this</span>); }
<a name="l01551"></a>01551 
<a name="l01557"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a1d8043d6a36bfbe6d8c464ac2b017b73">01557</a>    <span class="keywordtype">float</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a1d8043d6a36bfbe6d8c464ac2b017b73">balance_factor</a>()<span class="keyword"> const</span>
<a name="l01558"></a>01558 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;priv_alpha(); }
<a name="l01559"></a>01559 
<a name="l01568"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a7dc7427938242db7c8520d07fa7d4f75">01568</a>    <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a1d8043d6a36bfbe6d8c464ac2b017b73">balance_factor</a>(<span class="keywordtype">float</span> new_alpha)
<a name="l01569"></a>01569    {
<a name="l01570"></a>01570       BOOST_INTRUSIVE_INVARIANT_ASSERT((new_alpha &gt; 0.5f &amp;&amp; new_alpha &lt; 1.0f));
<a name="l01571"></a>01571       <span class="keywordflow">if</span>(new_alpha &lt; 0.5f &amp;&amp; new_alpha &gt;= 1.0f)  <span class="keywordflow">return</span>;
<a name="l01572"></a>01572 
<a name="l01573"></a>01573       <span class="comment">//The alpha factor CAN&#39;t be changed if the fixed, floating operation-less</span>
<a name="l01574"></a>01574       <span class="comment">//1/sqrt(2) alpha factor option is activated</span>
<a name="l01575"></a>01575       BOOST_STATIC_ASSERT((<a class="code" href="structboost_1_1intrusive_1_1floating__point.html">floating_point</a>));
<a name="l01576"></a>01576       <span class="keywordtype">float</span> old_alpha = this-&gt;priv_alpha();
<a name="l01577"></a>01577       this-&gt;priv_alpha(new_alpha);
<a name="l01578"></a>01578 
<a name="l01579"></a>01579       <span class="keywordflow">if</span>(new_alpha &lt; old_alpha){
<a name="l01580"></a>01580          data_.max_tree_size_ = this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a8f293d3b93e9cbbc198353171d85f99c">size</a>();
<a name="l01581"></a>01581          this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a3d0435cb7cdaf0ea635da7169c662b34">rebalance</a>();
<a name="l01582"></a>01582       }
<a name="l01583"></a>01583    }
<a name="l01584"></a>01584 <span class="comment">/*</span>
<a name="l01597"></a>01597 <span class="comment">   template&lt;class T&gt;</span>
<a name="l01598"></a>01598 <span class="comment">   static void remove_node(T&amp; value)</span>
<a name="l01599"></a>01599 <span class="comment">   {</span>
<a name="l01600"></a>01600 <span class="comment">      //This function is only usable for safe mode hooks and non-constant</span>
<a name="l01601"></a>01601 <span class="comment">      //time lists. </span>
<a name="l01602"></a>01602 <span class="comment">      //BOOST_STATIC_ASSERT((!(safemode_or_autounlink &amp;&amp; constant_time_size)));</span>
<a name="l01603"></a>01603 <span class="comment">      BOOST_STATIC_ASSERT((!constant_time_size));</span>
<a name="l01604"></a>01604 <span class="comment">      BOOST_STATIC_ASSERT((boost::is_convertible&lt;T, value_type&gt;::value));</span>
<a name="l01605"></a>01605 <span class="comment">      node_ptr to_remove(value_traits::to_node_ptr(value));</span>
<a name="l01606"></a>01606 <span class="comment">      node_algorithms::unlink_and_rebalance(to_remove);</span>
<a name="l01607"></a>01607 <span class="comment">      if(safemode_or_autounlink)</span>
<a name="l01608"></a>01608 <span class="comment">         node_algorithms::init(to_remove);</span>
<a name="l01609"></a>01609 <span class="comment">   }</span>
<a name="l01610"></a>01610 <span class="comment">*/</span>
<a name="l01611"></a>01611 
<a name="l01613"></a>01613    <span class="keyword">private</span>:
<a name="l01614"></a>01614    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Disposer&gt;
<a name="l01615"></a>01615    iterator private_erase(const_iterator b, const_iterator e, <a class="code" href="structboost_1_1intrusive_1_1size__type.html">size_type</a> &amp;n, Disposer disposer)
<a name="l01616"></a>01616    {
<a name="l01617"></a>01617       <span class="keywordflow">for</span>(n = 0; b != e; ++n)
<a name="l01618"></a>01618         this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a3bfe0691f0b3f97824eee31c2330b7b5">erase_and_dispose</a>(b++, disposer);
<a name="l01619"></a>01619       <span class="keywordflow">return</span> b.unconst();
<a name="l01620"></a>01620    }
<a name="l01621"></a>01621 
<a name="l01622"></a>01622    iterator private_erase(const_iterator b, const_iterator e, size_type &amp;n)
<a name="l01623"></a>01623    {
<a name="l01624"></a>01624       <span class="keywordflow">for</span>(n = 0; b != e; ++n)
<a name="l01625"></a>01625         this-&gt;<a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a65fef004b3dfd1c638b4df2ed9def5ca">erase</a>(b++);
<a name="l01626"></a>01626       <span class="keywordflow">return</span> b.unconst();
<a name="l01627"></a>01627    }
<a name="l01629"></a>01629 
<a name="l01630"></a>01630    <span class="keyword">private</span>:
<a name="l01631"></a>01631    <span class="keyword">static</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a8246ea323aea53f94eab22ce4adffbc7">sgtree_impl</a> &amp;priv_container_from_end_iterator(<span class="keyword">const</span> const_iterator &amp;end_iterator)
<a name="l01632"></a>01632    {
<a name="l01633"></a>01633       header_plus_alpha *r = detail::parent_from_member&lt;header_plus_alpha, node&gt;
<a name="l01634"></a>01634          ( detail::boost_intrusive_get_pointer(end_iterator.pointed_node()), &amp;header_plus_alpha::header_);
<a name="l01635"></a>01635       node_plus_pred_t *n = detail::parent_from_member
<a name="l01636"></a>01636          &lt;node_plus_pred_t, header_plus_alpha&gt;(r, &amp;node_plus_pred_t::header_plus_alpha_);
<a name="l01637"></a>01637       data_t *d = detail::parent_from_member&lt;data_t, node_plus_pred_t&gt;(n, &amp;data_t::node_plus_pred_);
<a name="l01638"></a>01638       <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a8246ea323aea53f94eab22ce4adffbc7">sgtree_impl</a> *scapegoat  = detail::parent_from_member&lt;sgtree_impl, data_t&gt;(d, &amp;sgtree_impl::data_);
<a name="l01639"></a>01639       <span class="keywordflow">return</span> *scapegoat;
<a name="l01640"></a>01640    }
<a name="l01641"></a>01641 
<a name="l01642"></a>01642    <span class="keyword">static</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html#a8246ea323aea53f94eab22ce4adffbc7">sgtree_impl</a> &amp;priv_container_from_iterator(<span class="keyword">const</span> const_iterator &amp;it)
<a name="l01643"></a>01643    {  <span class="keywordflow">return</span> priv_container_from_end_iterator(it.end_iterator_from_it());   }
<a name="l01644"></a>01644 };
<a name="l01645"></a>01645 
<a name="l01646"></a>01646 <span class="preprocessor">#if defined(BOOST_INTRUSIVE_DOXYGEN_INVOKED)</span>
<a name="l01647"></a>01647 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class </span>T, <span class="keyword">class </span>...Options&gt;
<a name="l01648"></a>01648 <span class="preprocessor">#else</span>
<a name="l01649"></a>01649 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class</span> Config&gt;
<a name="l01650"></a>01650 <span class="preprocessor">#endif</span>
<a name="l01651"></a>01651 <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">bool</span> <span class="keyword">operator</span>&lt;
<a name="l01652"></a>01652 <span class="preprocessor">#if defined(BOOST_INTRUSIVE_DOXYGEN_INVOKED)</span>
<a name="l01653"></a>01653 <span class="preprocessor"></span>(<span class="keyword">const</span> sgtree_impl&lt;T, Options...&gt; &amp;x, <span class="keyword">const</span> sgtree_impl&lt;T, Options...&gt; &amp;y)
<a name="l01654"></a>01654 #<span class="keywordflow">else</span>
<a name="l01655"></a>01655 (<span class="keyword">const</span> sgtree_impl&lt;Config&gt; &amp;x, <span class="keyword">const</span> sgtree_impl&lt;Config&gt; &amp;y)
<a name="l01656"></a>01656 <span class="preprocessor">#endif</span>
<a name="l01657"></a>01657 <span class="preprocessor"></span>{  <span class="keywordflow">return</span> std::lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());  }
<a name="l01658"></a>01658 
<a name="l01659"></a>01659 <span class="preprocessor">#if defined(BOOST_INTRUSIVE_DOXYGEN_INVOKED)</span>
<a name="l01660"></a>01660 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class </span>T, <span class="keyword">class </span>...Options&gt;
<a name="l01661"></a>01661 <span class="preprocessor">#else</span>
<a name="l01662"></a>01662 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class</span> Config&gt;
<a name="l01663"></a>01663 <span class="preprocessor">#endif</span>
<a name="l01664"></a>01664 <span class="preprocessor"></span><span class="keywordtype">bool</span> <span class="keyword">operator</span>==
<a name="l01665"></a>01665 <span class="preprocessor">#if defined(BOOST_INTRUSIVE_DOXYGEN_INVOKED)</span>
<a name="l01666"></a>01666 <span class="preprocessor"></span>(<span class="keyword">const</span> sgtree_impl&lt;T, Options...&gt; &amp;x, <span class="keyword">const</span> sgtree_impl&lt;T, Options...&gt; &amp;y)
<a name="l01667"></a>01667 #<span class="keywordflow">else</span>
<a name="l01668"></a>01668 (<span class="keyword">const</span> sgtree_impl&lt;Config&gt; &amp;x, <span class="keyword">const</span> sgtree_impl&lt;Config&gt; &amp;y)
<a name="l01669"></a>01669 <span class="preprocessor">#endif</span>
<a name="l01670"></a>01670 <span class="preprocessor"></span>{
<a name="l01671"></a>01671    <span class="keyword">typedef</span> sgtree_impl&lt;Config&gt; tree_type;
<a name="l01672"></a>01672    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_type::const_iterator const_iterator;
<a name="l01673"></a>01673 
<a name="l01674"></a>01674    <span class="keywordflow">if</span>(tree_type::constant_time_size &amp;&amp; x.size() != y.size()){
<a name="l01675"></a>01675       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01676"></a>01676    }
<a name="l01677"></a>01677    const_iterator end1 = x.end();
<a name="l01678"></a>01678    const_iterator i1 = x.begin();
<a name="l01679"></a>01679    const_iterator i2 = y.begin();
<a name="l01680"></a>01680    <span class="keywordflow">if</span>(tree_type::constant_time_size){
<a name="l01681"></a>01681       <span class="keywordflow">while</span> (i1 != end1 &amp;&amp; *i1 == *i2) {
<a name="l01682"></a>01682          ++i1;
<a name="l01683"></a>01683          ++i2;
<a name="l01684"></a>01684       }
<a name="l01685"></a>01685       <span class="keywordflow">return</span> i1 == end1;
<a name="l01686"></a>01686    }
<a name="l01687"></a>01687    <span class="keywordflow">else</span>{
<a name="l01688"></a>01688       const_iterator end2 = y.end();
<a name="l01689"></a>01689       <span class="keywordflow">while</span> (i1 != end1 &amp;&amp; i2 != end2 &amp;&amp; *i1 == *i2) {
<a name="l01690"></a>01690          ++i1;
<a name="l01691"></a>01691          ++i2;
<a name="l01692"></a>01692       }
<a name="l01693"></a>01693       <span class="keywordflow">return</span> i1 == end1 &amp;&amp; i2 == end2;
<a name="l01694"></a>01694    }
<a name="l01695"></a>01695 }
<a name="l01696"></a>01696 
<a name="l01697"></a>01697 <span class="preprocessor">#if defined(BOOST_INTRUSIVE_DOXYGEN_INVOKED)</span>
<a name="l01698"></a>01698 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class </span>T, <span class="keyword">class </span>...Options&gt;
<a name="l01699"></a>01699 <span class="preprocessor">#else</span>
<a name="l01700"></a>01700 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class</span> Config&gt;
<a name="l01701"></a>01701 <span class="preprocessor">#endif</span>
<a name="l01702"></a>01702 <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">bool</span> <span class="keyword">operator</span>!=
<a name="l01703"></a>01703 <span class="preprocessor">#if defined(BOOST_INTRUSIVE_DOXYGEN_INVOKED)</span>
<a name="l01704"></a>01704 <span class="preprocessor"></span>(<span class="keyword">const</span> sgtree_impl&lt;T, Options...&gt; &amp;x, <span class="keyword">const</span> sgtree_impl&lt;T, Options...&gt; &amp;y)
<a name="l01705"></a>01705 #<span class="keywordflow">else</span>
<a name="l01706"></a>01706 (<span class="keyword">const</span> sgtree_impl&lt;Config&gt; &amp;x, <span class="keyword">const</span> sgtree_impl&lt;Config&gt; &amp;y)
<a name="l01707"></a>01707 <span class="preprocessor">#endif</span>
<a name="l01708"></a>01708 <span class="preprocessor"></span>{  <span class="keywordflow">return</span> !(x == y); }
<a name="l01709"></a>01709 
<a name="l01710"></a>01710 <span class="preprocessor">#if defined(BOOST_INTRUSIVE_DOXYGEN_INVOKED)</span>
<a name="l01711"></a>01711 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class </span>T, <span class="keyword">class </span>...Options&gt;
<a name="l01712"></a>01712 <span class="preprocessor">#else</span>
<a name="l01713"></a>01713 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class</span> Config&gt;
<a name="l01714"></a>01714 <span class="preprocessor">#endif</span>
<a name="l01715"></a>01715 <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">bool</span> <span class="keyword">operator</span>&gt;
<a name="l01716"></a>01716 <span class="preprocessor">#if defined(BOOST_INTRUSIVE_DOXYGEN_INVOKED)</span>
<a name="l01717"></a>01717 <span class="preprocessor"></span>(<span class="keyword">const</span> sgtree_impl&lt;T, Options...&gt; &amp;x, <span class="keyword">const</span> sgtree_impl&lt;T, Options...&gt; &amp;y)
<a name="l01718"></a>01718 #<span class="keywordflow">else</span>
<a name="l01719"></a>01719 (<span class="keyword">const</span> sgtree_impl&lt;Config&gt; &amp;x, <span class="keyword">const</span> sgtree_impl&lt;Config&gt; &amp;y)
<a name="l01720"></a>01720 <span class="preprocessor">#endif</span>
<a name="l01721"></a>01721 <span class="preprocessor"></span>{  <span class="keywordflow">return</span> y &lt; x;  }
<a name="l01722"></a>01722 
<a name="l01723"></a>01723 <span class="preprocessor">#if defined(BOOST_INTRUSIVE_DOXYGEN_INVOKED)</span>
<a name="l01724"></a>01724 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class </span>T, <span class="keyword">class </span>...Options&gt;
<a name="l01725"></a>01725 <span class="preprocessor">#else</span>
<a name="l01726"></a>01726 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class</span> Config&gt;
<a name="l01727"></a>01727 <span class="preprocessor">#endif</span>
<a name="l01728"></a>01728 <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">bool</span> <span class="keyword">operator</span>&lt;=
<a name="l01729"></a>01729 <span class="preprocessor">#if defined(BOOST_INTRUSIVE_DOXYGEN_INVOKED)</span>
<a name="l01730"></a>01730 <span class="preprocessor"></span>(<span class="keyword">const</span> sgtree_impl&lt;T, Options...&gt; &amp;x, <span class="keyword">const</span> sgtree_impl&lt;T, Options...&gt; &amp;y)
<a name="l01731"></a>01731 #<span class="keywordflow">else</span>
<a name="l01732"></a>01732 (<span class="keyword">const</span> sgtree_impl&lt;Config&gt; &amp;x, <span class="keyword">const</span> sgtree_impl&lt;Config&gt; &amp;y)
<a name="l01733"></a>01733 <span class="preprocessor">#endif</span>
<a name="l01734"></a>01734 <span class="preprocessor"></span>{  <span class="keywordflow">return</span> !(y &lt; x);  }
<a name="l01735"></a>01735 
<a name="l01736"></a>01736 <span class="preprocessor">#if defined(BOOST_INTRUSIVE_DOXYGEN_INVOKED)</span>
<a name="l01737"></a>01737 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class </span>T, <span class="keyword">class </span>...Options&gt;
<a name="l01738"></a>01738 <span class="preprocessor">#else</span>
<a name="l01739"></a>01739 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class</span> Config&gt;
<a name="l01740"></a>01740 <span class="preprocessor">#endif</span>
<a name="l01741"></a>01741 <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">bool</span> <span class="keyword">operator</span>&gt;=
<a name="l01742"></a>01742 <span class="preprocessor">#if defined(BOOST_INTRUSIVE_DOXYGEN_INVOKED)</span>
<a name="l01743"></a>01743 <span class="preprocessor"></span>(<span class="keyword">const</span> sgtree_impl&lt;T, Options...&gt; &amp;x, <span class="keyword">const</span> sgtree_impl&lt;T, Options...&gt; &amp;y)
<a name="l01744"></a>01744 #<span class="keywordflow">else</span>
<a name="l01745"></a>01745 (<span class="keyword">const</span> sgtree_impl&lt;Config&gt; &amp;x, <span class="keyword">const</span> sgtree_impl&lt;Config&gt; &amp;y)
<a name="l01746"></a>01746 <span class="preprocessor">#endif</span>
<a name="l01747"></a>01747 <span class="preprocessor"></span>{  <span class="keywordflow">return</span> !(x &lt; y);  }
<a name="l01748"></a>01748 
<a name="l01749"></a>01749 <span class="preprocessor">#if defined(BOOST_INTRUSIVE_DOXYGEN_INVOKED)</span>
<a name="l01750"></a>01750 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class </span>T, <span class="keyword">class </span>...Options&gt;
<a name="l01751"></a>01751 <span class="preprocessor">#else</span>
<a name="l01752"></a>01752 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class</span> Config&gt;
<a name="l01753"></a>01753 <span class="preprocessor">#endif</span>
<a name="l01754"></a>01754 <span class="preprocessor"></span><span class="keyword">inline</span> <span class="keywordtype">void</span> swap
<a name="l01755"></a>01755 <span class="preprocessor">#if defined(BOOST_INTRUSIVE_DOXYGEN_INVOKED)</span>
<a name="l01756"></a>01756 <span class="preprocessor"></span>(sgtree_impl&lt;T, Options...&gt; &amp;x, sgtree_impl&lt;T, Options...&gt; &amp;y)
<a name="l01757"></a>01757 #<span class="keywordflow">else</span>
<a name="l01758"></a>01758 (sgtree_impl&lt;Config&gt; &amp;x, sgtree_impl&lt;Config&gt; &amp;y)
<a name="l01759"></a>01759 <span class="preprocessor">#endif</span>
<a name="l01760"></a>01760 <span class="preprocessor"></span>{  x.swap(y);  }
<a name="l01761"></a>01761 
<a name="l01763"></a>01763 <span class="preprocessor">#if !defined(BOOST_INTRUSIVE_VARIADIC_TEMPLATES)</span>
<a name="l01764"></a>01764 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class </span>T, <span class="keyword">class </span>O1 = none, <span class="keyword">class </span>O2 = none
<a name="l01765"></a>01765                 , <span class="keyword">class </span>O3 = none, <span class="keyword">class </span>O4 = none&gt;
<a name="l01766"></a>01766 <span class="preprocessor">#else</span>
<a name="l01767"></a>01767 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class </span>T, <span class="keyword">class </span>...Options&gt;
<a name="l01768"></a>01768 <span class="preprocessor">#endif</span>
<a name="l01769"></a>01769 <span class="preprocessor"></span><span class="keyword">struct </span>make_sgtree_opt
<a name="l01770"></a>01770 {
<a name="l01771"></a>01771    <span class="keyword">typedef</span> <span class="keyword">typename</span> pack_options
<a name="l01772"></a>01772       &lt; sg_set_defaults&lt;T&gt;, 
<a name="l01773"></a>01773 <span class="preprocessor">      #if !defined(BOOST_INTRUSIVE_VARIADIC_TEMPLATES)</span>
<a name="l01774"></a>01774 <span class="preprocessor"></span>      O1, O2, O3, O4
<a name="l01775"></a>01775 <span class="preprocessor">      #else</span>
<a name="l01776"></a>01776 <span class="preprocessor"></span>      Options...
<a name="l01777"></a>01777       #endif
<a name="l01778"></a>01778       &gt;::type packed_options;
<a name="l01779"></a>01779    <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::get_value_traits
<a name="l01780"></a>01780       &lt;T, <span class="keyword">typename</span> packed_options::value_traits&gt;::type value_traits;
<a name="l01781"></a>01781 
<a name="l01782"></a>01782    <span class="keyword">typedef</span> sg_setopt
<a name="l01783"></a>01783          &lt; value_traits
<a name="l01784"></a>01784          , <span class="keyword">typename</span> packed_options::compare
<a name="l01785"></a>01785          , <span class="keyword">typename</span> packed_options::size_type
<a name="l01786"></a>01786          , packed_options::floating_point
<a name="l01787"></a>01787          &gt; type;
<a name="l01788"></a>01788 };
<a name="l01790"></a>01790 
<a name="l01793"></a>01793 <span class="preprocessor">#if defined(BOOST_INTRUSIVE_DOXYGEN_INVOKED) || defined(BOOST_INTRUSIVE_VARIADIC_TEMPLATES)</span>
<a name="l01794"></a>01794 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class </span>T, <span class="keyword">class </span>...Options&gt;
<a name="l01795"></a>01795 <span class="preprocessor">#else</span>
<a name="l01796"></a>01796 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class </span>T, <span class="keyword">class </span>O1 = none, <span class="keyword">class </span>O2 = none
<a name="l01797"></a>01797                 , <span class="keyword">class </span>O3 = none, <span class="keyword">class </span>O4 = none&gt;
<a name="l01798"></a>01798 <span class="preprocessor">#endif</span>
<a name="l01799"></a><a class="code" href="structboost_1_1intrusive_1_1make__sgtree.html">01799</a> <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structboost_1_1intrusive_1_1make__sgtree.html">make_sgtree</a>
<a name="l01800"></a>01800 {
<a name="l01802"></a>01802    <span class="keyword">typedef</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree__impl.html">sgtree_impl</a>
<a name="l01803"></a>01803       &lt; <span class="keyword">typename</span> make_sgtree_opt&lt;T, 
<a name="l01804"></a>01804 <span class="preprocessor">         #if !defined(BOOST_INTRUSIVE_VARIADIC_TEMPLATES)</span>
<a name="l01805"></a>01805 <span class="preprocessor"></span>         O1, O2, O3, O4
<a name="l01806"></a>01806 <span class="preprocessor">         #else</span>
<a name="l01807"></a>01807 <span class="preprocessor"></span>         Options...
<a name="l01808"></a>01808          #endif
<a name="l01809"></a>01809       &gt;::type
<a name="l01810"></a>01810       &gt; implementation_defined;
<a name="l01812"></a>01812    <span class="keyword">typedef</span> implementation_defined type;
<a name="l01813"></a>01813 };
<a name="l01814"></a>01814 
<a name="l01815"></a>01815 <span class="preprocessor">#ifndef BOOST_INTRUSIVE_DOXYGEN_INVOKED</span>
<a name="l01816"></a>01816 <span class="preprocessor"></span><span class="preprocessor">#if !defined(BOOST_INTRUSIVE_VARIADIC_TEMPLATES)</span>
<a name="l01817"></a>01817 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> O1, <span class="keyword">class</span> O2, <span class="keyword">class</span> O3, <span class="keyword">class</span> O4&gt;
<a name="l01818"></a>01818 <span class="preprocessor">#else</span>
<a name="l01819"></a>01819 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class </span>T, <span class="keyword">class </span>...Options&gt;
<a name="l01820"></a>01820 <span class="preprocessor">#endif</span>
<a name="l01821"></a><a class="code" href="classboost_1_1intrusive_1_1sgtree.html">01821</a> <span class="preprocessor"></span><span class="keyword">class </span><a class="code" href="classboost_1_1intrusive_1_1sgtree.html">sgtree</a>
<a name="l01822"></a>01822    :  <span class="keyword">public</span> <a class="code" href="structboost_1_1intrusive_1_1make__sgtree.html">make_sgtree</a>&lt;T, 
<a name="l01823"></a>01823          #if !defined(BOOST_INTRUSIVE_VARIADIC_TEMPLATES)
<a name="l01824"></a>01824          O1, O2, O3, O4
<a name="l01825"></a>01825          #else
<a name="l01826"></a>01826          Options...
<a name="l01827"></a>01827          #endif
<a name="l01828"></a>01828       &gt;::type
<a name="l01829"></a>01829 {
<a name="l01830"></a>01830    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structboost_1_1intrusive_1_1make__sgtree.html">make_sgtree</a>
<a name="l01831"></a>01831       &lt;T, 
<a name="l01832"></a>01832 <span class="preprocessor">         #if !defined(BOOST_INTRUSIVE_VARIADIC_TEMPLATES)</span>
<a name="l01833"></a>01833 <span class="preprocessor"></span>         O1, O2, O3, O4
<a name="l01834"></a>01834 <span class="preprocessor">         #else</span>
<a name="l01835"></a>01835 <span class="preprocessor"></span>         Options...
<a name="l01836"></a>01836          #endif
<a name="l01837"></a>01837       &gt;::type   Base;
<a name="l01838"></a>01838 
<a name="l01839"></a>01839    <span class="keyword">public</span>:
<a name="l01840"></a>01840    <span class="keyword">typedef</span> <span class="keyword">typename</span> Base::value_compare      value_compare;
<a name="l01841"></a>01841    <span class="keyword">typedef</span> <span class="keyword">typename</span> Base::value_traits       value_traits;
<a name="l01842"></a>01842    <span class="keyword">typedef</span> <span class="keyword">typename</span> Base::real_value_traits  real_value_traits;
<a name="l01843"></a>01843    <span class="keyword">typedef</span> <span class="keyword">typename</span> Base::iterator           iterator;
<a name="l01844"></a>01844    <span class="keyword">typedef</span> <span class="keyword">typename</span> Base::const_iterator     const_iterator;
<a name="l01845"></a>01845 
<a name="l01846"></a>01846    <span class="comment">//Assert if passed value traits are compatible with the type</span>
<a name="l01847"></a>01847    BOOST_STATIC_ASSERT((<a class="code" href="structboost_1_1intrusive_1_1detail_1_1is__same.html">detail::is_same&lt;typename real_value_traits::value_type, T&gt;::value</a>));
<a name="l01848"></a>01848 
<a name="l01849"></a>01849    <a class="code" href="classboost_1_1intrusive_1_1sgtree.html">sgtree</a>( <span class="keyword">const</span> value_compare &amp;cmp = value_compare()
<a name="l01850"></a>01850          , <span class="keyword">const</span> value_traits &amp;v_traits = value_traits())
<a name="l01851"></a>01851       :  Base(cmp, v_traits)
<a name="l01852"></a>01852    {}
<a name="l01853"></a>01853 
<a name="l01854"></a>01854    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;
<a name="l01855"></a>01855    <a class="code" href="classboost_1_1intrusive_1_1sgtree.html">sgtree</a>( <span class="keywordtype">bool</span> unique, Iterator b, Iterator e
<a name="l01856"></a>01856          , <span class="keyword">const</span> value_compare &amp;cmp = value_compare()
<a name="l01857"></a>01857          , <span class="keyword">const</span> value_traits &amp;v_traits = value_traits())
<a name="l01858"></a>01858       :  Base(unique, b, e, cmp, v_traits)
<a name="l01859"></a>01859    {}
<a name="l01860"></a>01860 
<a name="l01861"></a>01861    <span class="keyword">static</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree.html">sgtree</a> &amp;container_from_end_iterator(iterator end_iterator)
<a name="l01862"></a>01862    {  <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><a class="code" href="classboost_1_1intrusive_1_1sgtree.html">sgtree</a> &amp;<span class="keyword">&gt;</span>(Base::container_from_end_iterator(end_iterator));   }
<a name="l01863"></a>01863 
<a name="l01864"></a>01864    <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classboost_1_1intrusive_1_1sgtree.html">sgtree</a> &amp;container_from_end_iterator(const_iterator end_iterator)
<a name="l01865"></a>01865    {  <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span><a class="code" href="classboost_1_1intrusive_1_1sgtree.html">sgtree</a> &amp;<span class="keyword">&gt;</span>(Base::container_from_end_iterator(end_iterator));   }
<a name="l01866"></a>01866 };
<a name="l01867"></a>01867 
<a name="l01868"></a>01868 <span class="preprocessor">#endif</span>
<a name="l01869"></a>01869 <span class="preprocessor"></span>
<a name="l01870"></a>01870 
<a name="l01871"></a>01871 } <span class="comment">//namespace intrusive </span>
<a name="l01872"></a>01872 } <span class="comment">//namespace boost </span>
<a name="l01873"></a>01873 
<a name="l01874"></a>01874 <span class="preprocessor">#include &lt;boost/intrusive/detail/config_end.hpp&gt;</span>
<a name="l01875"></a>01875 
<a name="l01876"></a>01876 <span class="preprocessor">#endif //BOOST_INTRUSIVE_SGTREE_HPP</span>
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Apr 27 2011 00:50:06 for Nutcracker by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
