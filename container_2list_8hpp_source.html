<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nutcracker: list.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>list.hpp</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00002"></a>00002 <span class="comment">//</span>
<a name="l00003"></a>00003 <span class="comment">// (C) Copyright Ion Gaztanaga 2005-2009. Distributed under the Boost</span>
<a name="l00004"></a>00004 <span class="comment">// Software License, Version 1.0. (See accompanying file</span>
<a name="l00005"></a>00005 <span class="comment">// LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)</span>
<a name="l00006"></a>00006 <span class="comment">//</span>
<a name="l00007"></a>00007 <span class="comment">// See http://www.boost.org/libs/container for documentation.</span>
<a name="l00008"></a>00008 <span class="comment">//</span>
<a name="l00009"></a>00009 
<a name="l00010"></a>00010 <span class="preprocessor">#ifndef BOOST_CONTAINERS_LIST_HPP_</span>
<a name="l00011"></a>00011 <span class="preprocessor"></span><span class="preprocessor">#define BOOST_CONTAINERS_LIST_HPP_</span>
<a name="l00012"></a>00012 <span class="preprocessor"></span>
<a name="l00013"></a>00013 <span class="preprocessor">#if (defined _MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200)</span>
<a name="l00014"></a>00014 <span class="preprocessor"></span><span class="preprocessor">#  pragma once</span>
<a name="l00015"></a>00015 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00016"></a>00016 <span class="preprocessor"></span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &quot;detail/config_begin.hpp&quot;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_WORKAROUND_HPP</span>
<a name="l00019"></a>00019 <span class="preprocessor"></span><span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_CONTAINER_FWD_HPP</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span><span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_VERSION_TYPE_HPP</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span><span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_MOVE_HPP</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span><span class="preprocessor">#include &lt;boost/pointer_to_other.hpp&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_UTILITIES_HPP</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span><span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_ALGORITHMS_HPP</span>
<a name="l00025"></a>00025 <span class="preprocessor"></span><span class="preprocessor">#include &lt;boost/type_traits/has_trivial_destructor.hpp&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_MPL_HPP</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span><span class="preprocessor">#include &lt;boost/intrusive/list.hpp&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_NODE_ALLOC_HOLDER_HPP</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span>
<a name="l00030"></a>00030 <span class="preprocessor">#if defined(BOOST_CONTAINERS_PERFECT_FORWARDING) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)</span>
<a name="l00031"></a>00031 <span class="preprocessor"></span><span class="preprocessor">#else</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span><span class="comment">//Preprocessor library to emulate perfect forwarding</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_PREPROCESSOR_HPP </span>
<a name="l00034"></a>00034 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;stdexcept&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;iterator&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;utility&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;memory&gt;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &lt;functional&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;stdexcept&gt;</span>
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="preprocessor">#ifdef BOOST_CONTAINER_DOXYGEN_INVOKED</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span><span class="keyword">namespace </span>boost {
<a name="l00046"></a>00046 <span class="keyword">namespace </span>container {
<a name="l00047"></a>00047 <span class="preprocessor">#else</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span><span class="keyword">namespace </span>boost {
<a name="l00049"></a>00049 <span class="keyword">namespace </span>container {
<a name="l00050"></a>00050 <span class="preprocessor">#endif</span>
<a name="l00051"></a>00051 <span class="preprocessor"></span>
<a name="l00053"></a>00053 <span class="keyword">namespace </span>containers_detail {
<a name="l00054"></a>00054 
<a name="l00055"></a>00055 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Vo<span class="keywordtype">id</span>Po<span class="keywordtype">int</span>er&gt;
<a name="l00056"></a>00056 <span class="keyword">struct </span>list_hook
<a name="l00057"></a>00057 {
<a name="l00058"></a>00058    <span class="keyword">typedef</span> <span class="keyword">typename</span> containers_detail::bi::make_list_base_hook
<a name="l00059"></a>00059       &lt;containers_detail::bi::void_pointer&lt;VoidPointer&gt;, containers_detail::bi::link_mode&lt;containers_detail::bi::normal_link&gt; &gt;::type type;
<a name="l00060"></a>00060 };
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> Vo<span class="keywordtype">id</span>Po<span class="keywordtype">int</span>er&gt;
<a name="l00063"></a>00063 <span class="keyword">struct </span>list_node
<a name="l00064"></a>00064    :  <span class="keyword">public</span> list_hook&lt;VoidPointer&gt;::type
<a name="l00065"></a>00065 {
<a name="l00066"></a>00066 
<a name="l00067"></a>00067 <span class="preprocessor">   #if defined(BOOST_CONTAINERS_PERFECT_FORWARDING) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)</span>
<a name="l00068"></a>00068 <span class="preprocessor"></span>
<a name="l00069"></a>00069    list_node()
<a name="l00070"></a>00070       : m_data()
<a name="l00071"></a>00071    {}
<a name="l00072"></a>00072 
<a name="l00073"></a>00073    <span class="keyword">template</span>&lt;<span class="keyword">class </span>...Args&gt;
<a name="l00074"></a>00074    list_node(Args &amp;&amp;...args)
<a name="l00075"></a>00075       : m_data(BOOST_CONTAINER_MOVE_NAMESPACE::forward&lt;Args&gt;(args)...)
<a name="l00076"></a>00076    {}
<a name="l00077"></a>00077 
<a name="l00078"></a>00078 <span class="preprocessor">   #else //#ifndef BOOST_CONTAINERS_PERFECT_FORWARDING</span>
<a name="l00079"></a>00079 <span class="preprocessor"></span>
<a name="l00080"></a>00080    list_node()
<a name="l00081"></a>00081       : m_data()
<a name="l00082"></a>00082    {}
<a name="l00083"></a>00083 
<a name="l00084"></a>00084 <span class="preprocessor">   #define BOOST_PP_LOCAL_MACRO(n)                                                           \</span>
<a name="l00085"></a>00085 <span class="preprocessor">   template&lt;BOOST_PP_ENUM_PARAMS(n, class P)&gt;                                                \</span>
<a name="l00086"></a>00086 <span class="preprocessor">   list_node(BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_LIST, _))                          \</span>
<a name="l00087"></a>00087 <span class="preprocessor">      : m_data(BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_FORWARD, _))                     \</span>
<a name="l00088"></a>00088 <span class="preprocessor">   {}                                                                                        \</span>
<a name="l00089"></a>00089 <span class="preprocessor"></span>
<a name="l00090"></a>00090 <span class="preprocessor">   #define BOOST_PP_LOCAL_LIMITS (1, BOOST_CONTAINERS_MAX_CONSTRUCTOR_PARAMETERS)</span>
<a name="l00091"></a>00091 <span class="preprocessor"></span><span class="preprocessor">   #include BOOST_PP_LOCAL_ITERATE()</span>
<a name="l00092"></a>00092 <span class="preprocessor"></span>
<a name="l00093"></a>00093 <span class="preprocessor">   #endif//#ifndef BOOST_CONTAINERS_PERFECT_FORWARDING</span>
<a name="l00094"></a>00094 <span class="preprocessor"></span>
<a name="l00095"></a>00095    T m_data;
<a name="l00096"></a>00096 };
<a name="l00097"></a>00097 
<a name="l00098"></a>00098 <span class="keyword">template</span>&lt;<span class="keyword">class</span> A&gt;
<a name="l00099"></a>00099 <span class="keyword">struct </span>intrusive_list_type
<a name="l00100"></a>00100 {
<a name="l00101"></a>00101    <span class="keyword">typedef</span> <span class="keyword">typename</span> A::value_type               value_type;
<a name="l00102"></a>00102    <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::pointer_to_other
<a name="l00103"></a>00103       &lt;<span class="keyword">typename</span> A::pointer, <span class="keywordtype">void</span>&gt;::type         void_pointer;
<a name="l00104"></a>00104    <span class="keyword">typedef</span> <span class="keyword">typename</span> containers_detail::list_node
<a name="l00105"></a>00105          &lt;value_type, void_pointer&gt;             node_type;
<a name="l00106"></a>00106    <span class="keyword">typedef</span> <span class="keyword">typename</span> containers_detail::bi::make_list
<a name="l00107"></a>00107       &lt; node_type
<a name="l00108"></a>00108       , containers_detail::bi::base_hook&lt;typename list_hook&lt;void_pointer&gt;::type&gt;
<a name="l00109"></a>00109       , containers_detail::bi::constant_time_size&lt;true&gt;
<a name="l00110"></a>00110       , containers_detail::bi::size_type&lt;typename A::size_type&gt;
<a name="l00111"></a>00111       &gt;::type                                   container_type;
<a name="l00112"></a>00112    <span class="keyword">typedef</span> container_type                       type ;
<a name="l00113"></a>00113 };
<a name="l00114"></a>00114 
<a name="l00115"></a>00115 }  <span class="comment">//namespace containers_detail {</span>
<a name="l00117"></a>00117 <span class="comment"></span>
<a name="l00128"></a>00128 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> A&gt;
<a name="l00129"></a><a class="code" href="classboost_1_1container_1_1list.html">00129</a> <span class="keyword">class </span><a class="code" href="classboost_1_1container_1_1list.html">list</a> 
<a name="l00130"></a>00130    : <span class="keyword">protected</span> containers_detail::node_alloc_holder
<a name="l00131"></a>00131       &lt;A, typename containers_detail::intrusive_list_type&lt;A&gt;::type&gt;
<a name="l00132"></a>00132 {
<a name="l00134"></a>00134    <span class="keyword">typedef</span> <span class="keyword">typename</span> containers_detail::
<a name="l00135"></a>00135       move_const_ref_type&lt;T&gt;::type                    insert_const_ref_type;
<a name="l00136"></a>00136    <span class="keyword">typedef</span> <span class="keyword">typename</span> 
<a name="l00137"></a>00137       containers_detail::intrusive_list_type&lt;A&gt;::type Icont;
<a name="l00138"></a>00138    <span class="keyword">typedef</span> <a class="code" href="classboost_1_1container_1_1list.html">list &lt;T, A&gt;</a>                                ThisType;
<a name="l00139"></a>00139    <span class="keyword">typedef</span> <a class="code" href="structboost_1_1container_1_1containers__detail_1_1node__alloc__holder.html">containers_detail::node_alloc_holder&lt;A, Icont&gt;</a>        AllocHolder;
<a name="l00140"></a>00140    <span class="keyword">typedef</span> <span class="keyword">typename</span> AllocHolder::NodePtr              NodePtr;
<a name="l00141"></a>00141    <span class="keyword">typedef</span> <span class="keyword">typename</span> AllocHolder::NodeAlloc            NodeAlloc;
<a name="l00142"></a>00142    <span class="keyword">typedef</span> <span class="keyword">typename</span> AllocHolder::ValAlloc             ValAlloc;
<a name="l00143"></a>00143    <span class="keyword">typedef</span> <span class="keyword">typename</span> AllocHolder::Node                 Node;
<a name="l00144"></a>00144    <span class="keyword">typedef</span> <a class="code" href="classboost_1_1container_1_1containers__detail_1_1allocator__destroyer.html">containers_detail::allocator_destroyer&lt;NodeAlloc&gt;</a>     <a class="code" href="classboost_1_1container_1_1containers__detail_1_1allocator__destroyer.html">Destroyer</a>;
<a name="l00145"></a>00145    <span class="keyword">typedef</span> <span class="keyword">typename</span> AllocHolder::allocator_v1         <a class="code" href="structboost_1_1container_1_1containers__detail_1_1integral__constant.html">allocator_v1</a>;
<a name="l00146"></a>00146    <span class="keyword">typedef</span> <span class="keyword">typename</span> AllocHolder::allocator_v2         <a class="code" href="structboost_1_1container_1_1containers__detail_1_1integral__constant.html">allocator_v2</a>;
<a name="l00147"></a>00147    <span class="keyword">typedef</span> <span class="keyword">typename</span> AllocHolder::alloc_version        <a class="code" href="structboost_1_1container_1_1containers__detail_1_1integral__constant.html">alloc_version</a>;
<a name="l00148"></a>00148 
<a name="l00149"></a>00149    <span class="keyword">class </span>equal_to_value
<a name="l00150"></a>00150    {
<a name="l00151"></a>00151       <span class="keyword">typedef</span> <span class="keyword">typename</span> AllocHolder::value_type <a class="code" href="classboost_1_1container_1_1list.html#abd3e4718d62e2263bbc713fd14973438">value_type</a>;
<a name="l00152"></a>00152       <span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1list.html#abd3e4718d62e2263bbc713fd14973438">value_type</a> &amp;t_;
<a name="l00153"></a>00153 
<a name="l00154"></a>00154       <span class="keyword">public</span>:
<a name="l00155"></a>00155       equal_to_value(<span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1list.html#abd3e4718d62e2263bbc713fd14973438">value_type</a> &amp;t)
<a name="l00156"></a>00156          :  t_(t)
<a name="l00157"></a>00157       {}
<a name="l00158"></a>00158 
<a name="l00159"></a>00159       <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1list.html#abd3e4718d62e2263bbc713fd14973438">value_type</a> &amp;t)<span class="keyword">const</span>
<a name="l00160"></a>00160 <span class="keyword">      </span>{  <span class="keywordflow">return</span> t_ == t;   }
<a name="l00161"></a>00161    };
<a name="l00162"></a>00162 
<a name="l00163"></a>00163    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Pred&gt;
<a name="l00164"></a>00164    <span class="keyword">struct </span>ValueCompareToNodeCompare
<a name="l00165"></a>00165       :  Pred
<a name="l00166"></a>00166    {
<a name="l00167"></a>00167       ValueCompareToNodeCompare(Pred pred)
<a name="l00168"></a>00168          :  Pred(pred)
<a name="l00169"></a>00169       {}
<a name="l00170"></a>00170 
<a name="l00171"></a>00171       <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> Node &amp;a, <span class="keyword">const</span> Node &amp;b)<span class="keyword"> const</span>
<a name="l00172"></a>00172 <span class="keyword">      </span>{  <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>Pred&amp;<span class="keyword">&gt;</span>(*this)(a.m_data, b.m_data);  }
<a name="l00173"></a>00173 
<a name="l00174"></a>00174       <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> Node &amp;a)<span class="keyword"> const</span>
<a name="l00175"></a>00175 <span class="keyword">      </span>{  <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>Pred&amp;<span class="keyword">&gt;</span>(*this)(a.m_data);  }
<a name="l00176"></a>00176    };
<a name="l00178"></a>00178 
<a name="l00179"></a>00179    <span class="keyword">public</span>:
<a name="l00181"></a><a class="code" href="classboost_1_1container_1_1list.html#abd3e4718d62e2263bbc713fd14973438">00181</a>    <span class="keyword">typedef</span> T                                       <a class="code" href="classboost_1_1container_1_1list.html#abd3e4718d62e2263bbc713fd14973438">value_type</a>;
<a name="l00183"></a><a class="code" href="classboost_1_1container_1_1list.html#abdd5d951f267b1f1e3cab66a0d5d0c4c">00183</a>    <span class="keyword">typedef</span> <span class="keyword">typename</span> A::pointer                     <a class="code" href="classboost_1_1container_1_1list.html#abdd5d951f267b1f1e3cab66a0d5d0c4c" title="Pointer to T.">pointer</a>;
<a name="l00185"></a><a class="code" href="classboost_1_1container_1_1list.html#aa3183db0bad3b0aa9577b1aa94bfb039">00185</a>    <span class="keyword">typedef</span> <span class="keyword">typename</span> A::const_pointer               <a class="code" href="classboost_1_1container_1_1list.html#aa3183db0bad3b0aa9577b1aa94bfb039" title="Const pointer to T.">const_pointer</a>;
<a name="l00187"></a><a class="code" href="classboost_1_1container_1_1list.html#a3a98e1e8a6e210478822211d6491b17a">00187</a>    <span class="keyword">typedef</span> <span class="keyword">typename</span> A::reference                   <a class="code" href="classboost_1_1container_1_1list.html#a3a98e1e8a6e210478822211d6491b17a" title="Reference to T.">reference</a>;
<a name="l00189"></a><a class="code" href="classboost_1_1container_1_1list.html#ab76acfead7fc6f992084e5cae878041b">00189</a>    <span class="keyword">typedef</span> <span class="keyword">typename</span> A::const_reference             <a class="code" href="classboost_1_1container_1_1list.html#ab76acfead7fc6f992084e5cae878041b" title="Const reference to T.">const_reference</a>;
<a name="l00191"></a><a class="code" href="classboost_1_1container_1_1list.html#a94afde4a93196be9b8baf555e598ef5f">00191</a>    <span class="keyword">typedef</span> <span class="keyword">typename</span> A::size_type                   <a class="code" href="classboost_1_1container_1_1list.html#a94afde4a93196be9b8baf555e598ef5f" title="An unsigned integral type.">size_type</a>;
<a name="l00193"></a><a class="code" href="classboost_1_1container_1_1list.html#a78200a149b2ad61cc4176289cf173093">00193</a>    <span class="keyword">typedef</span> <span class="keyword">typename</span> A::difference_type             <a class="code" href="classboost_1_1container_1_1list.html#a78200a149b2ad61cc4176289cf173093" title="A signed integral type.">difference_type</a>;
<a name="l00195"></a><a class="code" href="classboost_1_1container_1_1list.html#aaa5541c9b4a438e34cdfeaef581918b0">00195</a>    <span class="keyword">typedef</span> A                                       <a class="code" href="classboost_1_1container_1_1list.html#aaa5541c9b4a438e34cdfeaef581918b0" title="The allocator type.">allocator_type</a>;
<a name="l00197"></a><a class="code" href="classboost_1_1container_1_1list.html#afcf2f41221ba835b33ae355bb4f45f3a">00197</a>    <span class="keyword">typedef</span> NodeAlloc                               <a class="code" href="classboost_1_1container_1_1list.html#afcf2f41221ba835b33ae355bb4f45f3a" title="The stored allocator type.">stored_allocator_type</a>;
<a name="l00198"></a>00198 
<a name="l00200"></a>00200    <span class="keyword">private</span>:
<a name="l00201"></a>00201    BOOST_MOVE_MACRO_COPYABLE_AND_MOVABLE(<a class="code" href="classboost_1_1container_1_1list.html">list</a>)
<a name="l00202"></a>00202    typedef <a class="code" href="classboost_1_1container_1_1list.html#a78200a149b2ad61cc4176289cf173093" title="A signed integral type.">difference_type</a>                         list_difference_type;
<a name="l00203"></a>00203    typedef <a class="code" href="classboost_1_1container_1_1list.html#abdd5d951f267b1f1e3cab66a0d5d0c4c" title="Pointer to T.">pointer</a>                                 list_pointer;
<a name="l00204"></a>00204    typedef <a class="code" href="classboost_1_1container_1_1list.html#aa3183db0bad3b0aa9577b1aa94bfb039" title="Const pointer to T.">const_pointer</a>                           list_const_pointer;
<a name="l00205"></a>00205    typedef <a class="code" href="classboost_1_1container_1_1list.html#a3a98e1e8a6e210478822211d6491b17a" title="Reference to T.">reference</a>                               list_reference;
<a name="l00206"></a>00206    typedef <a class="code" href="classboost_1_1container_1_1list.html#ab76acfead7fc6f992084e5cae878041b" title="Const reference to T.">const_reference</a>                         list_const_reference;
<a name="l00208"></a>00208 
<a name="l00209"></a>00209    public:
<a name="l00211"></a>00211    class const_iterator
<a name="l00213"></a>00213       : public std::iterator&lt;std::bidirectional_iterator_tag, 
<a name="l00214"></a>00214                                  <a class="code" href="classboost_1_1container_1_1list.html#abd3e4718d62e2263bbc713fd14973438">value_type</a>,         list_difference_type, 
<a name="l00215"></a>00215                                  list_const_pointer, list_const_reference&gt;
<a name="l00216"></a>00216    {
<a name="l00217"></a>00217 
<a name="l00218"></a>00218       <span class="keyword">protected</span>:
<a name="l00219"></a>00219       <span class="keyword">typename</span> Icont::iterator m_it;
<a name="l00220"></a>00220       <span class="keyword">explicit</span> const_iterator(<span class="keyword">typename</span> Icont::iterator it)  : m_it(it){}
<a name="l00221"></a>00221       <span class="keywordtype">void</span> prot_incr() { ++m_it; }
<a name="l00222"></a>00222       <span class="keywordtype">void</span> prot_decr() { --m_it; }
<a name="l00223"></a>00223 
<a name="l00224"></a>00224       <span class="keyword">private</span>:
<a name="l00225"></a>00225       <span class="keyword">typename</span> Icont::iterator <span class="keyword">get</span>()
<a name="l00226"></a>00226       {  <span class="keywordflow">return</span> this-&gt;m_it;   }
<a name="l00227"></a>00227 
<a name="l00228"></a>00228       <span class="keyword">public</span>:
<a name="l00229"></a>00229       <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classboost_1_1container_1_1list.html">list</a>&lt;T, A&gt;;
<a name="l00230"></a>00230       <span class="keyword">typedef</span> list_difference_type        <a class="code" href="classboost_1_1container_1_1list.html#a78200a149b2ad61cc4176289cf173093" title="A signed integral type.">difference_type</a>;
<a name="l00231"></a>00231 
<a name="l00232"></a>00232       <span class="comment">//Constructors</span>
<a name="l00233"></a>00233       const_iterator()
<a name="l00234"></a>00234          :  m_it()
<a name="l00235"></a>00235       {}
<a name="l00236"></a>00236 
<a name="l00237"></a>00237       <span class="comment">//Pointer like operators</span>
<a name="l00238"></a>00238       <a class="code" href="classboost_1_1container_1_1list.html#ab76acfead7fc6f992084e5cae878041b" title="Const reference to T.">const_reference</a> operator*()<span class="keyword">  const </span>
<a name="l00239"></a>00239 <span class="keyword">      </span>{ <span class="keywordflow">return</span>  m_it-&gt;m_data;  }
<a name="l00240"></a>00240 
<a name="l00241"></a>00241       <a class="code" href="classboost_1_1container_1_1list.html#aa3183db0bad3b0aa9577b1aa94bfb039" title="Const pointer to T.">const_pointer</a>   operator-&gt;()<span class="keyword"> const </span>
<a name="l00242"></a>00242 <span class="keyword">      </span>{ <span class="keywordflow">return</span>  <a class="code" href="classboost_1_1container_1_1list.html#aa3183db0bad3b0aa9577b1aa94bfb039" title="Const pointer to T.">const_pointer</a>(&amp;m_it-&gt;m_data); }
<a name="l00243"></a>00243 
<a name="l00244"></a>00244       <span class="comment">//Increment / Decrement</span>
<a name="l00245"></a>00245       const_iterator&amp; operator++()       
<a name="l00246"></a>00246       { prot_incr();  <span class="keywordflow">return</span> *<span class="keyword">this</span>; }
<a name="l00247"></a>00247 
<a name="l00248"></a>00248       const_iterator operator++(<span class="keywordtype">int</span>)      
<a name="l00249"></a>00249       { <span class="keyword">typename</span> Icont::iterator tmp = m_it; ++*<span class="keyword">this</span>; <span class="keywordflow">return</span> const_iterator(tmp);  }
<a name="l00250"></a>00250 
<a name="l00251"></a>00251       const_iterator&amp; operator--()
<a name="l00252"></a>00252       {   prot_decr(); <span class="keywordflow">return</span> *<span class="keyword">this</span>;   }
<a name="l00253"></a>00253 
<a name="l00254"></a>00254       const_iterator operator--(<span class="keywordtype">int</span>)
<a name="l00255"></a>00255       {  <span class="keyword">typename</span> Icont::iterator tmp = m_it; --*<span class="keyword">this</span>; <span class="keywordflow">return</span> const_iterator(tmp); }
<a name="l00256"></a>00256 
<a name="l00257"></a>00257       <span class="comment">//Comparison operators</span>
<a name="l00258"></a>00258       <span class="keywordtype">bool</span> operator==   (<span class="keyword">const</span> const_iterator&amp; r)<span class="keyword">  const</span>
<a name="l00259"></a>00259 <span class="keyword">      </span>{  <span class="keywordflow">return</span> m_it == r.m_it;  }
<a name="l00260"></a>00260 
<a name="l00261"></a>00261       <span class="keywordtype">bool</span> operator!=   (<span class="keyword">const</span> const_iterator&amp; r)<span class="keyword">  const</span>
<a name="l00262"></a>00262 <span class="keyword">      </span>{  <span class="keywordflow">return</span> m_it != r.m_it;  }
<a name="l00263"></a>00263    }
<a name="l00265"></a>00265    ;
<a name="l00266"></a>00266 
<a name="l00268"></a><a class="code" href="classboost_1_1container_1_1list.html#a9957ceeff5fae9d869e955dac1cc630f">00268</a>    <span class="keyword">class </span>iterator
<a name="l00270"></a>00270       : <span class="keyword">public</span> const_iterator
<a name="l00271"></a>00271    {
<a name="l00272"></a>00272 
<a name="l00273"></a>00273       <span class="keyword">private</span>:
<a name="l00274"></a>00274       <span class="keyword">explicit</span> iterator(<span class="keyword">typename</span> Icont::iterator it)
<a name="l00275"></a>00275          :  const_iterator(it)
<a name="l00276"></a>00276       {}
<a name="l00277"></a>00277    
<a name="l00278"></a>00278       <span class="keyword">typename</span> Icont::iterator <span class="keyword">get</span>()
<a name="l00279"></a>00279       {  <span class="keywordflow">return</span> this-&gt;m_it;   }
<a name="l00280"></a>00280 
<a name="l00281"></a>00281       <span class="keyword">public</span>:
<a name="l00282"></a>00282       <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classboost_1_1container_1_1list.html">list</a>&lt;T, A&gt;;
<a name="l00283"></a>00283       <span class="keyword">typedef</span> list_pointer       <a class="code" href="classboost_1_1container_1_1list.html#abdd5d951f267b1f1e3cab66a0d5d0c4c" title="Pointer to T.">pointer</a>;
<a name="l00284"></a>00284       <span class="keyword">typedef</span> list_reference     <a class="code" href="classboost_1_1container_1_1list.html#a3a98e1e8a6e210478822211d6491b17a" title="Reference to T.">reference</a>;
<a name="l00285"></a>00285 
<a name="l00286"></a>00286       <span class="comment">//Constructors</span>
<a name="l00287"></a>00287       iterator(){}
<a name="l00288"></a>00288 
<a name="l00289"></a>00289       <span class="comment">//Pointer like operators</span>
<a name="l00290"></a>00290       <a class="code" href="classboost_1_1container_1_1list.html#a3a98e1e8a6e210478822211d6491b17a" title="Reference to T.">reference</a> operator*()<span class="keyword">  const </span>{  <span class="keywordflow">return</span>  this-&gt;m_it-&gt;m_data;  }
<a name="l00291"></a>00291       <a class="code" href="classboost_1_1container_1_1list.html#abdd5d951f267b1f1e3cab66a0d5d0c4c" title="Pointer to T.">pointer</a>   operator-&gt;()<span class="keyword"> const </span>{  <span class="keywordflow">return</span>  <a class="code" href="classboost_1_1container_1_1list.html#abdd5d951f267b1f1e3cab66a0d5d0c4c" title="Pointer to T.">pointer</a>(&amp;this-&gt;m_it-&gt;m_data);  }
<a name="l00292"></a>00292 
<a name="l00293"></a>00293       <span class="comment">//Increment / Decrement</span>
<a name="l00294"></a>00294       iterator&amp; operator++()  
<a name="l00295"></a>00295          { this-&gt;prot_incr(); <span class="keywordflow">return</span> *<span class="keyword">this</span>;  }
<a name="l00296"></a>00296 
<a name="l00297"></a>00297       iterator operator++(<span class="keywordtype">int</span>)
<a name="l00298"></a>00298          { <span class="keyword">typename</span> Icont::iterator tmp = this-&gt;m_it; ++*<span class="keyword">this</span>; <span class="keywordflow">return</span> iterator(tmp); }
<a name="l00299"></a>00299       
<a name="l00300"></a>00300       iterator&amp; operator--()
<a name="l00301"></a>00301          {  this-&gt;prot_decr(); <span class="keywordflow">return</span> *<span class="keyword">this</span>;  }
<a name="l00302"></a>00302 
<a name="l00303"></a>00303       iterator operator--(<span class="keywordtype">int</span>)
<a name="l00304"></a>00304          {  iterator tmp = *<span class="keyword">this</span>; --*<span class="keyword">this</span>; <span class="keywordflow">return</span> tmp; }
<a name="l00305"></a>00305    };
<a name="l00307"></a>00307 
<a name="l00309"></a>00309    <span class="keyword">typedef</span> std::reverse_iterator&lt;iterator&gt;        reverse_iterator;
<a name="l00311"></a>00311    <span class="keyword">typedef</span> std::reverse_iterator&lt;const_iterator&gt;  const_reverse_iterator;
<a name="l00312"></a>00312 
<a name="l00318"></a><a class="code" href="classboost_1_1container_1_1list.html#ac7d834217397d806428366720006155f">00318</a>    <span class="keyword">explicit</span> <a class="code" href="classboost_1_1container_1_1list.html">list</a>(<span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1list.html#aaa5541c9b4a438e34cdfeaef581918b0" title="The allocator type.">allocator_type</a> &amp;a = A()) 
<a name="l00319"></a>00319       : AllocHolder(a)
<a name="l00320"></a>00320    {}
<a name="l00321"></a>00321 
<a name="l00329"></a><a class="code" href="classboost_1_1container_1_1list.html#ad34d97676be7dfe57ac9c1acd448a227">00329</a>    <a class="code" href="classboost_1_1container_1_1list.html">list</a>(<a class="code" href="classboost_1_1container_1_1list.html#a94afde4a93196be9b8baf555e598ef5f" title="An unsigned integral type.">size_type</a> n)
<a name="l00330"></a>00330       : AllocHolder(A())
<a name="l00331"></a>00331    {  this-&gt;resize(n);  }
<a name="l00332"></a>00332 
<a name="l00340"></a><a class="code" href="classboost_1_1container_1_1list.html#a7617783eee082cae1c0e8eac504d3573">00340</a>    <a class="code" href="classboost_1_1container_1_1list.html">list</a>(<a class="code" href="classboost_1_1container_1_1list.html#a94afde4a93196be9b8baf555e598ef5f" title="An unsigned integral type.">size_type</a> n, <span class="keyword">const</span> T&amp; value, <span class="keyword">const</span> A&amp; a = A())
<a name="l00341"></a>00341       : AllocHolder(a)
<a name="l00342"></a>00342    {  this-&gt;insert(this-&gt;cbegin(), n, value);  }
<a name="l00343"></a>00343 
<a name="l00351"></a><a class="code" href="classboost_1_1container_1_1list.html#a49837ec4ea0f8c4cb9dcd30a0a1e3db5">00351</a>    <a class="code" href="classboost_1_1container_1_1list.html">list</a>(<span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1list.html">list</a>&amp; x) 
<a name="l00352"></a>00352       : AllocHolder(x)
<a name="l00353"></a>00353    {  this-&gt;insert(this-&gt;cbegin(), x.<a class="code" href="classboost_1_1container_1_1list.html#afe4b88bbec1883ae0c9ca1a16e327a54">begin</a>(), x.<a class="code" href="classboost_1_1container_1_1list.html#a868812cf975a6005e8dd8186b0b1e6a9">end</a>());   }
<a name="l00354"></a>00354 
<a name="l00360"></a><a class="code" href="classboost_1_1container_1_1list.html#af95c12d83e73af8d7a7fe020b1776027">00360</a>    <a class="code" href="classboost_1_1container_1_1list.html">list</a>(BOOST_MOVE_MACRO_RV_REF(<a class="code" href="classboost_1_1container_1_1list.html">list</a>) x)
<a name="l00361"></a>00361       : AllocHolder(BOOST_CONTAINER_MOVE_NAMESPACE::move(static_cast&lt;AllocHolder&amp;&gt;(x)))
<a name="l00362"></a>00362    {}
<a name="l00363"></a>00363 
<a name="l00371"></a>00371    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InpIt&gt;
<a name="l00372"></a><a class="code" href="classboost_1_1container_1_1list.html#a7b60d4e8e9e341bc43b7ec0f8a181843">00372</a>    <a class="code" href="classboost_1_1container_1_1list.html">list</a>(InpIt first, InpIt last, <span class="keyword">const</span> A &amp;a = A())
<a name="l00373"></a>00373       : AllocHolder(a)
<a name="l00374"></a>00374    {  this-&gt;insert(this-&gt;cbegin(), first, last);  }
<a name="l00375"></a>00375 
<a name="l00382"></a><a class="code" href="classboost_1_1container_1_1list.html#af3f04b68adb4b26e1386b2ff09f79c9b">00382</a>    ~<a class="code" href="classboost_1_1container_1_1list.html">list</a>()
<a name="l00383"></a>00383    {} <span class="comment">//AllocHolder clears the list</span>
<a name="l00384"></a>00384 
<a name="l00390"></a><a class="code" href="classboost_1_1container_1_1list.html#a5168a5f5b83a79a1afd9bdb4b952df38">00390</a>    <a class="code" href="classboost_1_1container_1_1list.html#aaa5541c9b4a438e34cdfeaef581918b0" title="The allocator type.">allocator_type</a> get_allocator()<span class="keyword"> const</span>
<a name="l00391"></a>00391 <span class="keyword">   </span>{  <span class="keywordflow">return</span> <a class="code" href="classboost_1_1container_1_1list.html#aaa5541c9b4a438e34cdfeaef581918b0" title="The allocator type.">allocator_type</a>(this-&gt;node_alloc()); }
<a name="l00392"></a>00392 
<a name="l00393"></a>00393    <span class="keyword">const</span> stored_allocator_type &amp;get_stored_allocator()<span class="keyword"> const </span>
<a name="l00394"></a>00394 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;node_alloc(); }
<a name="l00395"></a>00395 
<a name="l00396"></a>00396    stored_allocator_type &amp;get_stored_allocator()
<a name="l00397"></a>00397    {  <span class="keywordflow">return</span> this-&gt;node_alloc(); }
<a name="l00398"></a>00398 
<a name="l00404"></a><a class="code" href="classboost_1_1container_1_1list.html#a893e5cafdd7983b00300dda5a5b4a77b">00404</a>    <span class="keywordtype">void</span> clear()
<a name="l00405"></a>00405    {  AllocHolder::clear(<a class="code" href="structboost_1_1container_1_1containers__detail_1_1integral__constant.html">alloc_version</a>());  }
<a name="l00406"></a>00406 
<a name="l00412"></a><a class="code" href="classboost_1_1container_1_1list.html#afe4b88bbec1883ae0c9ca1a16e327a54">00412</a>    iterator begin()
<a name="l00413"></a>00413    { <span class="keywordflow">return</span> iterator(this-&gt;icont().<a class="code" href="classboost_1_1container_1_1list.html#afe4b88bbec1883ae0c9ca1a16e327a54">begin</a>()); }
<a name="l00414"></a>00414 
<a name="l00420"></a><a class="code" href="classboost_1_1container_1_1list.html#ae6cb1d7e7941a8df206e766c4cf8d4c6">00420</a>    const_iterator begin()<span class="keyword"> const</span>
<a name="l00421"></a>00421 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;cbegin();   }
<a name="l00422"></a>00422 
<a name="l00428"></a><a class="code" href="classboost_1_1container_1_1list.html#a868812cf975a6005e8dd8186b0b1e6a9">00428</a>    iterator end()
<a name="l00429"></a>00429    {  <span class="keywordflow">return</span> iterator(this-&gt;icont().<a class="code" href="classboost_1_1container_1_1list.html#a868812cf975a6005e8dd8186b0b1e6a9">end</a>());  }
<a name="l00430"></a>00430 
<a name="l00436"></a><a class="code" href="classboost_1_1container_1_1list.html#ae6ca3205d2b3087633009b9ea81c4d94">00436</a>    const_iterator end()<span class="keyword"> const</span>
<a name="l00437"></a>00437 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;cend();  }
<a name="l00438"></a>00438 
<a name="l00445"></a><a class="code" href="classboost_1_1container_1_1list.html#a053224607e25716b19369600b06483a4">00445</a>    reverse_iterator rbegin()
<a name="l00446"></a>00446    {  <span class="keywordflow">return</span> reverse_iterator(end());  }
<a name="l00447"></a>00447 
<a name="l00454"></a><a class="code" href="classboost_1_1container_1_1list.html#a1437cdcaa99a5f234982426e686828ab">00454</a>    <a class="code" href="classboost_1_1container_1_1list.html#a9957ceeff5fae9d869e955dac1cc630f" title="Iterator used to iterate through a list.">const_reverse_iterator</a> rbegin()<span class="keyword"> const</span>
<a name="l00455"></a>00455 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;crbegin();  }
<a name="l00456"></a>00456 
<a name="l00463"></a><a class="code" href="classboost_1_1container_1_1list.html#aaba278584f03f2e646c75cf2f7faedad">00463</a>    reverse_iterator rend()
<a name="l00464"></a>00464    {  <span class="keywordflow">return</span> reverse_iterator(begin());   }
<a name="l00465"></a>00465 
<a name="l00472"></a><a class="code" href="classboost_1_1container_1_1list.html#a3f70e18015b162b319fc4c5e5219b96a">00472</a>    <a class="code" href="classboost_1_1container_1_1list.html#a9957ceeff5fae9d869e955dac1cc630f" title="Iterator used to iterate through a list.">const_reverse_iterator</a> rend()<span class="keyword"> const</span>
<a name="l00473"></a>00473 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;crend();   }
<a name="l00474"></a>00474 
<a name="l00480"></a><a class="code" href="classboost_1_1container_1_1list.html#a79dfdf80a00a2d00527d324dc69d1f0e">00480</a>    const_iterator cbegin()<span class="keyword"> const</span>
<a name="l00481"></a>00481 <span class="keyword">   </span>{  <span class="keywordflow">return</span> const_iterator(this-&gt;non_const_icont().begin());   }
<a name="l00482"></a>00482 
<a name="l00488"></a><a class="code" href="classboost_1_1container_1_1list.html#a6cd12198148bd686752e555a5ae98a50">00488</a>    const_iterator cend()<span class="keyword"> const</span>
<a name="l00489"></a>00489 <span class="keyword">   </span>{  <span class="keywordflow">return</span> const_iterator(this-&gt;non_const_icont().end());  }
<a name="l00490"></a>00490 
<a name="l00497"></a><a class="code" href="classboost_1_1container_1_1list.html#a0bcd77ad54a6422f549931a7dbf90741">00497</a>    <a class="code" href="classboost_1_1container_1_1list.html#a9957ceeff5fae9d869e955dac1cc630f" title="Iterator used to iterate through a list.">const_reverse_iterator</a> crbegin()<span class="keyword"> const</span>
<a name="l00498"></a>00498 <span class="keyword">   </span>{  <span class="keywordflow">return</span> <a class="code" href="classboost_1_1container_1_1list.html#a9957ceeff5fae9d869e955dac1cc630f" title="Iterator used to iterate through a list.">const_reverse_iterator</a>(this-&gt;cend());  }
<a name="l00499"></a>00499 
<a name="l00506"></a><a class="code" href="classboost_1_1container_1_1list.html#a30ab1f5826e267c036194ee67d79fd9e">00506</a>    <a class="code" href="classboost_1_1container_1_1list.html#a9957ceeff5fae9d869e955dac1cc630f" title="Iterator used to iterate through a list.">const_reverse_iterator</a> crend()<span class="keyword"> const</span>
<a name="l00507"></a>00507 <span class="keyword">   </span>{  <span class="keywordflow">return</span> <a class="code" href="classboost_1_1container_1_1list.html#a9957ceeff5fae9d869e955dac1cc630f" title="Iterator used to iterate through a list.">const_reverse_iterator</a>(this-&gt;cbegin());   }
<a name="l00508"></a>00508 
<a name="l00514"></a><a class="code" href="classboost_1_1container_1_1list.html#a741bc132ff191ee29c632e77f3613827">00514</a>    <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>
<a name="l00515"></a>00515 <span class="keyword">   </span>{  <span class="keywordflow">return</span> !this-&gt;size();  }
<a name="l00516"></a>00516 
<a name="l00522"></a><a class="code" href="classboost_1_1container_1_1list.html#a86df54568f2940c5f5964bf15213891d">00522</a>    <a class="code" href="classboost_1_1container_1_1list.html#a94afde4a93196be9b8baf555e598ef5f" title="An unsigned integral type.">size_type</a> size()<span class="keyword"> const </span>
<a name="l00523"></a>00523 <span class="keyword">   </span>{   <span class="keywordflow">return</span> this-&gt;icont().size();   }
<a name="l00524"></a>00524 
<a name="l00530"></a><a class="code" href="classboost_1_1container_1_1list.html#a343925665e50b631f86c1f61411481c3">00530</a>    <a class="code" href="classboost_1_1container_1_1list.html#a94afde4a93196be9b8baf555e598ef5f" title="An unsigned integral type.">size_type</a> max_size()<span class="keyword"> const </span>
<a name="l00531"></a>00531 <span class="keyword">   </span>{  <span class="keywordflow">return</span> AllocHolder::max_size();  }
<a name="l00532"></a>00532 
<a name="l00539"></a><a class="code" href="classboost_1_1container_1_1list.html#a612c1d8907af60085508545ef8d6c748">00539</a>    <span class="keywordtype">void</span> push_front(insert_const_ref_type x)   
<a name="l00540"></a>00540    {  this-&gt;insert(this-&gt;cbegin(), x);  }
<a name="l00541"></a>00541 
<a name="l00542"></a>00542 <span class="preprocessor">   #if defined(BOOST_NO_RVALUE_REFERENCES) &amp;&amp; !defined(BOOST_MOVE_DOXYGEN_INVOKED)</span>
<a name="l00543"></a>00543 <span class="preprocessor"></span>   <span class="keywordtype">void</span> push_front(T &amp;x) { push_front(const_cast&lt;const T &amp;&gt;(x)); }
<a name="l00544"></a>00544 
<a name="l00545"></a>00545    <span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt;
<a name="l00546"></a>00546    <span class="keywordtype">void</span> push_front(<span class="keyword">const</span> U &amp;u, <span class="keyword">typename</span> containers_detail::enable_if_c&lt;containers_detail::is_same&lt;T, U&gt;::value &amp;&amp; !::BOOST_CONTAINER_MOVE_NAMESPACE::is_movable&lt;U&gt;::value &gt;::type* =0)
<a name="l00547"></a>00547    {  this-&gt;insert(this-&gt;cbegin(), u);  }
<a name="l00548"></a>00548 <span class="preprocessor">   #endif</span>
<a name="l00549"></a>00549 <span class="preprocessor"></span>
<a name="l00556"></a><a class="code" href="classboost_1_1container_1_1list.html#a103964f1755db3345e3cbf62221c5a27">00556</a>    <span class="keywordtype">void</span> push_front(BOOST_MOVE_MACRO_RV_REF(T) x)
<a name="l00557"></a>00557    {  this-&gt;insert(this-&gt;cbegin(), BOOST_CONTAINER_MOVE_NAMESPACE::move(x));  }
<a name="l00558"></a>00558 
<a name="l00564"></a><a class="code" href="classboost_1_1container_1_1list.html#a5b7e74ae4865c5873740ae1717930b1d">00564</a>    <span class="keywordtype">void</span> push_back (insert_const_ref_type x)   
<a name="l00565"></a>00565    {  this-&gt;insert(this-&gt;cend(), x);    }
<a name="l00566"></a>00566 
<a name="l00567"></a>00567 <span class="preprocessor">   #if defined(BOOST_NO_RVALUE_REFERENCES) &amp;&amp; !defined(BOOST_MOVE_DOXYGEN_INVOKED)</span>
<a name="l00568"></a>00568 <span class="preprocessor"></span>   <span class="keywordtype">void</span> push_back(T &amp;x) { push_back(const_cast&lt;const T &amp;&gt;(x)); }
<a name="l00569"></a>00569 
<a name="l00570"></a>00570    <span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt;
<a name="l00571"></a>00571    <span class="keywordtype">void</span> push_back(<span class="keyword">const</span> U &amp;u, <span class="keyword">typename</span> containers_detail::enable_if_c&lt;containers_detail::is_same&lt;T, U&gt;::value &amp;&amp; !::BOOST_CONTAINER_MOVE_NAMESPACE::is_movable&lt;U&gt;::value &gt;::type* =0)
<a name="l00572"></a>00572    {  this-&gt;insert(this-&gt;cend(), u);    }
<a name="l00573"></a>00573 
<a name="l00574"></a>00574 <span class="preprocessor">   #endif</span>
<a name="l00575"></a>00575 <span class="preprocessor"></span>
<a name="l00581"></a><a class="code" href="classboost_1_1container_1_1list.html#acfd420e09ec419871d1cd774d402cf8f">00581</a>    <span class="keywordtype">void</span> push_back (BOOST_MOVE_MACRO_RV_REF(T) x)
<a name="l00582"></a>00582    {  this-&gt;insert(this-&gt;cend(), BOOST_CONTAINER_MOVE_NAMESPACE::move(x));    }
<a name="l00583"></a>00583 
<a name="l00589"></a><a class="code" href="classboost_1_1container_1_1list.html#a411d4fdee9010d3ea589a1d2a70d4f8a">00589</a>    <span class="keywordtype">void</span> pop_front()              
<a name="l00590"></a>00590    {  this-&gt;erase(this-&gt;cbegin());      }
<a name="l00591"></a>00591 
<a name="l00597"></a><a class="code" href="classboost_1_1container_1_1list.html#a8ffde13e2b10c3e4bc43987782752b40">00597</a>    <span class="keywordtype">void</span> pop_back()               
<a name="l00598"></a>00598    {  const_iterator tmp = this-&gt;cend(); this-&gt;erase(--tmp);  }
<a name="l00599"></a>00599 
<a name="l00608"></a><a class="code" href="classboost_1_1container_1_1list.html#a255d1819a647347d86af5951ee018a39">00608</a>    <a class="code" href="classboost_1_1container_1_1list.html#a3a98e1e8a6e210478822211d6491b17a" title="Reference to T.">reference</a> front()             
<a name="l00609"></a>00609    { <span class="keywordflow">return</span> *this-&gt;begin(); }
<a name="l00610"></a>00610 
<a name="l00619"></a><a class="code" href="classboost_1_1container_1_1list.html#a93f4e7b2b8bd374893a05106b90f47c7">00619</a>    <a class="code" href="classboost_1_1container_1_1list.html#ab76acfead7fc6f992084e5cae878041b" title="Const reference to T.">const_reference</a> front()<span class="keyword"> const </span>
<a name="l00620"></a>00620 <span class="keyword">   </span>{ <span class="keywordflow">return</span> *this-&gt;begin(); }
<a name="l00621"></a>00621 
<a name="l00630"></a><a class="code" href="classboost_1_1container_1_1list.html#acc50975f4dcd84cdddc540af70743ecb">00630</a>    <a class="code" href="classboost_1_1container_1_1list.html#a3a98e1e8a6e210478822211d6491b17a" title="Reference to T.">reference</a> back()              
<a name="l00631"></a>00631    { <span class="keywordflow">return</span> *(--this-&gt;end()); }
<a name="l00632"></a>00632 
<a name="l00641"></a><a class="code" href="classboost_1_1container_1_1list.html#a5e6f92c9138550347f30e516d8efe2f8">00641</a>    <a class="code" href="classboost_1_1container_1_1list.html#ab76acfead7fc6f992084e5cae878041b" title="Const reference to T.">const_reference</a> back()<span class="keyword">  const </span>
<a name="l00642"></a>00642 <span class="keyword">   </span>{ <span class="keywordflow">return</span> *(--this-&gt;end()); }
<a name="l00643"></a>00643 
<a name="l00650"></a><a class="code" href="classboost_1_1container_1_1list.html#a42ab1b3829e080ca746e8cff2f27810e">00650</a>    <span class="keywordtype">void</span> resize(<a class="code" href="classboost_1_1container_1_1list.html#a94afde4a93196be9b8baf555e598ef5f" title="An unsigned integral type.">size_type</a> new_size, <span class="keyword">const</span> T&amp; x)
<a name="l00651"></a>00651    {
<a name="l00652"></a>00652       const_iterator iend = this-&gt;cend();
<a name="l00653"></a>00653       <a class="code" href="classboost_1_1container_1_1list.html#a94afde4a93196be9b8baf555e598ef5f" title="An unsigned integral type.">size_type</a> len = this-&gt;size();
<a name="l00654"></a>00654       
<a name="l00655"></a>00655       <span class="keywordflow">if</span>(len &gt; new_size){
<a name="l00656"></a>00656          <a class="code" href="classboost_1_1container_1_1list.html#a94afde4a93196be9b8baf555e598ef5f" title="An unsigned integral type.">size_type</a> to_erase = len - new_size;
<a name="l00657"></a>00657          <span class="keywordflow">while</span>(to_erase--){
<a name="l00658"></a>00658             --iend;
<a name="l00659"></a>00659          }
<a name="l00660"></a>00660          this-&gt;erase(iend, this-&gt;cend());
<a name="l00661"></a>00661       }
<a name="l00662"></a>00662       <span class="keywordflow">else</span>{
<a name="l00663"></a>00663          this-&gt;priv_create_and_insert_nodes(iend, new_size - len, x);
<a name="l00664"></a>00664       }
<a name="l00665"></a>00665    }
<a name="l00666"></a>00666 
<a name="l00673"></a><a class="code" href="classboost_1_1container_1_1list.html#accbe12ec2f1dd1271dd9f755fa1fd957">00673</a>    <span class="keywordtype">void</span> resize(<a class="code" href="classboost_1_1container_1_1list.html#a94afde4a93196be9b8baf555e598ef5f" title="An unsigned integral type.">size_type</a> new_size)
<a name="l00674"></a>00674    {
<a name="l00675"></a>00675       const_iterator iend = this-&gt;end();
<a name="l00676"></a>00676       <a class="code" href="classboost_1_1container_1_1list.html#a94afde4a93196be9b8baf555e598ef5f" title="An unsigned integral type.">size_type</a> len = this-&gt;size();
<a name="l00677"></a>00677       
<a name="l00678"></a>00678       <span class="keywordflow">if</span>(len &gt; new_size){
<a name="l00679"></a>00679          <a class="code" href="classboost_1_1container_1_1list.html#a94afde4a93196be9b8baf555e598ef5f" title="An unsigned integral type.">size_type</a> to_erase = len - new_size;
<a name="l00680"></a>00680          const_iterator ifirst;
<a name="l00681"></a>00681          <span class="keywordflow">if</span>(to_erase &lt; len/2u){
<a name="l00682"></a>00682             ifirst = iend;
<a name="l00683"></a>00683             <span class="keywordflow">while</span>(to_erase--){
<a name="l00684"></a>00684                --ifirst;
<a name="l00685"></a>00685             }
<a name="l00686"></a>00686          }
<a name="l00687"></a>00687          <span class="keywordflow">else</span>{
<a name="l00688"></a>00688             ifirst = this-&gt;begin();
<a name="l00689"></a>00689             <a class="code" href="classboost_1_1container_1_1list.html#a94afde4a93196be9b8baf555e598ef5f" title="An unsigned integral type.">size_type</a> to_skip = len - to_erase;
<a name="l00690"></a>00690             <span class="keywordflow">while</span>(to_skip--){
<a name="l00691"></a>00691                ++ifirst;
<a name="l00692"></a>00692             }
<a name="l00693"></a>00693          }
<a name="l00694"></a>00694          this-&gt;erase(ifirst, iend);
<a name="l00695"></a>00695       }
<a name="l00696"></a>00696       <span class="keywordflow">else</span>{
<a name="l00697"></a>00697          this-&gt;priv_create_and_insert_nodes(this-&gt;cend(), new_size - len);
<a name="l00698"></a>00698       }
<a name="l00699"></a>00699    }
<a name="l00700"></a>00700 
<a name="l00708"></a><a class="code" href="classboost_1_1container_1_1list.html#ad90b0232eed7b1d0f38dc197f1ab43e4">00708</a>    <span class="keywordtype">void</span> swap(ThisType&amp; x)
<a name="l00709"></a>00709    {  AllocHolder::swap(x);   }
<a name="l00710"></a>00710 
<a name="l00719"></a><a class="code" href="classboost_1_1container_1_1list.html#a6bad680b8815dd8afaba58781efe0d91">00719</a>    ThisType&amp; operator=(BOOST_MOVE_MACRO_COPY_ASSIGN_REF(ThisType) x)
<a name="l00720"></a>00720    {
<a name="l00721"></a>00721       <span class="keywordflow">if</span> (<span class="keyword">this</span> != &amp;x) {
<a name="l00722"></a>00722          this-&gt;assign(x.begin(), x.end());
<a name="l00723"></a>00723       }
<a name="l00724"></a>00724       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00725"></a>00725    }
<a name="l00726"></a>00726 
<a name="l00735"></a><a class="code" href="classboost_1_1container_1_1list.html#afc9a227dcf36652da6853af761961306">00735</a>    ThisType&amp; operator=(BOOST_MOVE_MACRO_RV_REF(ThisType) mx)
<a name="l00736"></a>00736    {
<a name="l00737"></a>00737       this-&gt;clear();
<a name="l00738"></a>00738       this-&gt;swap(mx);
<a name="l00739"></a>00739       <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00740"></a>00740    }
<a name="l00741"></a>00741 
<a name="l00749"></a><a class="code" href="classboost_1_1container_1_1list.html#a641f74fc14d73b16cf01ef29c22057b0">00749</a>    <span class="keywordtype">void</span> insert(const_iterator p, <a class="code" href="classboost_1_1container_1_1list.html#a94afde4a93196be9b8baf555e598ef5f" title="An unsigned integral type.">size_type</a> n, <span class="keyword">const</span> T&amp; x)
<a name="l00750"></a>00750    { this-&gt;priv_create_and_insert_nodes(p, n, x); }
<a name="l00751"></a>00751 
<a name="l00760"></a>00760    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InpIt&gt;
<a name="l00761"></a><a class="code" href="classboost_1_1container_1_1list.html#ae73ec2bc702d83b55656d4b4d68033fb">00761</a>    <span class="keywordtype">void</span> insert(const_iterator p, InpIt first, InpIt last) 
<a name="l00762"></a>00762    {
<a name="l00763"></a>00763       <span class="keyword">const</span> <span class="keywordtype">bool</span> aux_boolean = <a class="code" href="classboost_1_1container_1_1containers__detail_1_1is__convertible.html">containers_detail::is_convertible&lt;InpIt, std::size_t&gt;::value</a>;
<a name="l00764"></a>00764       <span class="keyword">typedef</span> <a class="code" href="structboost_1_1container_1_1containers__detail_1_1bool__.html">containers_detail::bool_&lt;aux_boolean&gt;</a> Result;
<a name="l00765"></a>00765       this-&gt;priv_insert_dispatch(p, first, last, Result());
<a name="l00766"></a>00766    }
<a name="l00767"></a>00767 
<a name="l00775"></a><a class="code" href="classboost_1_1container_1_1list.html#a6f3de91d4de60c032f367c7dd88de8e5">00775</a>    iterator insert(const_iterator position, insert_const_ref_type x) 
<a name="l00776"></a>00776    {  <span class="keywordflow">return</span> this-&gt;priv_insert(position, x); }
<a name="l00777"></a>00777 
<a name="l00778"></a>00778 <span class="preprocessor">   #if defined(BOOST_NO_RVALUE_REFERENCES) &amp;&amp; !defined(BOOST_MOVE_DOXYGEN_INVOKED)</span>
<a name="l00779"></a>00779 <span class="preprocessor"></span>   iterator insert(const_iterator position, T &amp;x) { <span class="keywordflow">return</span> this-&gt;insert(position, const_cast&lt;const T &amp;&gt;(x)); }
<a name="l00780"></a>00780 
<a name="l00781"></a>00781    <span class="keyword">template</span>&lt;<span class="keyword">class</span> U&gt;
<a name="l00782"></a>00782    iterator insert(const_iterator position, <span class="keyword">const</span> U &amp;u, <span class="keyword">typename</span> containers_detail::enable_if_c&lt;containers_detail::is_same&lt;T, U&gt;::value &amp;&amp; !::BOOST_CONTAINER_MOVE_NAMESPACE::is_movable&lt;U&gt;::value &gt;::type* =0)
<a name="l00783"></a>00783    {  <span class="keywordflow">return</span> this-&gt;priv_insert(position, u); }
<a name="l00784"></a>00784 <span class="preprocessor">   #endif</span>
<a name="l00785"></a>00785 <span class="preprocessor"></span>
<a name="l00793"></a><a class="code" href="classboost_1_1container_1_1list.html#a9e5e253b2baf7c96ee272a3df292b13f">00793</a>    iterator insert(const_iterator p, BOOST_MOVE_MACRO_RV_REF(T) x) 
<a name="l00794"></a>00794    {
<a name="l00795"></a>00795       NodePtr tmp = AllocHolder::create_node(BOOST_CONTAINER_MOVE_NAMESPACE::move(x));
<a name="l00796"></a>00796       <span class="keywordflow">return</span> iterator(this-&gt;icont().insert(p.get(), *tmp));
<a name="l00797"></a>00797    }
<a name="l00798"></a>00798 
<a name="l00799"></a>00799 <span class="preprocessor">   #if defined(BOOST_CONTAINERS_PERFECT_FORWARDING) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)</span>
<a name="l00800"></a>00800 <span class="preprocessor"></span>
<a name="l00808"></a>00808    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;
<a name="l00809"></a>00809    <span class="keywordtype">void</span> emplace_back(Args&amp;&amp;... args)
<a name="l00810"></a>00810    {
<a name="l00811"></a>00811       this-&gt;emplace(this-&gt;cend(), BOOST_CONTAINER_MOVE_NAMESPACE::forward&lt;Args&gt;(args)...);
<a name="l00812"></a>00812    }
<a name="l00813"></a>00813 
<a name="l00821"></a>00821    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;
<a name="l00822"></a>00822    <span class="keywordtype">void</span> emplace_front(Args&amp;&amp;... args)
<a name="l00823"></a>00823    {
<a name="l00824"></a>00824       this-&gt;emplace(this-&gt;cbegin(), BOOST_CONTAINER_MOVE_NAMESPACE::forward&lt;Args&gt;(args)...);
<a name="l00825"></a>00825    }
<a name="l00826"></a>00826 
<a name="l00834"></a>00834    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;
<a name="l00835"></a>00835    iterator emplace(const_iterator p, Args&amp;&amp;... args)
<a name="l00836"></a>00836    {
<a name="l00837"></a>00837       <span class="keyword">typename</span> AllocHolder::Deallocator d(AllocHolder::create_node_and_deallocator());
<a name="l00838"></a>00838       <span class="keyword">new</span> ((<span class="keywordtype">void</span>*)containers_detail::get_pointer(d.get())) Node(BOOST_CONTAINER_MOVE_NAMESPACE::forward&lt;Args&gt;(args)...);
<a name="l00839"></a>00839       NodePtr node = d.get();
<a name="l00840"></a>00840       d.release();
<a name="l00841"></a>00841       <span class="keywordflow">return</span> iterator(this-&gt;icont().insert(p.get(), *node));
<a name="l00842"></a>00842    }
<a name="l00843"></a>00843 
<a name="l00844"></a>00844 <span class="preprocessor">   #else //#ifdef BOOST_CONTAINERS_PERFECT_FORWARDING</span>
<a name="l00845"></a>00845 <span class="preprocessor"></span>
<a name="l00846"></a>00846    <span class="comment">//0 args</span>
<a name="l00847"></a>00847    <span class="keywordtype">void</span> emplace_back()
<a name="l00848"></a>00848    {  this-&gt;emplace(this-&gt;cend());  }
<a name="l00849"></a>00849 
<a name="l00850"></a>00850    <span class="keywordtype">void</span> emplace_front()
<a name="l00851"></a>00851    {  this-&gt;emplace(this-&gt;cbegin());   }
<a name="l00852"></a>00852 
<a name="l00853"></a>00853    iterator emplace(const_iterator p)
<a name="l00854"></a>00854    {
<a name="l00855"></a>00855       <span class="keyword">typename</span> AllocHolder::Deallocator d(AllocHolder::create_node_and_deallocator());
<a name="l00856"></a>00856       <span class="keyword">new</span> ((<span class="keywordtype">void</span>*)containers_detail::get_pointer(d.get())) Node();
<a name="l00857"></a>00857       NodePtr node = d.get();
<a name="l00858"></a>00858       d.release();
<a name="l00859"></a>00859       <span class="keywordflow">return</span> iterator(this-&gt;icont().insert(p.get(), *node));
<a name="l00860"></a>00860    }
<a name="l00861"></a>00861 
<a name="l00862"></a>00862 <span class="preprocessor">   #define BOOST_PP_LOCAL_MACRO(n)                                                              \</span>
<a name="l00863"></a>00863 <span class="preprocessor">   template&lt;BOOST_PP_ENUM_PARAMS(n, class P)&gt;                                                   \</span>
<a name="l00864"></a>00864 <span class="preprocessor">   void emplace_back(BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_LIST, _))                     \</span>
<a name="l00865"></a>00865 <span class="preprocessor">   {                                                                                            \</span>
<a name="l00866"></a>00866 <span class="preprocessor">      this-&gt;emplace(this-&gt;cend(), BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_FORWARD, _));    \</span>
<a name="l00867"></a>00867 <span class="preprocessor">   }                                                                                            \</span>
<a name="l00868"></a>00868 <span class="preprocessor">                                                                                                \</span>
<a name="l00869"></a>00869 <span class="preprocessor">   template&lt;BOOST_PP_ENUM_PARAMS(n, class P)&gt;                                                   \</span>
<a name="l00870"></a>00870 <span class="preprocessor">   void emplace_front(BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_LIST, _))                    \</span>
<a name="l00871"></a>00871 <span class="preprocessor">   {  this-&gt;emplace(this-&gt;cbegin(), BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_FORWARD, _));} \</span>
<a name="l00872"></a>00872 <span class="preprocessor">                                                                                                \</span>
<a name="l00873"></a>00873 <span class="preprocessor">   template&lt;BOOST_PP_ENUM_PARAMS(n, class P)&gt;                                                   \</span>
<a name="l00874"></a>00874 <span class="preprocessor">   iterator emplace(const_iterator p, BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_LIST, _))    \</span>
<a name="l00875"></a>00875 <span class="preprocessor">   {                                                                                            \</span>
<a name="l00876"></a>00876 <span class="preprocessor">      typename AllocHolder::Deallocator d(AllocHolder::create_node_and_deallocator());          \</span>
<a name="l00877"></a>00877 <span class="preprocessor">      new ((void*)containers_detail::get_pointer(d.get()))                                                 \</span>
<a name="l00878"></a>00878 <span class="preprocessor">         Node(BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_FORWARD, _));                        \</span>
<a name="l00879"></a>00879 <span class="preprocessor">      NodePtr node = d.get();                                                                   \</span>
<a name="l00880"></a>00880 <span class="preprocessor">      d.release();                                                                              \</span>
<a name="l00881"></a>00881 <span class="preprocessor">      return iterator(this-&gt;icont().insert(p.get(), *node));                                    \</span>
<a name="l00882"></a>00882 <span class="preprocessor">   }                                                                                            \</span>
<a name="l00883"></a>00883 <span class="preprocessor"></span>
<a name="l00884"></a>00884 <span class="preprocessor">   #define BOOST_PP_LOCAL_LIMITS (1, BOOST_CONTAINERS_MAX_CONSTRUCTOR_PARAMETERS)</span>
<a name="l00885"></a>00885 <span class="preprocessor"></span><span class="preprocessor">   #include BOOST_PP_LOCAL_ITERATE()</span>
<a name="l00886"></a>00886 <span class="preprocessor"></span>
<a name="l00887"></a>00887 <span class="preprocessor">   #endif   //#ifdef BOOST_CONTAINERS_PERFECT_FORWARDING</span>
<a name="l00888"></a>00888 <span class="preprocessor"></span>
<a name="l00896"></a><a class="code" href="classboost_1_1container_1_1list.html#a4bacc42503edc6964945b1aac2311ae2">00896</a>    iterator erase(const_iterator p) 
<a name="l00897"></a>00897    {  <span class="keywordflow">return</span> iterator(this-&gt;icont().erase_and_dispose(p.get(), <a class="code" href="classboost_1_1container_1_1containers__detail_1_1allocator__destroyer.html">Destroyer</a>(this-&gt;node_alloc()))); }
<a name="l00898"></a>00898 
<a name="l00906"></a><a class="code" href="classboost_1_1container_1_1list.html#ad5d8c85d502004f8543e2a34b25dc49e">00906</a>    iterator erase(const_iterator first, const_iterator last)
<a name="l00907"></a>00907    {  <span class="keywordflow">return</span> iterator(AllocHolder::erase_range(first.get(), last.get(), <a class="code" href="structboost_1_1container_1_1containers__detail_1_1integral__constant.html">alloc_version</a>())); }
<a name="l00908"></a>00908 
<a name="l00914"></a><a class="code" href="classboost_1_1container_1_1list.html#af248469795d1747c21684729cf1a7fbf">00914</a>    <span class="keywordtype">void</span> assign(<a class="code" href="classboost_1_1container_1_1list.html#a94afde4a93196be9b8baf555e598ef5f" title="An unsigned integral type.">size_type</a> n, <span class="keyword">const</span> T&amp; val) 
<a name="l00915"></a>00915    {  this-&gt;priv_fill_assign(n, val);  }
<a name="l00916"></a>00916 
<a name="l00923"></a>00923    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InpIt&gt;
<a name="l00924"></a><a class="code" href="classboost_1_1container_1_1list.html#a4fe294835098987607e0b0564f1be7a6">00924</a>    <span class="keywordtype">void</span> assign(InpIt first, InpIt last) 
<a name="l00925"></a>00925    {
<a name="l00926"></a>00926       <span class="keyword">const</span> <span class="keywordtype">bool</span> aux_boolean = <a class="code" href="classboost_1_1container_1_1containers__detail_1_1is__convertible.html">containers_detail::is_convertible&lt;InpIt, std::size_t&gt;::value</a>;
<a name="l00927"></a>00927       <span class="keyword">typedef</span> <a class="code" href="structboost_1_1container_1_1containers__detail_1_1bool__.html">containers_detail::bool_&lt;aux_boolean&gt;</a> Result;
<a name="l00928"></a>00928       this-&gt;priv_assign_dispatch(first, last, Result());
<a name="l00929"></a>00929    }
<a name="l00930"></a>00930 
<a name="l00944"></a><a class="code" href="classboost_1_1container_1_1list.html#a7fa8b97286aa0cfedbd922fc001f38e7">00944</a>    <span class="keywordtype">void</span> splice(iterator p, ThisType&amp; x) 
<a name="l00945"></a>00945    {
<a name="l00946"></a>00946       <span class="keywordflow">if</span>((NodeAlloc&amp;)*<span class="keyword">this</span> == (NodeAlloc&amp;)x){
<a name="l00947"></a>00947          this-&gt;icont().splice(p.get(), x.icont());
<a name="l00948"></a>00948       }
<a name="l00949"></a>00949       <span class="keywordflow">else</span>{
<a name="l00950"></a>00950          <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;list::splice called with unequal allocators&quot;</span>);
<a name="l00951"></a>00951       }
<a name="l00952"></a>00952    }
<a name="l00953"></a>00953 
<a name="l00968"></a><a class="code" href="classboost_1_1container_1_1list.html#ac759fa2a491b5d40d1c2d7b5e3717019">00968</a>    <span class="keywordtype">void</span> splice(const_iterator p, ThisType &amp;x, const_iterator i) 
<a name="l00969"></a>00969    {
<a name="l00970"></a>00970       <span class="keywordflow">if</span>((NodeAlloc&amp;)*<span class="keyword">this</span> == (NodeAlloc&amp;)x){
<a name="l00971"></a>00971          this-&gt;icont().splice(p.get(), x.icont(), i.get());
<a name="l00972"></a>00972       }
<a name="l00973"></a>00973       <span class="keywordflow">else</span>{
<a name="l00974"></a>00974          <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;list::splice called with unequal allocators&quot;</span>);
<a name="l00975"></a>00975       }
<a name="l00976"></a>00976    }
<a name="l00977"></a>00977 
<a name="l00991"></a><a class="code" href="classboost_1_1container_1_1list.html#acc300e2ee90b6635cb869f9a1ff9561b">00991</a>    <span class="keywordtype">void</span> splice(const_iterator p, ThisType &amp;x, const_iterator first, const_iterator last) 
<a name="l00992"></a>00992    {
<a name="l00993"></a>00993       <span class="keywordflow">if</span>((NodeAlloc&amp;)*<span class="keyword">this</span> == (NodeAlloc&amp;)x){
<a name="l00994"></a>00994          this-&gt;icont().splice(p.get(), x.icont(), first.get(), last.get());
<a name="l00995"></a>00995       }
<a name="l00996"></a>00996       <span class="keywordflow">else</span>{
<a name="l00997"></a>00997          <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;list::splice called with unequal allocators&quot;</span>);
<a name="l00998"></a>00998       }
<a name="l00999"></a>00999    }
<a name="l01000"></a>01000 
<a name="l01015"></a><a class="code" href="classboost_1_1container_1_1list.html#ad81cf5e49d66ed7553ecb49e4c8b15d1">01015</a>    <span class="keywordtype">void</span> splice(const_iterator p, ThisType &amp;x, const_iterator first, const_iterator last, <a class="code" href="classboost_1_1container_1_1list.html#a94afde4a93196be9b8baf555e598ef5f" title="An unsigned integral type.">size_type</a> n) 
<a name="l01016"></a>01016    {
<a name="l01017"></a>01017       <span class="keywordflow">if</span>((NodeAlloc&amp;)*<span class="keyword">this</span> == (NodeAlloc&amp;)x){
<a name="l01018"></a>01018          this-&gt;icont().splice(p.get(), x.icont(), first.get(), last.get(), n);
<a name="l01019"></a>01019       }
<a name="l01020"></a>01020       <span class="keywordflow">else</span>{
<a name="l01021"></a>01021          <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;list::splice called with unequal allocators&quot;</span>);
<a name="l01022"></a>01022       }
<a name="l01023"></a>01023    }
<a name="l01024"></a>01024 
<a name="l01032"></a><a class="code" href="classboost_1_1container_1_1list.html#a19b16b6c471cfe96a2036fcffd9ca0fc">01032</a>    <span class="keywordtype">void</span> reverse()
<a name="l01033"></a>01033    {  this-&gt;icont().reverse(); }    
<a name="l01034"></a>01034 
<a name="l01043"></a><a class="code" href="classboost_1_1container_1_1list.html#af6f0720027e4066d21b6ddc0ed066ef6">01043</a>    <span class="keywordtype">void</span> <span class="keyword">remove</span>(<span class="keyword">const</span> T&amp; value)
<a name="l01044"></a>01044    {  remove_if(equal_to_value(value));  }
<a name="l01045"></a>01045 
<a name="l01055"></a>01055    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Pred&gt;
<a name="l01056"></a><a class="code" href="classboost_1_1container_1_1list.html#a580339e1e7fb941aca9f09cb7b6461df">01056</a>    <span class="keywordtype">void</span> remove_if(Pred pred)
<a name="l01057"></a>01057    {
<a name="l01058"></a>01058       <span class="keyword">typedef</span> ValueCompareToNodeCompare&lt;Pred&gt; Predicate;
<a name="l01059"></a>01059       this-&gt;icont().remove_and_dispose_if(Predicate(pred), <a class="code" href="classboost_1_1container_1_1containers__detail_1_1allocator__destroyer.html">Destroyer</a>(this-&gt;node_alloc()));
<a name="l01060"></a>01060    }
<a name="l01061"></a>01061 
<a name="l01071"></a><a class="code" href="classboost_1_1container_1_1list.html#a2a760703238574d202ddad1a841dff0e">01071</a>    <span class="keywordtype">void</span> unique()
<a name="l01072"></a>01072    {  this-&gt;<a class="code" href="classboost_1_1container_1_1list.html#a2a760703238574d202ddad1a841dff0e">unique</a>(value_equal());  }
<a name="l01073"></a>01073 
<a name="l01083"></a>01083    <span class="keyword">template</span> &lt;<span class="keyword">class</span> BinaryPredicate&gt;
<a name="l01084"></a><a class="code" href="classboost_1_1container_1_1list.html#ab24ea7d1067e481e6e90c1c349661d4a">01084</a>    <span class="keywordtype">void</span> unique(BinaryPredicate binary_pred)
<a name="l01085"></a>01085    {
<a name="l01086"></a>01086       <span class="keyword">typedef</span> ValueCompareToNodeCompare&lt;BinaryPredicate&gt; Predicate;
<a name="l01087"></a>01087       this-&gt;icont().unique_and_dispose(Predicate(binary_pred), <a class="code" href="classboost_1_1container_1_1containers__detail_1_1allocator__destroyer.html">Destroyer</a>(this-&gt;node_alloc()));
<a name="l01088"></a>01088    }
<a name="l01089"></a>01089 
<a name="l01101"></a><a class="code" href="classboost_1_1container_1_1list.html#a43f4074e714c052fe014acee2ca96424">01101</a>    <span class="keywordtype">void</span> merge(<a class="code" href="classboost_1_1container_1_1list.html">list&lt;T, A&gt;</a>&amp; x)
<a name="l01102"></a>01102    {  this-&gt;<a class="code" href="classboost_1_1container_1_1list.html#a43f4074e714c052fe014acee2ca96424">merge</a>(x, value_less());  }
<a name="l01103"></a>01103 
<a name="l01118"></a>01118    <span class="keyword">template</span> &lt;<span class="keyword">class</span> StrictWeakOrdering&gt;
<a name="l01119"></a><a class="code" href="classboost_1_1container_1_1list.html#a566f809e9183a1c5b7c98e6a5980c3ee">01119</a>    <span class="keywordtype">void</span> merge(<a class="code" href="classboost_1_1container_1_1list.html">list</a> &amp;x, StrictWeakOrdering comp)
<a name="l01120"></a>01120    {
<a name="l01121"></a>01121       <span class="keywordflow">if</span>((NodeAlloc&amp;)*<span class="keyword">this</span> == (NodeAlloc&amp;)x){
<a name="l01122"></a>01122          this-&gt;icont().merge(x.icont(),
<a name="l01123"></a>01123             ValueCompareToNodeCompare&lt;StrictWeakOrdering&gt;(comp));
<a name="l01124"></a>01124       }
<a name="l01125"></a>01125       <span class="keywordflow">else</span>{
<a name="l01126"></a>01126          <span class="keywordflow">throw</span> std::runtime_error(<span class="stringliteral">&quot;list::merge called with unequal allocators&quot;</span>);
<a name="l01127"></a>01127       }
<a name="l01128"></a>01128    }
<a name="l01129"></a>01129 
<a name="l01139"></a><a class="code" href="classboost_1_1container_1_1list.html#a7efaccdbc0283f3fe0cae26f366d36f1">01139</a>    <span class="keywordtype">void</span> sort()
<a name="l01140"></a>01140    {  this-&gt;<a class="code" href="classboost_1_1container_1_1list.html#a7efaccdbc0283f3fe0cae26f366d36f1">sort</a>(value_less());  }
<a name="l01141"></a>01141 
<a name="l01151"></a>01151    <span class="keyword">template</span> &lt;<span class="keyword">class</span> StrictWeakOrdering&gt;
<a name="l01152"></a><a class="code" href="classboost_1_1container_1_1list.html#a2ec93dbf3053b88dcb47e7f6e9781126">01152</a>    <span class="keywordtype">void</span> sort(StrictWeakOrdering comp)
<a name="l01153"></a>01153    {
<a name="l01154"></a>01154       <span class="comment">// nothing if the list has length 0 or 1.</span>
<a name="l01155"></a>01155       <span class="keywordflow">if</span> (this-&gt;size() &lt; 2)
<a name="l01156"></a>01156          <span class="keywordflow">return</span>;
<a name="l01157"></a>01157       this-&gt;icont().sort(ValueCompareToNodeCompare&lt;StrictWeakOrdering&gt;(comp));
<a name="l01158"></a>01158    }
<a name="l01159"></a>01159 
<a name="l01161"></a>01161    <span class="keyword">private</span>:
<a name="l01162"></a>01162 
<a name="l01163"></a>01163    iterator priv_insert(const_iterator p, <span class="keyword">const</span> T &amp;x) 
<a name="l01164"></a>01164    {
<a name="l01165"></a>01165       NodePtr tmp = AllocHolder::create_node(x);
<a name="l01166"></a>01166       <span class="keywordflow">return</span> iterator(this-&gt;icont().insert(p.get(), *tmp));
<a name="l01167"></a>01167    }
<a name="l01168"></a>01168 
<a name="l01169"></a>01169    <span class="comment">//Iterator range version</span>
<a name="l01170"></a>01170    <span class="keyword">template</span>&lt;<span class="keyword">class</span> InpIterator&gt;
<a name="l01171"></a>01171    <span class="keywordtype">void</span> priv_create_and_insert_nodes
<a name="l01172"></a>01172       (const_iterator pos, InpIterator beg, InpIterator end)
<a name="l01173"></a>01173    {
<a name="l01174"></a>01174       <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;InpIterator&gt;::iterator_category ItCat;
<a name="l01175"></a>01175       priv_create_and_insert_nodes(pos, beg, end, alloc_version(), ItCat());
<a name="l01176"></a>01176    }
<a name="l01177"></a>01177 
<a name="l01178"></a>01178    <span class="keyword">template</span>&lt;<span class="keyword">class</span> InpIterator&gt;
<a name="l01179"></a>01179    <span class="keywordtype">void</span> priv_create_and_insert_nodes
<a name="l01180"></a>01180       (const_iterator pos, InpIterator beg, InpIterator end, allocator_v1, std::input_iterator_tag)
<a name="l01181"></a>01181    {
<a name="l01182"></a>01182       <span class="keywordflow">for</span> (; beg != end; ++beg){
<a name="l01183"></a>01183          this-&gt;icont().insert(pos.get(), *this-&gt;create_node_from_it(beg));
<a name="l01184"></a>01184       }
<a name="l01185"></a>01185    }
<a name="l01186"></a>01186 
<a name="l01187"></a>01187    <span class="keyword">template</span>&lt;<span class="keyword">class</span> InpIterator&gt;
<a name="l01188"></a>01188    <span class="keywordtype">void</span> priv_create_and_insert_nodes
<a name="l01189"></a>01189       (const_iterator pos, InpIterator beg, InpIterator end, allocator_v2, std::input_iterator_tag)
<a name="l01190"></a>01190    {  <span class="comment">//Just forward to the default one</span>
<a name="l01191"></a>01191       priv_create_and_insert_nodes(pos, beg, end, allocator_v1(), std::input_iterator_tag());
<a name="l01192"></a>01192    }
<a name="l01193"></a>01193 
<a name="l01194"></a>01194    <span class="keyword">class </span>insertion_functor;
<a name="l01195"></a>01195    <span class="keyword">friend</span> <span class="keyword">class </span>insertion_functor;
<a name="l01196"></a>01196 
<a name="l01197"></a>01197    <span class="keyword">class </span>insertion_functor
<a name="l01198"></a>01198    {
<a name="l01199"></a>01199       Icont &amp;icont_;
<a name="l01200"></a>01200       <span class="keyword">typename</span> Icont::const_iterator pos_;
<a name="l01201"></a>01201 
<a name="l01202"></a>01202       <span class="keyword">public</span>:
<a name="l01203"></a>01203       insertion_functor(Icont &amp;icont, <span class="keyword">typename</span> Icont::const_iterator pos)
<a name="l01204"></a>01204          :  icont_(icont), pos_(pos)
<a name="l01205"></a>01205       {}
<a name="l01206"></a>01206 
<a name="l01207"></a>01207       <span class="keywordtype">void</span> operator()(Node &amp;n)
<a name="l01208"></a>01208       {  this-&gt;icont_.insert(pos_, n); }
<a name="l01209"></a>01209    };
<a name="l01210"></a>01210 
<a name="l01211"></a>01211 
<a name="l01212"></a>01212    <span class="keyword">template</span>&lt;<span class="keyword">class</span> FwdIterator&gt;
<a name="l01213"></a>01213    <span class="keywordtype">void</span> priv_create_and_insert_nodes
<a name="l01214"></a>01214       (const_iterator pos, FwdIterator beg, FwdIterator end, allocator_v2, std::forward_iterator_tag)
<a name="l01215"></a>01215    {
<a name="l01216"></a>01216       <span class="keywordflow">if</span>(beg != end){
<a name="l01217"></a>01217          <span class="comment">//Optimized allocation and construction</span>
<a name="l01218"></a>01218          this-&gt;allocate_many_and_construct
<a name="l01219"></a>01219             (beg, std::distance(beg, end), insertion_functor(this-&gt;icont(), pos.get()));
<a name="l01220"></a>01220       }
<a name="l01221"></a>01221    }
<a name="l01222"></a>01222 
<a name="l01223"></a>01223    <span class="comment">//Default constructed version</span>
<a name="l01224"></a>01224    <span class="keywordtype">void</span> priv_create_and_insert_nodes(const_iterator pos, size_type n)
<a name="l01225"></a>01225    {
<a name="l01226"></a>01226       <span class="keyword">typedef</span> default_construct_iterator&lt;value_type, difference_type&gt; default_iterator;
<a name="l01227"></a>01227       this-&gt;priv_create_and_insert_nodes(pos, default_iterator(n), default_iterator());
<a name="l01228"></a>01228    }
<a name="l01229"></a>01229 
<a name="l01230"></a>01230    <span class="comment">//Copy constructed version</span>
<a name="l01231"></a>01231    <span class="keywordtype">void</span> priv_create_and_insert_nodes(const_iterator pos, size_type n, <span class="keyword">const</span> T&amp; x)
<a name="l01232"></a>01232    {
<a name="l01233"></a>01233       <span class="keyword">typedef</span> constant_iterator&lt;value_type, difference_type&gt; cvalue_iterator;
<a name="l01234"></a>01234       this-&gt;priv_create_and_insert_nodes(pos, cvalue_iterator(x, n), cvalue_iterator());
<a name="l01235"></a>01235    }
<a name="l01236"></a>01236 
<a name="l01237"></a>01237    <span class="comment">//Dispatch to detect iterator range or integer overloads</span>
<a name="l01238"></a>01238    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIter&gt;
<a name="l01239"></a>01239    <span class="keywordtype">void</span> priv_insert_dispatch(const_iterator p,
<a name="l01240"></a>01240                              InputIter first, InputIter last,
<a name="l01241"></a>01241                              containers_detail::false_)
<a name="l01242"></a>01242    {  this-&gt;priv_create_and_insert_nodes(p, first, last);   }
<a name="l01243"></a>01243 
<a name="l01244"></a>01244    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Integer&gt;
<a name="l01245"></a>01245    <span class="keywordtype">void</span> priv_insert_dispatch(const_iterator p, Integer n, Integer x, containers_detail::true_) 
<a name="l01246"></a>01246    {  this-&gt;insert(p, (size_type)n, x);  }
<a name="l01247"></a>01247 
<a name="l01248"></a>01248    <span class="keywordtype">void</span> priv_fill_assign(size_type n, <span class="keyword">const</span> T&amp; val) 
<a name="l01249"></a>01249    {
<a name="l01250"></a>01250       iterator i = this-&gt;begin(), iend = this-&gt;end();
<a name="l01251"></a>01251 
<a name="l01252"></a>01252       <span class="keywordflow">for</span> ( ; i != iend &amp;&amp; n &gt; 0; ++i, --n)
<a name="l01253"></a>01253          *i = val;
<a name="l01254"></a>01254       <span class="keywordflow">if</span> (n &gt; 0){
<a name="l01255"></a>01255          this-&gt;priv_create_and_insert_nodes(this-&gt;cend(), n, val);
<a name="l01256"></a>01256       }
<a name="l01257"></a>01257       <span class="keywordflow">else</span>{
<a name="l01258"></a>01258          this-&gt;erase(i, cend());
<a name="l01259"></a>01259       }
<a name="l01260"></a>01260    }
<a name="l01261"></a>01261 
<a name="l01262"></a>01262    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Integer&gt;
<a name="l01263"></a>01263    <span class="keywordtype">void</span> priv_assign_dispatch(Integer n, Integer val, containers_detail::true_)
<a name="l01264"></a>01264    {  this-&gt;priv_fill_assign((size_type) n, (T) val); }
<a name="l01265"></a>01265 
<a name="l01266"></a>01266    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIter&gt;
<a name="l01267"></a>01267    <span class="keywordtype">void</span> priv_assign_dispatch(InputIter first2, InputIter last2, containers_detail::false_)
<a name="l01268"></a>01268    {
<a name="l01269"></a>01269       iterator first1   = this-&gt;begin();
<a name="l01270"></a>01270       iterator last1    = this-&gt;end();
<a name="l01271"></a>01271       <span class="keywordflow">for</span> ( ; first1 != last1 &amp;&amp; first2 != last2; ++first1, ++first2)
<a name="l01272"></a>01272          *first1 = *first2;
<a name="l01273"></a>01273       <span class="keywordflow">if</span> (first2 == last2)
<a name="l01274"></a>01274          this-&gt;erase(first1, last1);
<a name="l01275"></a>01275       <span class="keywordflow">else</span>{
<a name="l01276"></a>01276          this-&gt;priv_create_and_insert_nodes(last1, first2, last2);
<a name="l01277"></a>01277       }
<a name="l01278"></a>01278    }
<a name="l01279"></a>01279 
<a name="l01280"></a>01280    <span class="comment">//Functors for member algorithm defaults</span>
<a name="l01281"></a>01281    <span class="keyword">struct </span>value_less
<a name="l01282"></a>01282    {
<a name="l01283"></a>01283       <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> value_type &amp;a, <span class="keyword">const</span> value_type &amp;b)<span class="keyword"> const</span>
<a name="l01284"></a>01284 <span class="keyword">         </span>{  <span class="keywordflow">return</span> a &lt; b;  }
<a name="l01285"></a>01285    };
<a name="l01286"></a>01286 
<a name="l01287"></a>01287    <span class="keyword">struct </span>value_equal
<a name="l01288"></a>01288    {
<a name="l01289"></a>01289       <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> value_type &amp;a, <span class="keyword">const</span> value_type &amp;b)<span class="keyword"> const</span>
<a name="l01290"></a>01290 <span class="keyword">         </span>{  <span class="keywordflow">return</span> a == b;  }
<a name="l01291"></a>01291    };
<a name="l01293"></a>01293 
<a name="l01294"></a>01294 };
<a name="l01295"></a>01295 
<a name="l01296"></a>01296 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> A&gt;
<a name="l01297"></a>01297 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> list&lt;T,A&gt;&amp; x, <span class="keyword">const</span> list&lt;T,A&gt;&amp; y)
<a name="l01298"></a>01298 {
<a name="l01299"></a>01299    <span class="keywordflow">if</span>(x.size() != y.size()){
<a name="l01300"></a>01300       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l01301"></a>01301    }
<a name="l01302"></a>01302    <span class="keyword">typedef</span> <span class="keyword">typename</span> list&lt;T,A&gt;::const_iterator const_iterator;
<a name="l01303"></a>01303    const_iterator end1 = x.end();
<a name="l01304"></a>01304 
<a name="l01305"></a>01305    const_iterator i1 = x.begin();
<a name="l01306"></a>01306    const_iterator i2 = y.begin();
<a name="l01307"></a>01307    <span class="keywordflow">while</span> (i1 != end1 &amp;&amp; *i1 == *i2) {
<a name="l01308"></a>01308       ++i1;
<a name="l01309"></a>01309       ++i2;
<a name="l01310"></a>01310    }
<a name="l01311"></a>01311    <span class="keywordflow">return</span> i1 == end1;
<a name="l01312"></a>01312 }
<a name="l01313"></a>01313 
<a name="l01314"></a>01314 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> A&gt;
<a name="l01315"></a>01315 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&lt;(const list&lt;T,A&gt;&amp; x,
<a name="l01316"></a>01316                       <span class="keyword">const</span> list&lt;T,A&gt;&amp; y)
<a name="l01317"></a>01317 {
<a name="l01318"></a>01318   <span class="keywordflow">return</span> std::lexicographical_compare(x.begin(), x.end(), y.begin(), y.end());
<a name="l01319"></a>01319 }
<a name="l01320"></a>01320 
<a name="l01321"></a>01321 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> A&gt;
<a name="l01322"></a>01322 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> list&lt;T,A&gt;&amp; x, <span class="keyword">const</span> list&lt;T,A&gt;&amp; y) 
<a name="l01323"></a>01323 {
<a name="l01324"></a>01324   <span class="keywordflow">return</span> !(x == y);
<a name="l01325"></a>01325 }
<a name="l01326"></a>01326 
<a name="l01327"></a>01327 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> A&gt;
<a name="l01328"></a>01328 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&gt;(<span class="keyword">const</span> list&lt;T,A&gt;&amp; x, <span class="keyword">const</span> list&lt;T,A&gt;&amp; y) 
<a name="l01329"></a>01329 {
<a name="l01330"></a>01330   <span class="keywordflow">return</span> y &lt; x;
<a name="l01331"></a>01331 }
<a name="l01332"></a>01332 
<a name="l01333"></a>01333 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> A&gt;
<a name="l01334"></a>01334 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&lt;=(const list&lt;T,A&gt;&amp; x, <span class="keyword">const</span> list&lt;T,A&gt;&amp; y) 
<a name="l01335"></a>01335 {
<a name="l01336"></a>01336   <span class="keywordflow">return</span> !(y &lt; x);
<a name="l01337"></a>01337 }
<a name="l01338"></a>01338 
<a name="l01339"></a>01339 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> A&gt;
<a name="l01340"></a>01340 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&gt;=(<span class="keyword">const</span> list&lt;T,A&gt;&amp; x, <span class="keyword">const</span> list&lt;T,A&gt;&amp; y) 
<a name="l01341"></a>01341 {
<a name="l01342"></a>01342   <span class="keywordflow">return</span> !(x &lt; y);
<a name="l01343"></a>01343 }
<a name="l01344"></a>01344 
<a name="l01345"></a>01345 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T, <span class="keyword">class</span> A&gt;
<a name="l01346"></a>01346 <span class="keyword">inline</span> <span class="keywordtype">void</span> swap(list&lt;T, A&gt;&amp; x, list&lt;T, A&gt;&amp; y)
<a name="l01347"></a>01347 {
<a name="l01348"></a>01348   x.swap(y);
<a name="l01349"></a>01349 }
<a name="l01350"></a>01350 
<a name="l01352"></a>01352 
<a name="l01353"></a>01353 }  <span class="comment">//namespace container {</span>
<a name="l01354"></a>01354 <span class="comment">/*</span>
<a name="l01357"></a>01357 <span class="comment">template &lt;class T, class A&gt;</span>
<a name="l01358"></a>01358 <span class="comment">struct has_trivial_destructor_after_move&lt;boost::container::list&lt;T, A&gt; &gt;</span>
<a name="l01359"></a>01359 <span class="comment">{</span>
<a name="l01360"></a>01360 <span class="comment">   static const bool value = has_trivial_destructor&lt;A&gt;::value;</span>
<a name="l01361"></a>01361 <span class="comment">};</span>
<a name="l01362"></a>01362 <span class="comment">*/</span>
<a name="l01363"></a>01363 <span class="keyword">namespace </span>container {
<a name="l01364"></a>01364 
<a name="l01366"></a>01366 
<a name="l01367"></a>01367 }}
<a name="l01368"></a>01368 
<a name="l01369"></a>01369 <span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_CONFIG_END_HPP</span>
<a name="l01370"></a>01370 <span class="preprocessor"></span>
<a name="l01371"></a>01371 <span class="preprocessor">#endif // BOOST_CONTAINERS_LIST_HPP_</span>
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Apr 27 2011 00:50:04 for Nutcracker by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
