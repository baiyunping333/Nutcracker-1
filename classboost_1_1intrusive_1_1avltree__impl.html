<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nutcracker: boost::intrusive::avltree_impl&lt; Config &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><b>boost</b>      </li>
      <li><b>intrusive</b>      </li>
      <li><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">avltree_impl</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#friends">Friends</a>  </div>
  <div class="headertitle">
<h1>boost::intrusive::avltree_impl&lt; Config &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="boost::intrusive::avltree_impl" --><!-- doxytag: inherits="clear_on_destructor_base&lt; avltree_impl&lt; Config &gt; &gt;" -->
<p><code>#include &lt;<a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>&gt;</code></p>
<!-- startSectionHeader --><div class="dynheader">
Inheritance diagram for boost::intrusive::avltree_impl&lt; Config &gt;:<!-- endSectionHeader --></div>
<!-- startSectionSummary --><!-- endSectionSummary --><!-- startSectionContent --><div class="dyncontent">
 <div class="center">
  <img src="classboost_1_1intrusive_1_1avltree__impl.png" usemap="#boost::intrusive::avltree_impl&lt; Config &gt;_map" alt=""/>
  <map id="boost::intrusive::avltree_impl&lt; Config &gt;_map" name="boost::intrusive::avltree_impl&lt; Config &gt;_map">
<area href="classboost_1_1intrusive_1_1detail_1_1clear__on__destructor__base.html" alt="boost::intrusive::detail::clear_on_destructor_base&lt; avltree_impl&lt; Config &gt; &gt;" shape="rect" coords="0,0,439,24"/>
</map>
 </div><!-- endSectionContent --></div>

<p><a href="classboost_1_1intrusive_1_1avltree__impl-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af191731c6f3604c3821412edf697d77d"></a><!-- doxytag: member="boost::intrusive::avltree_impl::value_traits" ref="af191731c6f3604c3821412edf697d77d" args="" -->
typedef Config::value_traits&#160;</td><td class="memItemRight" valign="bottom"><b>value_traits</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0879a31de7f68c3a908aa87838e00166"></a><!-- doxytag: member="boost::intrusive::avltree_impl::pointer" ref="a0879a31de7f68c3a908aa87838e00166" args="" -->
typedef real_value_traits::pointer&#160;</td><td class="memItemRight" valign="bottom"><b>pointer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6ee0c485e0e8de7f65bdf2dd13b683cc"></a><!-- doxytag: member="boost::intrusive::avltree_impl::const_pointer" ref="a6ee0c485e0e8de7f65bdf2dd13b683cc" args="" -->
typedef <br class="typebreak"/>
real_value_traits::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><b>const_pointer</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acaf983d8d38197ee23b79f9a3bc753cd"></a><!-- doxytag: member="boost::intrusive::avltree_impl::value_type" ref="acaf983d8d38197ee23b79f9a3bc753cd" args="" -->
typedef std::iterator_traits<br class="typebreak"/>
&lt; pointer &gt;::value_type&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9c4646648f9c2a5cc0be565bd913090b"></a><!-- doxytag: member="boost::intrusive::avltree_impl::key_type" ref="a9c4646648f9c2a5cc0be565bd913090b" args="" -->
typedef value_type&#160;</td><td class="memItemRight" valign="bottom"><b>key_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabcc7f9f0aacc44f1a5d0c85a748b14b"></a><!-- doxytag: member="boost::intrusive::avltree_impl::reference" ref="aabcc7f9f0aacc44f1a5d0c85a748b14b" args="" -->
typedef std::iterator_traits<br class="typebreak"/>
&lt; pointer &gt;::reference&#160;</td><td class="memItemRight" valign="bottom"><b>reference</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0554621a142ffbd5513cdbebbaa932b4"></a><!-- doxytag: member="boost::intrusive::avltree_impl::const_reference" ref="a0554621a142ffbd5513cdbebbaa932b4" args="" -->
typedef std::iterator_traits<br class="typebreak"/>
&lt; const_pointer &gt;::reference&#160;</td><td class="memItemRight" valign="bottom"><b>const_reference</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1aacca49b108fbb920d93c5f91080430"></a><!-- doxytag: member="boost::intrusive::avltree_impl::difference_type" ref="a1aacca49b108fbb920d93c5f91080430" args="" -->
typedef std::iterator_traits<br class="typebreak"/>
&lt; pointer &gt;::difference_type&#160;</td><td class="memItemRight" valign="bottom"><b>difference_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a870da684a63816ad464c602823049ce2"></a><!-- doxytag: member="boost::intrusive::avltree_impl::size_type" ref="a870da684a63816ad464c602823049ce2" args="" -->
typedef Config::size_type&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af76929f23070b06ec0d082de4066d6cb"></a><!-- doxytag: member="boost::intrusive::avltree_impl::value_compare" ref="af76929f23070b06ec0d082de4066d6cb" args="" -->
typedef Config::compare&#160;</td><td class="memItemRight" valign="bottom"><b>value_compare</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6b3d2af3bee5b1915075859f4cbd635a"></a><!-- doxytag: member="boost::intrusive::avltree_impl::key_compare" ref="a6b3d2af3bee5b1915075859f4cbd635a" args="" -->
typedef value_compare&#160;</td><td class="memItemRight" valign="bottom"><b>key_compare</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab135ec3775dd514a13a5171073e47120"></a><!-- doxytag: member="boost::intrusive::avltree_impl::iterator" ref="ab135ec3775dd514a13a5171073e47120" args="" -->
typedef <a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">tree_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">avltree_impl</a>, false &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="addef83ae26238338d44977d94deeb630"></a><!-- doxytag: member="boost::intrusive::avltree_impl::const_iterator" ref="addef83ae26238338d44977d94deeb630" args="" -->
typedef <a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">tree_iterator</a><br class="typebreak"/>
&lt; <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">avltree_impl</a>, true &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa6323c90e3b4fabdc7c4f96340466ec9"></a><!-- doxytag: member="boost::intrusive::avltree_impl::reverse_iterator" ref="aa6323c90e3b4fabdc7c4f96340466ec9" args="" -->
typedef std::reverse_iterator<br class="typebreak"/>
&lt; <a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>reverse_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a637a1536aa498d8eb3169472d276a731"></a><!-- doxytag: member="boost::intrusive::avltree_impl::const_reverse_iterator" ref="a637a1536aa498d8eb3169472d276a731" args="" -->
typedef std::reverse_iterator<br class="typebreak"/>
&lt; <a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>const_reverse_iterator</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27da2c0e1be90b4a84845e5157335f14"></a><!-- doxytag: member="boost::intrusive::avltree_impl::node_traits" ref="a27da2c0e1be90b4a84845e5157335f14" args="" -->
typedef <br class="typebreak"/>
real_value_traits::node_traits&#160;</td><td class="memItemRight" valign="bottom"><b>node_traits</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a818afa3204af7a27e3f3ddc3dc1ab9f2"></a><!-- doxytag: member="boost::intrusive::avltree_impl::node" ref="a818afa3204af7a27e3f3ddc3dc1ab9f2" args="" -->
typedef node_traits::node&#160;</td><td class="memItemRight" valign="bottom"><b>node</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab4ef2597270503e69cd92b2f19218e37"></a><!-- doxytag: member="boost::intrusive::avltree_impl::node_ptr" ref="ab4ef2597270503e69cd92b2f19218e37" args="" -->
typedef <br class="typebreak"/>
boost::pointer_to_other<br class="typebreak"/>
&lt; pointer, node &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>node_ptr</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe1148aee24c0ff6f7947c7421828f27"></a><!-- doxytag: member="boost::intrusive::avltree_impl::const_node_ptr" ref="afe1148aee24c0ff6f7947c7421828f27" args="" -->
typedef <br class="typebreak"/>
boost::pointer_to_other<br class="typebreak"/>
&lt; node_ptr, const node &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><b>const_node_ptr</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af967f0c38512921ea5537116ff52b509"></a><!-- doxytag: member="boost::intrusive::avltree_impl::node_algorithms" ref="af967f0c38512921ea5537116ff52b509" args="" -->
typedef <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">avltree_algorithms</a><br class="typebreak"/>
&lt; node_traits &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>node_algorithms</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afe91120fdc66582b72af6a87bada4ee4"></a><!-- doxytag: member="boost::intrusive::avltree_impl::insert_commit_data" ref="afe91120fdc66582b72af6a87bada4ee4" args="" -->
typedef <br class="typebreak"/>
<a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a665cb410c60648bda0beebcb4425529a">node_algorithms::insert_commit_data</a>&#160;</td><td class="memItemRight" valign="bottom"><b>insert_commit_data</b></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2233ddfaf75a361b73ded8d075c2f1c"></a><!-- doxytag: member="boost::intrusive::avltree_impl::get_real_value_traits" ref="aa2233ddfaf75a361b73ded8d075c2f1c" args="() const " -->
const real_value_traits &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_real_value_traits</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7324415445f416f647547c389e88d963"></a><!-- doxytag: member="boost::intrusive::avltree_impl::get_real_value_traits" ref="a7324415445f416f647547c389e88d963" args="()" -->
real_value_traits &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_real_value_traits</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a8d86509dd42cb3676db54fcbaf409c6f">avltree_impl</a> (const value_compare &amp;cmp=value_compare(), const value_traits &amp;v_traits=value_traits())</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a209b262afe2ba79597024b3ada1ff7dd">avltree_impl</a> (bool unique, Iterator b, Iterator e, const value_compare &amp;cmp=value_compare(), const value_traits &amp;v_traits=value_traits())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#aa49f3378a61874041f69d5cbcdd6a5d0">~avltree_impl</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a9ffdbe55857f436054c07dedef8f26ad">begin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a1eaba40711d9c6f611cf07d8a91e48dc">begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a7c3dbc19019b7b7d47200a74b4ab0d80">cbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a17d718ce900a21673a85003e5c0b74ad">end</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a214db6d653b9f970e0eb1a9d4d43ff5d">end</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a9c6ec1eb411a77e6d1718539cedf1c25">cend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#af6dc87271ceea0b98457599785710671">rbegin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a79984e36f93e447e9236fbb132867f1f">rbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a9fb0ef9b8716ccad1d2eeeb8b5c886d0">crbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a99b540f6edbb65bc2b476cb5583a8ebb">rend</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#ad82236b0d8c19f45e5997e755ce097d2">rend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_reverse_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#ae47fa084f545031b37af801f24c8bd2e">crend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">value_compare&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#ab0fb164ae8bfc5101465d20b9f2ceb04">value_comp</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a46f3e554266238f59f88261d11369371">empty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a05a9d1f05beb7143e4b134db4354861e">size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a5a0b4f80148d891b591e63eacd79ddfa">swap</a> (<a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">avltree_impl</a> &amp;other)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a35c245e6da09fdae9d12470bb19599be">insert_equal</a> (reference value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#aaa948656e878a08c2b70fcaac9b9908d">insert_equal</a> (<a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> hint, reference value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#ac6607df2a23fefb89c063c24674b3c8e">insert_equal</a> (Iterator b, Iterator e)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a03a2b5ec12e3c452c7a308c46bbeaabe">insert_unique</a> (reference value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#afa2c16fa30ebe54da72fdf8daaad52e6">insert_unique</a> (<a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> hint, reference value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a49823b32dfe6c8394da7af6cae43f9c1">insert_unique</a> (Iterator b, Iterator e)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KeyType , class KeyValueCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a64b983d4a40e14b88215ae66975535ec">insert_unique_check</a> (const KeyType &amp;key, KeyValueCompare key_value_comp, insert_commit_data &amp;commit_data)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KeyType , class KeyValueCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a4f8c54f87c95cc5a95a79a263fa261cc">insert_unique_check</a> (<a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> hint, const KeyType &amp;key, KeyValueCompare key_value_comp, insert_commit_data &amp;commit_data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a76f86838608dbca472b3ddf025ba2404">insert_unique_commit</a> (reference value, const insert_commit_data &amp;commit_data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a9997cd47fb8ce499074b8b1c78780609">insert_before</a> (<a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> pos, reference value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#ac1f9966d63f6fa6d03154e3afb8cf6fa">push_back</a> (reference value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a778c7cbf58f80cef0acb8914d7bbc3c5">push_front</a> (reference value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#af146cf59c4093c2661157a88cfd30f57">erase</a> (<a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#ac57bffaa2331cbc60dd517e502c2f834">erase</a> (<a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> b, <a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> e)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#adac6e6bc38ba975cdf49a6d583871d31">erase</a> (const_reference value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KeyType , class KeyValueCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#ae45b7c5c67884204dd8b221dda81b5fb">erase</a> (const KeyType &amp;key, KeyValueCompare comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Disposer &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a903e96e7ba5ab81dbc52cd203780863b">erase_and_dispose</a> (<a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> i, Disposer disposer)</td></tr>
<tr><td class="memTemplParams" colspan="2"><a class="anchor" id="aa2a4836cad4451b0632ccc027dadf206"></a><!-- doxytag: member="boost::intrusive::avltree_impl::erase_and_dispose" ref="aa2a4836cad4451b0632ccc027dadf206" args="(iterator i, Disposer disposer)" -->
template&lt;class Disposer &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><b>erase_and_dispose</b> (<a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> i, Disposer disposer)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Disposer &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#ae717eec4b36acf06fc298b167f292c47">erase_and_dispose</a> (<a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> b, <a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> e, Disposer disposer)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Disposer &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a3b413f7ed982c06675551ebe4ba82eca">erase_and_dispose</a> (const_reference value, Disposer disposer)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KeyType , class KeyValueCompare , class Disposer &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a1a047dd2725652b440cc41bfd53934a7">erase_and_dispose</a> (const KeyType &amp;key, KeyValueCompare comp, Disposer disposer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a7b3e9f6242ec335469714a5c74014867">clear</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Disposer &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#adeb92ca76f57b261ff0a4353e1a33399">clear_and_dispose</a> (Disposer disposer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a8322392cfeb59740affa74c626ae67b3">count</a> (const_reference value) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KeyType , class KeyValueCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">size_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a9a02cf21fedfd84a39fc80489570b251">count</a> (const KeyType &amp;key, KeyValueCompare comp) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a4ec8b654a35d57c29930ee345afa0d64">lower_bound</a> (const_reference value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#abb6b230dd4cce43de0e4ed9d301b2ca6">lower_bound</a> (const_reference value) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KeyType , class KeyValueCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#ac3b40d6e841ac8fc7bb0c1a087564170">lower_bound</a> (const KeyType &amp;key, KeyValueCompare comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KeyType , class KeyValueCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a8c7c556ec41bfbe57974c35c8792071f">lower_bound</a> (const KeyType &amp;key, KeyValueCompare comp) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#acfb59e39ed58efb6934292e7d0f1438e">upper_bound</a> (const_reference value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KeyType , class KeyValueCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#aef47e494d5ab7385a98efa88f786a673">upper_bound</a> (const KeyType &amp;key, KeyValueCompare comp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a2c38a0f22cca065690fef9089afa0719">upper_bound</a> (const_reference value) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KeyType , class KeyValueCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#ad4bc805f83c366672291eaf56946ccd3">upper_bound</a> (const KeyType &amp;key, KeyValueCompare comp) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a42e301244fab463a34bae93180298f55">find</a> (const_reference value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KeyType , class KeyValueCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a45ecb087169d907524ad607b1a4306fe">find</a> (const KeyType &amp;key, KeyValueCompare comp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#ae379a55a0234bdd0cbf9ef7792138ded">find</a> (const_reference value) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KeyType , class KeyValueCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a6de90665e60b8abf7ae1f0928efbc778">find</a> (const KeyType &amp;key, KeyValueCompare comp) const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>, <a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a0912eadddd3986de1d628852c10a59f3">equal_range</a> (const_reference value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KeyType , class KeyValueCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>, <a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a4995ce0482c04d019f367733da8bdf69">equal_range</a> (const KeyType &amp;key, KeyValueCompare comp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>, <br class="typebreak"/>
<a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a2548447e3bffc9bad5914a2a980ea1d2">equal_range</a> (const_reference value) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KeyType , class KeyValueCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>, <br class="typebreak"/>
<a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a82138dc1936c2f0c250be844a266d09c">equal_range</a> (const KeyType &amp;key, KeyValueCompare comp) const </td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Cloner , class Disposer &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#adc672cc9aef47fa9aa8b6d11d7484bec">clone_from</a> (const <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">avltree_impl</a> &amp;src, Cloner cloner, Disposer disposer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#aeb3c5629a490934e732a271c8a910367">unlink_leftmost_without_rebalance</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#afce130f92188c54aca3059cea80d5c2f">replace_node</a> (<a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> replace_this, reference with_this)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a91363086150e5f7d72b27598571261c2">iterator_to</a> (reference value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#acc3336eedf33bb380199530c7708adfa">iterator_to</a> (const_reference value) const </td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">avltree_impl</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a235d235bad59fdad06408ace034dbe17">container_from_end_iterator</a> (<a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> end_iterator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">avltree_impl</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a8b69b7954c76277d223a372d5187fc63">container_from_end_iterator</a> (<a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> end_iterator)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">avltree_impl</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#accdfbd1de0055a1c7bf54576761465b4">container_from_iterator</a> (<a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> it)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">avltree_impl</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#ac25e578abf78d3058bc114bffcc4a053">container_from_iterator</a> (<a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> it)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#afb018ce99baee9309d1cc3cd2674332b">s_iterator_to</a> (reference value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#abdc5a0a2666256d47b0ea1119f79f823">s_iterator_to</a> (const_reference value)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a96a8cfd12e778e40b93e9031593cd597">init_node</a> (reference value)</td></tr>
<tr><td colspan="2"><h2><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a44f84161926b72acd73079de44249f99"></a><!-- doxytag: member="boost::intrusive::avltree_impl::constant_time_size" ref="a44f84161926b72acd73079de44249f99" args="" -->
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>constant_time_size</b> = Config::constant_time_size</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a544c669a07aa8db86744fda8c863eb33"></a><!-- doxytag: member="boost::intrusive::avltree_impl::stateful_value_traits" ref="a544c669a07aa8db86744fda8c863eb33" args="" -->
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>stateful_value_traits</b> = <a class="el" href="structboost_1_1intrusive_1_1detail_1_1store__cont__ptr__on__it.html">detail::store_cont_ptr_on_it</a>&lt;<a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">avltree_impl</a>&gt;::value</td></tr>
<tr><td colspan="2"><h2><a name="friends"></a>
Friends</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31fd0689b65ac35326310da6bc0d0ae0"></a><!-- doxytag: member="boost::intrusive::avltree_impl::detail::clear_on_destructor_base" ref="a31fd0689b65ac35326310da6bc0d0ae0" args="" -->
class&#160;</td><td class="memItemRight" valign="bottom"><b>detail::clear_on_destructor_base</b></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class Config&gt;<br/>
 class boost::intrusive::avltree_impl&lt; Config &gt;</h3>

<p>The class template avltree is an intrusive AVL tree container, that is used to construct intrusive <a class="el" href="classboost_1_1intrusive_1_1avl__set.html">avl_set</a> and <a class="el" href="classboost_1_1intrusive_1_1avl__multiset.html">avl_multiset</a> containers. The no-throw guarantee holds only, if the value_compare object doesn't throw.</p>
<p>The template parameter <code>T</code> is the type to be managed by the container. The user can specify additional options and if no options are provided default options are used.</p>
<p>The container supports the following options: <code>base_hook&lt;&gt;/member_hook&lt;&gt;/value_traits&lt;&gt;</code>, <code>constant_time_size&lt;&gt;</code>, <code>size_type&lt;&gt;</code> and <code>compare&lt;&gt;</code>. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00081">81</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8d86509dd42cb3676db54fcbaf409c6f"></a><!-- doxytag: member="boost::intrusive::avltree_impl::avltree_impl" ref="a8d86509dd42cb3676db54fcbaf409c6f" args="(const value_compare &amp;cmp=value_compare(), const value_traits &amp;v_traits=value_traits())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::<a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">avltree_impl</a> </td>
          <td>(</td>
          <td class="paramtype">const value_compare &amp;&#160;</td>
          <td class="paramname"> <em>cmp</em> = <code>value_compare()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_traits &amp;&#160;</td>
          <td class="paramname"> <em>v_traits</em> = <code>value_traits()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Constructs an empty tree.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor of the value_compare object throws. Basic guarantee. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00210">210</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a209b262afe2ba79597024b3ada1ff7dd"></a><!-- doxytag: member="boost::intrusive::avltree_impl::avltree_impl" ref="a209b262afe2ba79597024b3ada1ff7dd" args="(bool unique, Iterator b, Iterator e, const value_compare &amp;cmp=value_compare(), const value_traits &amp;v_traits=value_traits())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
<div class="memtemplate">
template&lt;class Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::<a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">avltree_impl</a> </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"> <em>unique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_compare &amp;&#160;</td>
          <td class="paramname"> <em>cmp</em> = <code>value_compare()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const value_traits &amp;&#160;</td>
          <td class="paramname"> <em>v_traits</em> = <code>value_traits()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: Dereferencing iterator must yield an lvalue of type value_type. cmp must be a comparison function that induces a strict weak ordering.</p>
<p><b>Effects</b>: Constructs an empty tree and inserts elements from [b, e).</p>
<p><b>Complexity</b>: Linear in N if [b, e) is already sorted using comp and otherwise N * log N, where N is the distance between first and last.</p>
<p><b>Throws</b>: If value_traits::node_traits::node constructor throws (this does not happen with predefined Boost.Intrusive hooks) or the copy constructor/operator() of the value_compare object throws. Basic guarantee. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00231">231</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa49f3378a61874041f69d5cbcdd6a5d0"></a><!-- doxytag: member="boost::intrusive::avltree_impl::~avltree_impl" ref="aa49f3378a61874041f69d5cbcdd6a5d0" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::~<a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">avltree_impl</a> </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Detaches all elements from this. The objects in the set are not deleted (i.e. no destructors are called), but the nodes according to the <a class="el" href="structboost_1_1intrusive_1_1value__traits.html">value_traits</a> template parameter are reinitialized and thus can be reused.</p>
<p><b>Complexity</b>: Linear to elements contained in *this.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00251">251</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a9ffdbe55857f436054c07dedef8f26ad"></a><!-- doxytag: member="boost::intrusive::avltree_impl::begin" ref="a9ffdbe55857f436054c07dedef8f26ad" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::begin </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns an iterator pointing to the beginning of the tree.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00259">259</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1eaba40711d9c6f611cf07d8a91e48dc"></a><!-- doxytag: member="boost::intrusive::avltree_impl::begin" ref="a1eaba40711d9c6f611cf07d8a91e48dc" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::begin </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns a const_iterator pointing to the beginning of the tree.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00267">267</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7c3dbc19019b7b7d47200a74b4ab0d80"></a><!-- doxytag: member="boost::intrusive::avltree_impl::cbegin" ref="a7c3dbc19019b7b7d47200a74b4ab0d80" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns a const_iterator pointing to the beginning of the tree.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00275">275</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9c6ec1eb411a77e6d1718539cedf1c25"></a><!-- doxytag: member="boost::intrusive::avltree_impl::cend" ref="a9c6ec1eb411a77e6d1718539cedf1c25" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::cend </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns a const_iterator pointing to the end of the tree.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00299">299</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7b3e9f6242ec335469714a5c74014867"></a><!-- doxytag: member="boost::intrusive::avltree_impl::clear" ref="a7b3e9f6242ec335469714a5c74014867" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::clear </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Erases all of the elements.</p>
<p><b>Complexity</b>: Linear to the number of elements on the container. if it's a safe-mode or auto-unlink value_type. Constant time otherwise.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00948">948</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adeb92ca76f57b261ff0a4353e1a33399"></a><!-- doxytag: member="boost::intrusive::avltree_impl::clear_and_dispose" ref="adeb92ca76f57b261ff0a4353e1a33399" args="(Disposer disposer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
<div class="memtemplate">
template&lt;class Disposer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::clear_and_dispose </td>
          <td>(</td>
          <td class="paramtype">Disposer&#160;</td>
          <td class="paramname"> <em>disposer</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Erases all of the elements calling disposer(p) for each node to be erased. <b>Complexity</b>: Average complexity for is at most O(log(<a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a05a9d1f05beb7143e4b134db4354861e">size()</a> + N)), where N is the number of elements in the container.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: Invalidates the iterators (but not the references) to the erased elements. Calls N times to disposer functor. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00969">969</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adc672cc9aef47fa9aa8b6d11d7484bec"></a><!-- doxytag: member="boost::intrusive::avltree_impl::clone_from" ref="adc672cc9aef47fa9aa8b6d11d7484bec" args="(const avltree_impl &amp;src, Cloner cloner, Disposer disposer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
<div class="memtemplate">
template&lt;class Cloner , class Disposer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::clone_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">avltree_impl</a>&lt; Config &gt; &amp;&#160;</td>
          <td class="paramname"> <em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cloner&#160;</td>
          <td class="paramname"> <em>cloner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Disposer&#160;</td>
          <td class="paramname"> <em>disposer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: Disposer::operator()(pointer) shouldn't throw. Cloner should yield to nodes equivalent to the original nodes.</p>
<p><b>Effects</b>: Erases all the elements from *this calling Disposer::operator()(pointer), clones all the elements from src calling Cloner::operator()(const_reference ) and inserts them on *this. Copies the predicate from the source container.</p>
<p>If cloner throws, all cloned elements are unlinked and disposed calling Disposer::operator()(pointer).</p>
<p><b>Complexity</b>: Linear to erased plus inserted elements.</p>
<p><b>Throws</b>: If cloner throws or predicate copy assignment throws. Basic guarantee. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l01216">1216</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8b69b7954c76277d223a372d5187fc63"></a><!-- doxytag: member="boost::intrusive::avltree_impl::container_from_end_iterator" ref="a8b69b7954c76277d223a372d5187fc63" args="(const_iterator end_iterator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">avltree_impl</a>&amp; <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::container_from_end_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"> <em>end_iterator</em>&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Precondition</b>: end_iterator must be a valid end const_iterator of avltree.</p>
<p><b>Effects</b>: Returns a const reference to the avltree associated to the end iterator</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Constant. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00375">375</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a235d235bad59fdad06408ace034dbe17"></a><!-- doxytag: member="boost::intrusive::avltree_impl::container_from_end_iterator" ref="a235d235bad59fdad06408ace034dbe17" args="(iterator end_iterator)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">avltree_impl</a>&amp; <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::container_from_end_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>&#160;</td>
          <td class="paramname"> <em>end_iterator</em>&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Precondition</b>: end_iterator must be a valid end iterator of avltree.</p>
<p><b>Effects</b>: Returns a const reference to the avltree associated to the end iterator</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Constant. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00364">364</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="accdfbd1de0055a1c7bf54576761465b4"></a><!-- doxytag: member="boost::intrusive::avltree_impl::container_from_iterator" ref="accdfbd1de0055a1c7bf54576761465b4" args="(iterator it)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">avltree_impl</a>&amp; <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::container_from_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>&#160;</td>
          <td class="paramname"> <em>it</em>&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Precondition</b>: it must be a valid iterator of rbtree.</p>
<p><b>Effects</b>: Returns a const reference to the tree associated to the iterator</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Logarithmic. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00386">386</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac25e578abf78d3058bc114bffcc4a053"></a><!-- doxytag: member="boost::intrusive::avltree_impl::container_from_iterator" ref="ac25e578abf78d3058bc114bffcc4a053" args="(const_iterator it)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">avltree_impl</a>&amp; <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::container_from_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"> <em>it</em>&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Precondition</b>: it must be a valid end const_iterator of rbtree.</p>
<p><b>Effects</b>: Returns a const reference to the tree associated to the iterator</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Logarithmic. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00397">397</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8322392cfeb59740affa74c626ae67b3"></a><!-- doxytag: member="boost::intrusive::avltree_impl::count" ref="a8322392cfeb59740affa74c626ae67b3" args="(const_reference value) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"> <em>value</em>&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns the number of contained elements with the given value</p>
<p><b>Complexity</b>: Logarithmic to the number of elements contained plus lineal to number of objects with the given value.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00983">983</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9a02cf21fedfd84a39fc80489570b251"></a><!-- doxytag: member="boost::intrusive::avltree_impl::count" ref="a9a02cf21fedfd84a39fc80489570b251" args="(const KeyType &amp;key, KeyValueCompare comp) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
<div class="memtemplate">
template&lt;class KeyType , class KeyValueCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyValueCompare&#160;</td>
          <td class="paramname"> <em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns the number of contained elements with the given key</p>
<p><b>Complexity</b>: Logarithmic to the number of elements contained plus lineal to number of objects with the given key.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00993">993</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9fb0ef9b8716ccad1d2eeeb8b5c886d0"></a><!-- doxytag: member="boost::intrusive::avltree_impl::crbegin" ref="a9fb0ef9b8716ccad1d2eeeb8b5c886d0" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::crbegin </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns a const_reverse_iterator pointing to the beginning of the reversed tree.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00326">326</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae47fa084f545031b37af801f24c8bd2e"></a><!-- doxytag: member="boost::intrusive::avltree_impl::crend" ref="ae47fa084f545031b37af801f24c8bd2e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::crend </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns a const_reverse_iterator pointing to the end of the reversed tree.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00353">353</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a46f3e554266238f59f88261d11369371"></a><!-- doxytag: member="boost::intrusive::avltree_impl::empty" ref="a46f3e554266238f59f88261d11369371" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::empty </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns true if the container is empty.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00413">413</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a214db6d653b9f970e0eb1a9d4d43ff5d"></a><!-- doxytag: member="boost::intrusive::avltree_impl::end" ref="a214db6d653b9f970e0eb1a9d4d43ff5d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::end </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns a const_iterator pointing to the end of the tree.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00291">291</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a17d718ce900a21673a85003e5c0b74ad"></a><!-- doxytag: member="boost::intrusive::avltree_impl::end" ref="a17d718ce900a21673a85003e5c0b74ad" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::end </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns an iterator pointing to the end of the tree.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00283">283</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a82138dc1936c2f0c250be844a266d09c"></a><!-- doxytag: member="boost::intrusive::avltree_impl::equal_range" ref="a82138dc1936c2f0c250be844a266d09c" args="(const KeyType &amp;key, KeyValueCompare comp) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
<div class="memtemplate">
template&lt;class KeyType , class KeyValueCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>, <a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>&gt; <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyValueCompare&#160;</td>
          <td class="paramname"> <em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l01192">1192</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4995ce0482c04d019f367733da8bdf69"></a><!-- doxytag: member="boost::intrusive::avltree_impl::equal_range" ref="a4995ce0482c04d019f367733da8bdf69" args="(const KeyType &amp;key, KeyValueCompare comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
<div class="memtemplate">
template&lt;class KeyType , class KeyValueCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>,<a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>&gt; <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyValueCompare&#160;</td>
          <td class="paramname"> <em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l01163">1163</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0912eadddd3986de1d628852c10a59f3"></a><!-- doxytag: member="boost::intrusive::avltree_impl::equal_range" ref="a0912eadddd3986de1d628852c10a59f3" args="(const_reference value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>,<a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>&gt; <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"> <em>value</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l01152">1152</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2548447e3bffc9bad5914a2a980ea1d2"></a><!-- doxytag: member="boost::intrusive::avltree_impl::equal_range" ref="a2548447e3bffc9bad5914a2a980ea1d2" args="(const_reference value) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>, <a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>&gt; <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"> <em>value</em>&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Finds a range containing all elements whose key is k or an empty range that indicates the position where those elements would be if they there is no elements with key k.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l01180">1180</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af146cf59c4093c2661157a88cfd30f57"></a><!-- doxytag: member="boost::intrusive::avltree_impl::erase" ref="af146cf59c4093c2661157a88cfd30f57" args="(const_iterator i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"> <em>i</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Erases the element pointed to by pos.</p>
<p><b>Complexity</b>: Average complexity for erase element is constant time.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00785">785</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac57bffaa2331cbc60dd517e502c2f834"></a><!-- doxytag: member="boost::intrusive::avltree_impl::erase" ref="ac57bffaa2331cbc60dd517e502c2f834" args="(const_iterator b, const_iterator e)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::erase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"> <em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Erases the range pointed to by b end e.</p>
<p><b>Complexity</b>: Average complexity for erase range is at most O(log(<a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a05a9d1f05beb7143e4b134db4354861e">size()</a> + N)), where N is the number of elements in the range.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00808">808</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adac6e6bc38ba975cdf49a6d583871d31"></a><!-- doxytag: member="boost::intrusive::avltree_impl::erase" ref="adac6e6bc38ba975cdf49a6d583871d31" args="(const_reference value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"> <em>value</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Erases all the elements with the given value.</p>
<p><b>Returns</b>: The number of erased elements.</p>
<p><b>Complexity</b>: O(log(<a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a05a9d1f05beb7143e4b134db4354861e">size()</a> + N).</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00821">821</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae45b7c5c67884204dd8b221dda81b5fb"></a><!-- doxytag: member="boost::intrusive::avltree_impl::erase" ref="ae45b7c5c67884204dd8b221dda81b5fb" args="(const KeyType &amp;key, KeyValueCompare comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
<div class="memtemplate">
template&lt;class KeyType , class KeyValueCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyValueCompare&#160;</td>
          <td class="paramname"> <em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Erases all the elements with the given key. according to the comparison functor "comp".</p>
<p><b>Returns</b>: The number of erased elements.</p>
<p><b>Complexity</b>: O(log(<a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a05a9d1f05beb7143e4b134db4354861e">size()</a> + N).</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00836">836</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a903e96e7ba5ab81dbc52cd203780863b"></a><!-- doxytag: member="boost::intrusive::avltree_impl::erase_and_dispose" ref="a903e96e7ba5ab81dbc52cd203780863b" args="(const_iterator i, Disposer disposer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
<div class="memtemplate">
template&lt;class Disposer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::erase_and_dispose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"> <em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Disposer&#160;</td>
          <td class="paramname"> <em>disposer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: Disposer::operator()(pointer) shouldn't throw.</p>
<p><b>Effects</b>: Erases the element pointed to by pos. Disposer::operator()(pointer) is called for the removed element.</p>
<p><b>Complexity</b>: Average complexity for erase element is constant time.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: Invalidates the iterators to the erased elements. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00860">860</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae717eec4b36acf06fc298b167f292c47"></a><!-- doxytag: member="boost::intrusive::avltree_impl::erase_and_dispose" ref="ae717eec4b36acf06fc298b167f292c47" args="(const_iterator b, const_iterator e, Disposer disposer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
<div class="memtemplate">
template&lt;class Disposer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::erase_and_dispose </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"> <em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Disposer&#160;</td>
          <td class="paramname"> <em>disposer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: Disposer::operator()(pointer) shouldn't throw.</p>
<p><b>Effects</b>: Erases the range pointed to by b end e. Disposer::operator()(pointer) is called for the removed elements.</p>
<p><b>Complexity</b>: Average complexity for erase range is at most O(log(<a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a05a9d1f05beb7143e4b134db4354861e">size()</a> + N)), where N is the number of elements in the range.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: Invalidates the iterators to the erased elements. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00887">887</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3b413f7ed982c06675551ebe4ba82eca"></a><!-- doxytag: member="boost::intrusive::avltree_impl::erase_and_dispose" ref="a3b413f7ed982c06675551ebe4ba82eca" args="(const_reference value, Disposer disposer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
<div class="memtemplate">
template&lt;class Disposer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::erase_and_dispose </td>
          <td>(</td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Disposer&#160;</td>
          <td class="paramname"> <em>disposer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: Disposer::operator()(pointer) shouldn't throw.</p>
<p><b>Effects</b>: Erases all the elements with the given value. Disposer::operator()(pointer) is called for the removed elements.</p>
<p><b>Returns</b>: The number of erased elements.</p>
<p><b>Complexity</b>: O(log(<a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a05a9d1f05beb7143e4b134db4354861e">size()</a> + N).</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: Invalidates the iterators (but not the references) to the erased elements. No destructors are called. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00904">904</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1a047dd2725652b440cc41bfd53934a7"></a><!-- doxytag: member="boost::intrusive::avltree_impl::erase_and_dispose" ref="a1a047dd2725652b440cc41bfd53934a7" args="(const KeyType &amp;key, KeyValueCompare comp, Disposer disposer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
<div class="memtemplate">
template&lt;class KeyType , class KeyValueCompare , class Disposer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::erase_and_dispose </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyValueCompare&#160;</td>
          <td class="paramname"> <em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Disposer&#160;</td>
          <td class="paramname"> <em>disposer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: Disposer::operator()(pointer) shouldn't throw.</p>
<p><b>Effects</b>: Erases all the elements with the given key. according to the comparison functor "comp". Disposer::operator()(pointer) is called for the removed elements.</p>
<p><b>Returns</b>: The number of erased elements.</p>
<p><b>Complexity</b>: O(log(<a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a05a9d1f05beb7143e4b134db4354861e">size()</a> + N).</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: Invalidates the iterators to the erased elements. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00927">927</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6de90665e60b8abf7ae1f0928efbc778"></a><!-- doxytag: member="boost::intrusive::avltree_impl::find" ref="a6de90665e60b8abf7ae1f0928efbc778" args="(const KeyType &amp;key, KeyValueCompare comp) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
<div class="memtemplate">
template&lt;class KeyType , class KeyValueCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyValueCompare&#160;</td>
          <td class="paramname"> <em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Finds a const_iterator to the first element whose key is k or <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a17d718ce900a21673a85003e5c0b74ad">end()</a> if that element does not exist.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l01137">1137</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a42e301244fab463a34bae93180298f55"></a><!-- doxytag: member="boost::intrusive::avltree_impl::find" ref="a42e301244fab463a34bae93180298f55" args="(const_reference value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"> <em>value</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Finds an iterator to the first element whose key is k or <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a17d718ce900a21673a85003e5c0b74ad">end()</a> if that element does not exist.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l01103">1103</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a45ecb087169d907524ad607b1a4306fe"></a><!-- doxytag: member="boost::intrusive::avltree_impl::find" ref="a45ecb087169d907524ad607b1a4306fe" args="(const KeyType &amp;key, KeyValueCompare comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
<div class="memtemplate">
template&lt;class KeyType , class KeyValueCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyValueCompare&#160;</td>
          <td class="paramname"> <em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Finds an iterator to the first element whose key is k or <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a17d718ce900a21673a85003e5c0b74ad">end()</a> if that element does not exist.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l01113">1113</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae379a55a0234bdd0cbf9ef7792138ded"></a><!-- doxytag: member="boost::intrusive::avltree_impl::find" ref="ae379a55a0234bdd0cbf9ef7792138ded" args="(const_reference value) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"> <em>value</em>&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Finds a const_iterator to the first element whose key is k or <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a17d718ce900a21673a85003e5c0b74ad">end()</a> if that element does not exist.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l01127">1127</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a96a8cfd12e778e40b93e9031593cd597"></a><!-- doxytag: member="boost::intrusive::avltree_impl::init_node" ref="a96a8cfd12e778e40b93e9031593cd597" args="(reference value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::init_node </td>
          <td>(</td>
          <td class="paramtype">reference&#160;</td>
          <td class="paramname"> <em>value</em>&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: value shall not be in a tree.</p>
<p><b>Effects</b>: init_node puts the hook of a value in a well-known default state.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Constant time.</p>
<p><b>Note</b>: This function puts the hook in the well-known default state used by auto_unlink and safe hooks. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l01347">1347</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9997cd47fb8ce499074b8b1c78780609"></a><!-- doxytag: member="boost::intrusive::avltree_impl::insert_before" ref="a9997cd47fb8ce499074b8b1c78780609" args="(const_iterator pos, reference value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::insert_before </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reference&#160;</td>
          <td class="paramname"> <em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: value must be an lvalue, "pos" must be a valid iterator (or end) and must be the succesor of value once inserted according to the predicate</p>
<p><b>Effects</b>: Inserts x into the tree before "pos".</p>
<p><b>Complexity</b>: Constant time.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: This function does not check preconditions so if "pos" is not the successor of "value" tree ordering invariant will be broken. This is a low-level function to be used only for performance reasons by advanced users. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00721">721</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a35c245e6da09fdae9d12470bb19599be"></a><!-- doxytag: member="boost::intrusive::avltree_impl::insert_equal" ref="a35c245e6da09fdae9d12470bb19599be" args="(reference value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::insert_equal </td>
          <td>(</td>
          <td class="paramtype">reference&#160;</td>
          <td class="paramname"> <em>value</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: value must be an lvalue</p>
<p><b>Effects</b>: Inserts value into the tree before the upper bound.</p>
<p><b>Complexity</b>: Average complexity for insert element is at most logarithmic.</p>
<p><b>Throws</b>: If the internal value_compare ordering function throws. Strong guarantee.</p>
<p><b>Note</b>: Does not affect the validity of iterators and references. No copy-constructors are called. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00461">461</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaa948656e878a08c2b70fcaac9b9908d"></a><!-- doxytag: member="boost::intrusive::avltree_impl::insert_equal" ref="aaa948656e878a08c2b70fcaac9b9908d" args="(const_iterator hint, reference value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::insert_equal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"> <em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reference&#160;</td>
          <td class="paramname"> <em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: value must be an lvalue, and "hint" must be a valid iterator.</p>
<p><b>Effects</b>: Inserts x into the tree, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case)</p>
<p><b>Complexity</b>: Logarithmic in general, but it is amortized constant time if t is inserted immediately before hint.</p>
<p><b>Throws</b>: If the internal value_compare ordering function throws. Strong guarantee.</p>
<p><b>Note</b>: Does not affect the validity of iterators and references. No copy-constructors are called. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00487">487</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac6607df2a23fefb89c063c24674b3c8e"></a><!-- doxytag: member="boost::intrusive::avltree_impl::insert_equal" ref="ac6607df2a23fefb89c063c24674b3c8e" args="(Iterator b, Iterator e)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
<div class="memtemplate">
template&lt;class Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::insert_equal </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"> <em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: Dereferencing iterator must yield an lvalue of type value_type.</p>
<p><b>Effects</b>: Inserts a each element of a range into the tree before the upper bound of the key of each element.</p>
<p><b>Complexity</b>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#ab0fb164ae8bfc5101465d20b9f2ceb04">value_comp()</a>.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: Does not affect the validity of iterators and references. No copy-constructors are called. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00514">514</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a03a2b5ec12e3c452c7a308c46bbeaabe"></a><!-- doxytag: member="boost::intrusive::avltree_impl::insert_unique" ref="a03a2b5ec12e3c452c7a308c46bbeaabe" args="(reference value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>, bool&gt; <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::insert_unique </td>
          <td>(</td>
          <td class="paramtype">reference&#160;</td>
          <td class="paramname"> <em>value</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: value must be an lvalue</p>
<p><b>Effects</b>: Inserts value into the tree if the value is not already present.</p>
<p><b>Complexity</b>: Average complexity for insert element is at most logarithmic.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: Does not affect the validity of iterators and references. No copy-constructors are called. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00533">533</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afa2c16fa30ebe54da72fdf8daaad52e6"></a><!-- doxytag: member="boost::intrusive::avltree_impl::insert_unique" ref="afa2c16fa30ebe54da72fdf8daaad52e6" args="(const_iterator hint, reference value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::insert_unique </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"> <em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reference&#160;</td>
          <td class="paramname"> <em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: value must be an lvalue, and "hint" must be a valid iterator</p>
<p><b>Effects</b>: Tries to insert x into the tree, using "hint" as a hint to where it will be inserted.</p>
<p><b>Complexity</b>: Logarithmic in general, but it is amortized constant time (two comparisons in the worst case) if t is inserted immediately before hint.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: Does not affect the validity of iterators and references. No copy-constructors are called. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00556">556</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a49823b32dfe6c8394da7af6cae43f9c1"></a><!-- doxytag: member="boost::intrusive::avltree_impl::insert_unique" ref="a49823b32dfe6c8394da7af6cae43f9c1" args="(Iterator b, Iterator e)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
<div class="memtemplate">
template&lt;class Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::insert_unique </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"> <em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"> <em>e</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: Dereferencing iterator must yield an lvalue of type value_type.</p>
<p><b>Effects</b>: Tries to insert each element of a range into the tree.</p>
<p><b>Complexity</b>: Insert range is in general O(N * log(N)), where N is the size of the range. However, it is linear in N if the range is already sorted by <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#ab0fb164ae8bfc5101465d20b9f2ceb04">value_comp()</a>.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: Does not affect the validity of iterators and references. No copy-constructors are called. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00579">579</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4f8c54f87c95cc5a95a79a263fa261cc"></a><!-- doxytag: member="boost::intrusive::avltree_impl::insert_unique_check" ref="a4f8c54f87c95cc5a95a79a263fa261cc" args="(const_iterator hint, const KeyType &amp;key, KeyValueCompare key_value_comp, insert_commit_data &amp;commit_data)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
<div class="memtemplate">
template&lt;class KeyType , class KeyValueCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>, bool&gt; <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::insert_unique_check </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a>&#160;</td>
          <td class="paramname"> <em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyValueCompare&#160;</td>
          <td class="paramname"> <em>key_value_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">insert_commit_data &amp;&#160;</td>
          <td class="paramname"> <em>commit_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: key_value_comp must be a comparison function that induces the same strict weak ordering as value_compare. The difference is that key_value_comp compares an arbitrary key with the contained values.</p>
<p><b>Effects</b>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself, using "hint" as a hint to where it will be inserted.</p>
<p><b>Returns</b>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</p>
<p><b>Complexity</b>: Logarithmic in general, but it's amortized constant time if t is inserted immediately before hint.</p>
<p><b>Throws</b>: If the key_value_comp ordering function throws. Strong guarantee.</p>
<p><b>Notes</b>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the constructing that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that key to check if the insertion will be successful.</p>
<p>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This can give a total constant-time complexity to the insertion: check(O(1)) + commit(O(1)).</p>
<p>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00668">668</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a64b983d4a40e14b88215ae66975535ec"></a><!-- doxytag: member="boost::intrusive::avltree_impl::insert_unique_check" ref="a64b983d4a40e14b88215ae66975535ec" args="(const KeyType &amp;key, KeyValueCompare key_value_comp, insert_commit_data &amp;commit_data)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
<div class="memtemplate">
template&lt;class KeyType , class KeyValueCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>, bool&gt; <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::insert_unique_check </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyValueCompare&#160;</td>
          <td class="paramname"> <em>key_value_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">insert_commit_data &amp;&#160;</td>
          <td class="paramname"> <em>commit_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: key_value_comp must be a comparison function that induces the same strict weak ordering as value_compare. The difference is that key_value_comp compares an arbitrary key with the contained values.</p>
<p><b>Effects</b>: Checks if a value can be inserted in the container, using a user provided key instead of the value itself.</p>
<p><b>Returns</b>: If there is an equivalent value returns a pair containing an iterator to the already present value and false. If the value can be inserted returns true in the returned pair boolean and fills "commit_data" that is meant to be used with the "insert_commit" function.</p>
<p><b>Complexity</b>: Average complexity is at most logarithmic.</p>
<p><b>Throws</b>: If the key_value_comp ordering function throws. Strong guarantee.</p>
<p><b>Notes</b>: This function is used to improve performance when constructing a value_type is expensive: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the value_type and this function offers the possibility to use that part to check if the insertion will be successful.</p>
<p>If the check is successful, the user can construct the value_type and use "insert_commit" to insert the object in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</p>
<p>"commit_data" remains valid for a subsequent "insert_commit" only if no more objects are inserted or erased from the container. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00624">624</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a76f86838608dbca472b3ddf025ba2404"></a><!-- doxytag: member="boost::intrusive::avltree_impl::insert_unique_commit" ref="a76f86838608dbca472b3ddf025ba2404" args="(reference value, const insert_commit_data &amp;commit_data)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::insert_unique_commit </td>
          <td>(</td>
          <td class="paramtype">reference&#160;</td>
          <td class="paramname"> <em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const insert_commit_data &amp;&#160;</td>
          <td class="paramname"> <em>commit_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: value must be an lvalue of type value_type. commit_data must have been obtained from a previous call to "insert_check". No objects should have been inserted or erased from the container between the "insert_check" that filled "commit_data" and the call to "insert_commit".</p>
<p><b>Effects</b>: Inserts the value in the <a class="el" href="classboost_1_1intrusive_1_1avl__set.html">avl_set</a> using the information obtained from the "commit_data" that a previous "insert_check" filled.</p>
<p><b>Returns</b>: An iterator to the newly inserted object.</p>
<p><b>Complexity</b>: Constant time.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Notes</b>: This function has only sense if a "insert_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00696">696</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acc3336eedf33bb380199530c7708adfa"></a><!-- doxytag: member="boost::intrusive::avltree_impl::iterator_to" ref="acc3336eedf33bb380199530c7708adfa" args="(const_reference value) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::iterator_to </td>
          <td>(</td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"> <em>value</em>&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</p>
<p><b>Effects</b>: Returns: a valid const_iterator i belonging to the set that points to the value</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l01333">1333</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a91363086150e5f7d72b27598571261c2"></a><!-- doxytag: member="boost::intrusive::avltree_impl::iterator_to" ref="a91363086150e5f7d72b27598571261c2" args="(reference value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::iterator_to </td>
          <td>(</td>
          <td class="paramtype">reference&#160;</td>
          <td class="paramname"> <em>value</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</p>
<p><b>Effects</b>: Returns: a valid iterator i belonging to the set that points to the value</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l01321">1321</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abb6b230dd4cce43de0e4ed9d301b2ca6"></a><!-- doxytag: member="boost::intrusive::avltree_impl::lower_bound" ref="abb6b230dd4cce43de0e4ed9d301b2ca6" args="(const_reference value) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"> <em>value</em>&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns an iterator to the first element whose key is not less than k or <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a17d718ce900a21673a85003e5c0b74ad">end()</a> if that element does not exist.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l01014">1014</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac3b40d6e841ac8fc7bb0c1a087564170"></a><!-- doxytag: member="boost::intrusive::avltree_impl::lower_bound" ref="ac3b40d6e841ac8fc7bb0c1a087564170" args="(const KeyType &amp;key, KeyValueCompare comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
<div class="memtemplate">
template&lt;class KeyType , class KeyValueCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyValueCompare&#160;</td>
          <td class="paramname"> <em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns an iterator to the first element whose key is not less than k or <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a17d718ce900a21673a85003e5c0b74ad">end()</a> if that element does not exist.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l01024">1024</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4ec8b654a35d57c29930ee345afa0d64"></a><!-- doxytag: member="boost::intrusive::avltree_impl::lower_bound" ref="a4ec8b654a35d57c29930ee345afa0d64" args="(const_reference value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"> <em>value</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns an iterator to the first element whose key is not less than k or <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a17d718ce900a21673a85003e5c0b74ad">end()</a> if that element does not exist.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l01005">1005</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8c7c556ec41bfbe57974c35c8792071f"></a><!-- doxytag: member="boost::intrusive::avltree_impl::lower_bound" ref="a8c7c556ec41bfbe57974c35c8792071f" args="(const KeyType &amp;key, KeyValueCompare comp) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
<div class="memtemplate">
template&lt;class KeyType , class KeyValueCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyValueCompare&#160;</td>
          <td class="paramname"> <em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns a const iterator to the first element whose key is not less than k or <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a17d718ce900a21673a85003e5c0b74ad">end()</a> if that element does not exist.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l01039">1039</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac1f9966d63f6fa6d03154e3afb8cf6fa"></a><!-- doxytag: member="boost::intrusive::avltree_impl::push_back" ref="ac1f9966d63f6fa6d03154e3afb8cf6fa" args="(reference value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">reference&#160;</td>
          <td class="paramname"> <em>value</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: value must be an lvalue, and it must be no less than the greatest inserted key</p>
<p><b>Effects</b>: Inserts x into the tree in the last position.</p>
<p><b>Complexity</b>: Constant time.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: This function does not check preconditions so if value is less than the greatest inserted key tree ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00745">745</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a778c7cbf58f80cef0acb8914d7bbc3c5"></a><!-- doxytag: member="boost::intrusive::avltree_impl::push_front" ref="a778c7cbf58f80cef0acb8914d7bbc3c5" args="(reference value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">reference&#160;</td>
          <td class="paramname"> <em>value</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: value must be an lvalue, and it must be no greater than the minimum inserted key</p>
<p><b>Effects</b>: Inserts x into the tree in the first position.</p>
<p><b>Complexity</b>: Constant time.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: This function does not check preconditions so if value is greater than the minimum inserted key tree ordering invariant will be broken. This function is slightly more efficient than using "insert_before". This is a low-level function to be used only for performance reasons by advanced users. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00768">768</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af6dc87271ceea0b98457599785710671"></a><!-- doxytag: member="boost::intrusive::avltree_impl::rbegin" ref="af6dc87271ceea0b98457599785710671" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns a reverse_iterator pointing to the beginning of the reversed tree.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00308">308</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a79984e36f93e447e9236fbb132867f1f"></a><!-- doxytag: member="boost::intrusive::avltree_impl::rbegin" ref="a79984e36f93e447e9236fbb132867f1f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::rbegin </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns a const_reverse_iterator pointing to the beginning of the reversed tree.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00317">317</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a99b540f6edbb65bc2b476cb5583a8ebb"></a><!-- doxytag: member="boost::intrusive::avltree_impl::rend" ref="a99b540f6edbb65bc2b476cb5583a8ebb" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">reverse_iterator <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::rend </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns a reverse_iterator pointing to the end of the reversed tree.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00335">335</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad82236b0d8c19f45e5997e755ce097d2"></a><!-- doxytag: member="boost::intrusive::avltree_impl::rend" ref="ad82236b0d8c19f45e5997e755ce097d2" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_reverse_iterator <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::rend </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns a const_reverse_iterator pointing to the end of the reversed tree.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00344">344</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afce130f92188c54aca3059cea80d5c2f"></a><!-- doxytag: member="boost::intrusive::avltree_impl::replace_node" ref="afce130f92188c54aca3059cea80d5c2f" args="(iterator replace_this, reference with_this)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::replace_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a>&#160;</td>
          <td class="paramname"> <em>replace_this</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">reference&#160;</td>
          <td class="paramname"> <em>with_this</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: replace_this must be a valid iterator of *this and with_this must not be inserted in any tree.</p>
<p><b>Effects</b>: Replaces replace_this in its position in the tree with with_this. The tree does not need to be rebalanced.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: This function will break container ordering invariants if with_this is not equivalent to *replace_this according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l01269">1269</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afb018ce99baee9309d1cc3cd2674332b"></a><!-- doxytag: member="boost::intrusive::avltree_impl::s_iterator_to" ref="afb018ce99baee9309d1cc3cd2674332b" args="(reference value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::s_iterator_to </td>
          <td>(</td>
          <td class="paramtype">reference&#160;</td>
          <td class="paramname"> <em>value</em>&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</p>
<p><b>Effects</b>: Returns: a valid iterator i belonging to the set that points to the value</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: This static function is available only if the <em>value traits</em> is stateless. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l01288">1288</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abdc5a0a2666256d47b0ea1119f79f823"></a><!-- doxytag: member="boost::intrusive::avltree_impl::s_iterator_to" ref="abdc5a0a2666256d47b0ea1119f79f823" args="(const_reference value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::s_iterator_to </td>
          <td>(</td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"> <em>value</em>&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: value must be an lvalue and shall be in a set of appropriate type. Otherwise the behavior is undefined.</p>
<p><b>Effects</b>: Returns: a valid const_iterator i belonging to the set that points to the value</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: This static function is available only if the <em>value traits</em> is stateless. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l01306">1306</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a05a9d1f05beb7143e4b134db4354861e"></a><!-- doxytag: member="boost::intrusive::avltree_impl::size" ref="a05a9d1f05beb7143e4b134db4354861e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_type <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::size </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns the number of elements stored in the tree.</p>
<p><b>Complexity</b>: Linear to elements contained in *this if constant-time size option is disabled. Constant time otherwise.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00422">422</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5a0b4f80148d891b591e63eacd79ddfa"></a><!-- doxytag: member="boost::intrusive::avltree_impl::swap" ref="a5a0b4f80148d891b591e63eacd79ddfa" args="(avltree_impl &amp;other)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">avltree_impl</a>&lt; Config &gt; &amp;&#160;</td>
          <td class="paramname"> <em>other</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Swaps the contents of two avltrees.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: If the comparison functor's swap call throws. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00436">436</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeb3c5629a490934e732a271c8a910367"></a><!-- doxytag: member="boost::intrusive::avltree_impl::unlink_leftmost_without_rebalance" ref="aeb3c5629a490934e732a271c8a910367" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">pointer <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::unlink_leftmost_without_rebalance </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Unlinks the leftmost node from the tree.</p>
<p><b>Complexity</b>: Average complexity is constant time.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Notes</b>: This function breaks the tree and the tree can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the tree. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l01243">1243</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad4bc805f83c366672291eaf56946ccd3"></a><!-- doxytag: member="boost::intrusive::avltree_impl::upper_bound" ref="ad4bc805f83c366672291eaf56946ccd3" args="(const KeyType &amp;key, KeyValueCompare comp) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
<div class="memtemplate">
template&lt;class KeyType , class KeyValueCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyValueCompare&#160;</td>
          <td class="paramname"> <em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns an iterator to the first element whose key is greater than k according to comp or <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a17d718ce900a21673a85003e5c0b74ad">end()</a> if that element does not exist.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l01089">1089</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aef47e494d5ab7385a98efa88f786a673"></a><!-- doxytag: member="boost::intrusive::avltree_impl::upper_bound" ref="aef47e494d5ab7385a98efa88f786a673" args="(const KeyType &amp;key, KeyValueCompare comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
<div class="memtemplate">
template&lt;class KeyType , class KeyValueCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyValueCompare&#160;</td>
          <td class="paramname"> <em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns an iterator to the first element whose key is greater than k according to comp or <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a17d718ce900a21673a85003e5c0b74ad">end()</a> if that element does not exist.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l01064">1064</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2c38a0f22cca065690fef9089afa0719"></a><!-- doxytag: member="boost::intrusive::avltree_impl::upper_bound" ref="a2c38a0f22cca065690fef9089afa0719" args="(const_reference value) const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">const_iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"> <em>value</em>&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns an iterator to the first element whose key is greater than k or <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a17d718ce900a21673a85003e5c0b74ad">end()</a> if that element does not exist.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l01078">1078</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acfb59e39ed58efb6934292e7d0f1438e"></a><!-- doxytag: member="boost::intrusive::avltree_impl::upper_bound" ref="acfb59e39ed58efb6934292e7d0f1438e" args="(const_reference value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1intrusive_1_1tree__iterator.html">iterator</a> <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const_reference&#160;</td>
          <td class="paramname"> <em>value</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns an iterator to the first element whose key is greater than k or <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html#a17d718ce900a21673a85003e5c0b74ad">end()</a> if that element does not exist.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l01053">1053</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab0fb164ae8bfc5101465d20b9f2ceb04"></a><!-- doxytag: member="boost::intrusive::avltree_impl::value_comp" ref="ab0fb164ae8bfc5101465d20b9f2ceb04" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Config &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">value_compare <a class="el" href="classboost_1_1intrusive_1_1avltree__impl.html">boost::intrusive::avltree_impl</a>&lt; Config &gt;::value_comp </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns the value_compare object used by the tree.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: If value_compare copy-constructor throws. </p>

<p>Definition at line <a class="el" href="avltree_8hpp_source.html#l00405">405</a> of file <a class="el" href="avltree_8hpp_source.html">avltree.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="avltree_8hpp_source.html">avltree.hpp</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Apr 27 2011 00:50:17 for Nutcracker by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
