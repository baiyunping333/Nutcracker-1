<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nutcracker: tree_algorithms.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>tree_algorithms.hpp</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00002"></a>00002 <span class="comment">//</span>
<a name="l00003"></a>00003 <span class="comment">// (C) Copyright Ion Gaztanaga  2007.</span>
<a name="l00004"></a>00004 <span class="comment">//</span>
<a name="l00005"></a>00005 <span class="comment">// Distributed under the Boost Software License, Version 1.0.</span>
<a name="l00006"></a>00006 <span class="comment">//    (See accompanying file LICENSE_1_0.txt or copy at</span>
<a name="l00007"></a>00007 <span class="comment">//          http://www.boost.org/LICENSE_1_0.txt)</span>
<a name="l00008"></a>00008 <span class="comment">//</span>
<a name="l00009"></a>00009 <span class="comment">// See http://www.boost.org/libs/intrusive for documentation.</span>
<a name="l00010"></a>00010 <span class="comment">//</span>
<a name="l00012"></a>00012 <span class="comment"></span>
<a name="l00013"></a>00013 <span class="preprocessor">#ifndef BOOST_INTRUSIVE_TREE_ALGORITHMS_HPP</span>
<a name="l00014"></a>00014 <span class="preprocessor"></span><span class="preprocessor">#define BOOST_INTRUSIVE_TREE_ALGORITHMS_HPP</span>
<a name="l00015"></a>00015 <span class="preprocessor"></span>
<a name="l00016"></a>00016 <span class="preprocessor">#include &lt;boost/intrusive/detail/config_begin.hpp&gt;</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;boost/intrusive/detail/assert.hpp&gt;</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;boost/intrusive/intrusive_fwd.hpp&gt;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;cstddef&gt;</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;boost/intrusive/detail/utilities.hpp&gt;</span>
<a name="l00021"></a>00021 <span class="comment">//iG pending #include &lt;boost/pointer_cast.hpp&gt;</span>
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="keyword">namespace </span>boost {
<a name="l00024"></a>00024 <span class="keyword">namespace </span>intrusive {
<a name="l00025"></a>00025 <span class="keyword">namespace </span>detail {
<a name="l00026"></a>00026 
<a name="l00069"></a>00069 
<a name="l00095"></a>00095 <span class="keyword">template</span>&lt;<span class="keyword">class</span> NodeTraits&gt;
<a name="l00096"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html">00096</a> <span class="keyword">class </span><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html">tree_algorithms</a>
<a name="l00097"></a>00097 {
<a name="l00098"></a>00098    <span class="keyword">public</span>:
<a name="l00099"></a>00099    <span class="keyword">typedef</span> <span class="keyword">typename</span> NodeTraits::node            node;
<a name="l00100"></a>00100    <span class="keyword">typedef</span> NodeTraits                           node_traits;
<a name="l00101"></a>00101    <span class="keyword">typedef</span> <span class="keyword">typename</span> NodeTraits::node_ptr        node_ptr;
<a name="l00102"></a>00102    <span class="keyword">typedef</span> <span class="keyword">typename</span> NodeTraits::const_node_ptr  const_node_ptr;
<a name="l00103"></a>00103 
<a name="l00105"></a><a class="code" href="structboost_1_1intrusive_1_1detail_1_1tree__algorithms_1_1insert__commit__data.html">00105</a>    <span class="keyword">struct </span><a class="code" href="structboost_1_1intrusive_1_1detail_1_1tree__algorithms_1_1insert__commit__data.html" title="This type is the information that will be filled by insert_unique_check.">insert_commit_data</a>
<a name="l00106"></a>00106    {
<a name="l00107"></a>00107       <a class="code" href="structboost_1_1intrusive_1_1detail_1_1tree__algorithms_1_1insert__commit__data.html" title="This type is the information that will be filled by insert_unique_check.">insert_commit_data</a>()
<a name="l00108"></a>00108          :  link_left(<span class="keyword">false</span>)
<a name="l00109"></a>00109          ,  node(0)
<a name="l00110"></a>00110       {}
<a name="l00111"></a>00111       <span class="keywordtype">bool</span>     link_left;
<a name="l00112"></a>00112       node_ptr node;
<a name="l00113"></a>00113    };
<a name="l00114"></a>00114 
<a name="l00115"></a><a class="code" href="structboost_1_1intrusive_1_1detail_1_1tree__algorithms_1_1nop__erase__fixup.html">00115</a>    <span class="keyword">struct </span><a class="code" href="structboost_1_1intrusive_1_1detail_1_1tree__algorithms_1_1nop__erase__fixup.html">nop_erase_fixup</a>
<a name="l00116"></a>00116    {
<a name="l00117"></a>00117       <span class="keywordtype">void</span> operator()(node_ptr, node_ptr){}
<a name="l00118"></a>00118    };
<a name="l00119"></a>00119 
<a name="l00121"></a>00121    <span class="keyword">private</span>:
<a name="l00122"></a>00122    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Disposer&gt;
<a name="l00123"></a>00123    <span class="keyword">struct </span>dispose_subtree_disposer
<a name="l00124"></a>00124    {
<a name="l00125"></a>00125       dispose_subtree_disposer(Disposer &amp;disp, node_ptr subtree)
<a name="l00126"></a>00126          : disposer_(&amp;disp), subtree_(subtree)
<a name="l00127"></a>00127       {}
<a name="l00128"></a>00128 
<a name="l00129"></a>00129       <span class="keywordtype">void</span> release()
<a name="l00130"></a>00130       {  disposer_ = 0;  }
<a name="l00131"></a>00131 
<a name="l00132"></a>00132       ~dispose_subtree_disposer()
<a name="l00133"></a>00133       {
<a name="l00134"></a>00134          <span class="keywordflow">if</span>(disposer_){
<a name="l00135"></a>00135             dispose_subtree(subtree_, *disposer_);
<a name="l00136"></a>00136          }
<a name="l00137"></a>00137       }
<a name="l00138"></a>00138       Disposer *disposer_;
<a name="l00139"></a>00139       node_ptr subtree_;
<a name="l00140"></a>00140    };
<a name="l00141"></a>00141 
<a name="l00142"></a>00142    <span class="keyword">static</span> node_ptr uncast(const_node_ptr ptr)
<a name="l00143"></a>00143    {
<a name="l00144"></a>00144       <span class="keywordflow">return</span> node_ptr(const_cast&lt;node*&gt;(::boost::intrusive::detail::boost_intrusive_get_pointer(ptr)));
<a name="l00145"></a>00145       <span class="comment">//iG pending return node_ptr(boost::const_pointer_cast&lt;node&gt;(ptr));</span>
<a name="l00146"></a>00146    }
<a name="l00148"></a>00148 
<a name="l00149"></a>00149    <span class="keyword">public</span>:
<a name="l00150"></a>00150    <span class="keyword">static</span> node_ptr begin_node(const_node_ptr header)
<a name="l00151"></a>00151    {  <span class="keywordflow">return</span> node_traits::get_left(header);   }
<a name="l00152"></a>00152 
<a name="l00153"></a>00153    <span class="keyword">static</span> node_ptr end_node(const_node_ptr header)
<a name="l00154"></a>00154    {  <span class="keywordflow">return</span> uncast(header);   }
<a name="l00155"></a>00155 
<a name="l00164"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a3122e5511a7e34a27defd69c8c1754ad">00164</a>    <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a3122e5511a7e34a27defd69c8c1754ad">unique</a>(const_node_ptr node)
<a name="l00165"></a>00165    { <span class="keywordflow">return</span> !NodeTraits::get_parent(node); }
<a name="l00166"></a>00166 
<a name="l00167"></a>00167    <span class="keyword">static</span> node_ptr get_header(const_node_ptr node)
<a name="l00168"></a>00168    {
<a name="l00169"></a>00169       node_ptr h = uncast(node);
<a name="l00170"></a>00170       <span class="keywordflow">if</span>(NodeTraits::get_parent(node)){
<a name="l00171"></a>00171          h = NodeTraits::get_parent(node);
<a name="l00172"></a>00172          <span class="keywordflow">while</span>(!is_header(h))
<a name="l00173"></a>00173             h = NodeTraits::get_parent(h);
<a name="l00174"></a>00174       }
<a name="l00175"></a>00175       <span class="keywordflow">return</span> h;
<a name="l00176"></a>00176    }
<a name="l00177"></a>00177 
<a name="l00193"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#ae5c35ee54b82695aef0860195a4e2d44">00193</a>    <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#ae5c35ee54b82695aef0860195a4e2d44">swap_nodes</a>(node_ptr node1, node_ptr node2)
<a name="l00194"></a>00194    {
<a name="l00195"></a>00195       <span class="keywordflow">if</span>(node1 == node2)
<a name="l00196"></a>00196          <span class="keywordflow">return</span>;
<a name="l00197"></a>00197    
<a name="l00198"></a>00198       node_ptr header1(get_header(node1)), header2(get_header(node2));
<a name="l00199"></a>00199       <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#ae5c35ee54b82695aef0860195a4e2d44">swap_nodes</a>(node1, header1, node2, header2);
<a name="l00200"></a>00200    }
<a name="l00201"></a>00201 
<a name="l00217"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a6d460f18d5a5225486d575d03e146c1f">00217</a>    <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#ae5c35ee54b82695aef0860195a4e2d44">swap_nodes</a>(node_ptr node1, node_ptr header1, node_ptr node2, node_ptr header2)
<a name="l00218"></a>00218    {
<a name="l00219"></a>00219       <span class="keywordflow">if</span>(node1 == node2)
<a name="l00220"></a>00220          <span class="keywordflow">return</span>;
<a name="l00221"></a>00221    
<a name="l00222"></a>00222       <span class="comment">//node1 and node2 must not be header nodes </span>
<a name="l00223"></a>00223       <span class="comment">//BOOST_INTRUSIVE_INVARIANT_ASSERT((header1 != node1 &amp;&amp; header2 != node2));</span>
<a name="l00224"></a>00224       <span class="keywordflow">if</span>(header1 != header2){
<a name="l00225"></a>00225          <span class="comment">//Update header1 if necessary</span>
<a name="l00226"></a>00226          <span class="keywordflow">if</span>(node1 == NodeTraits::get_left(header1)){
<a name="l00227"></a>00227             NodeTraits::set_left(header1, node2);
<a name="l00228"></a>00228          }
<a name="l00229"></a>00229 
<a name="l00230"></a>00230          <span class="keywordflow">if</span>(node1 == NodeTraits::get_right(header1)){
<a name="l00231"></a>00231             NodeTraits::set_right(header1, node2);
<a name="l00232"></a>00232          }
<a name="l00233"></a>00233 
<a name="l00234"></a>00234          <span class="keywordflow">if</span>(node1 == NodeTraits::get_parent(header1)){
<a name="l00235"></a>00235             NodeTraits::set_parent(header1, node2);
<a name="l00236"></a>00236          }
<a name="l00237"></a>00237 
<a name="l00238"></a>00238          <span class="comment">//Update header2 if necessary</span>
<a name="l00239"></a>00239          <span class="keywordflow">if</span>(node2 == NodeTraits::get_left(header2)){
<a name="l00240"></a>00240             NodeTraits::set_left(header2, node1);
<a name="l00241"></a>00241          }
<a name="l00242"></a>00242 
<a name="l00243"></a>00243          <span class="keywordflow">if</span>(node2 == NodeTraits::get_right(header2)){
<a name="l00244"></a>00244             NodeTraits::set_right(header2, node1);
<a name="l00245"></a>00245          }
<a name="l00246"></a>00246 
<a name="l00247"></a>00247          <span class="keywordflow">if</span>(node2 == NodeTraits::get_parent(header2)){
<a name="l00248"></a>00248             NodeTraits::set_parent(header2, node1);
<a name="l00249"></a>00249          }
<a name="l00250"></a>00250       }
<a name="l00251"></a>00251       <span class="keywordflow">else</span>{
<a name="l00252"></a>00252          <span class="comment">//If both nodes are from the same tree</span>
<a name="l00253"></a>00253          <span class="comment">//Update header if necessary</span>
<a name="l00254"></a>00254          <span class="keywordflow">if</span>(node1 == NodeTraits::get_left(header1)){
<a name="l00255"></a>00255             NodeTraits::set_left(header1, node2);
<a name="l00256"></a>00256          }
<a name="l00257"></a>00257          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(node2 == NodeTraits::get_left(header2)){
<a name="l00258"></a>00258             NodeTraits::set_left(header2, node1);
<a name="l00259"></a>00259          }
<a name="l00260"></a>00260 
<a name="l00261"></a>00261          <span class="keywordflow">if</span>(node1 == NodeTraits::get_right(header1)){
<a name="l00262"></a>00262             NodeTraits::set_right(header1, node2);
<a name="l00263"></a>00263          }
<a name="l00264"></a>00264          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(node2 == NodeTraits::get_right(header2)){
<a name="l00265"></a>00265             NodeTraits::set_right(header2, node1);
<a name="l00266"></a>00266          }
<a name="l00267"></a>00267 
<a name="l00268"></a>00268          <span class="keywordflow">if</span>(node1 == NodeTraits::get_parent(header1)){
<a name="l00269"></a>00269             NodeTraits::set_parent(header1, node2);
<a name="l00270"></a>00270          }
<a name="l00271"></a>00271          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(node2 == NodeTraits::get_parent(header2)){
<a name="l00272"></a>00272             NodeTraits::set_parent(header2, node1);
<a name="l00273"></a>00273          }
<a name="l00274"></a>00274 
<a name="l00275"></a>00275          <span class="comment">//Adjust data in nodes to be swapped</span>
<a name="l00276"></a>00276          <span class="comment">//so that final link swap works as expected</span>
<a name="l00277"></a>00277          <span class="keywordflow">if</span>(node1 == NodeTraits::get_parent(node2)){
<a name="l00278"></a>00278             NodeTraits::set_parent(node2, node2);
<a name="l00279"></a>00279 
<a name="l00280"></a>00280             <span class="keywordflow">if</span>(node2 == NodeTraits::get_right(node1)){
<a name="l00281"></a>00281                NodeTraits::set_right(node1, node1);
<a name="l00282"></a>00282             }
<a name="l00283"></a>00283             <span class="keywordflow">else</span>{
<a name="l00284"></a>00284                NodeTraits::set_left(node1, node1);
<a name="l00285"></a>00285             }
<a name="l00286"></a>00286          }
<a name="l00287"></a>00287          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(node2 == NodeTraits::get_parent(node1)){
<a name="l00288"></a>00288             NodeTraits::set_parent(node1, node1);
<a name="l00289"></a>00289 
<a name="l00290"></a>00290             <span class="keywordflow">if</span>(node1 == NodeTraits::get_right(node2)){
<a name="l00291"></a>00291                NodeTraits::set_right(node2, node2);
<a name="l00292"></a>00292             }
<a name="l00293"></a>00293             <span class="keywordflow">else</span>{
<a name="l00294"></a>00294                NodeTraits::set_left(node2, node2);
<a name="l00295"></a>00295             }
<a name="l00296"></a>00296          }
<a name="l00297"></a>00297       }
<a name="l00298"></a>00298 
<a name="l00299"></a>00299       <span class="comment">//Now swap all the links</span>
<a name="l00300"></a>00300       node_ptr temp;
<a name="l00301"></a>00301       <span class="comment">//swap left link</span>
<a name="l00302"></a>00302       temp = NodeTraits::get_left(node1);
<a name="l00303"></a>00303       NodeTraits::set_left(node1, NodeTraits::get_left(node2));
<a name="l00304"></a>00304       NodeTraits::set_left(node2, temp);
<a name="l00305"></a>00305       <span class="comment">//swap right link</span>
<a name="l00306"></a>00306       temp = NodeTraits::get_right(node1);
<a name="l00307"></a>00307       NodeTraits::set_right(node1, NodeTraits::get_right(node2));
<a name="l00308"></a>00308       NodeTraits::set_right(node2, temp);
<a name="l00309"></a>00309       <span class="comment">//swap parent link</span>
<a name="l00310"></a>00310       temp = NodeTraits::get_parent(node1);
<a name="l00311"></a>00311       NodeTraits::set_parent(node1, NodeTraits::get_parent(node2));
<a name="l00312"></a>00312       NodeTraits::set_parent(node2, temp);
<a name="l00313"></a>00313 
<a name="l00314"></a>00314       <span class="comment">//Now adjust adjacent nodes for newly inserted node 1</span>
<a name="l00315"></a>00315       <span class="keywordflow">if</span>((temp = NodeTraits::get_left(node1))){
<a name="l00316"></a>00316          NodeTraits::set_parent(temp, node1);
<a name="l00317"></a>00317       }
<a name="l00318"></a>00318       <span class="keywordflow">if</span>((temp = NodeTraits::get_right(node1))){
<a name="l00319"></a>00319          NodeTraits::set_parent(temp, node1);
<a name="l00320"></a>00320       }
<a name="l00321"></a>00321       <span class="keywordflow">if</span>((temp = NodeTraits::get_parent(node1)) &amp;&amp;
<a name="l00322"></a>00322          <span class="comment">//The header has been already updated so avoid it</span>
<a name="l00323"></a>00323          temp != header2){
<a name="l00324"></a>00324          <span class="keywordflow">if</span>(NodeTraits::get_left(temp) == node2){
<a name="l00325"></a>00325             NodeTraits::set_left(temp, node1);
<a name="l00326"></a>00326          }
<a name="l00327"></a>00327          <span class="keywordflow">if</span>(NodeTraits::get_right(temp) == node2){
<a name="l00328"></a>00328             NodeTraits::set_right(temp, node1);
<a name="l00329"></a>00329          }
<a name="l00330"></a>00330       }
<a name="l00331"></a>00331       <span class="comment">//Now adjust adjacent nodes for newly inserted node 2</span>
<a name="l00332"></a>00332       <span class="keywordflow">if</span>((temp = NodeTraits::get_left(node2))){
<a name="l00333"></a>00333          NodeTraits::set_parent(temp, node2);
<a name="l00334"></a>00334       }
<a name="l00335"></a>00335       <span class="keywordflow">if</span>((temp = NodeTraits::get_right(node2))){
<a name="l00336"></a>00336          NodeTraits::set_parent(temp, node2);
<a name="l00337"></a>00337       }
<a name="l00338"></a>00338       <span class="keywordflow">if</span>((temp = NodeTraits::get_parent(node2)) &amp;&amp;
<a name="l00339"></a>00339          <span class="comment">//The header has been already updated so avoid it</span>
<a name="l00340"></a>00340          temp != header1){
<a name="l00341"></a>00341          <span class="keywordflow">if</span>(NodeTraits::get_left(temp) == node1){
<a name="l00342"></a>00342             NodeTraits::set_left(temp, node2);
<a name="l00343"></a>00343          }
<a name="l00344"></a>00344          <span class="keywordflow">if</span>(NodeTraits::get_right(temp) == node1){
<a name="l00345"></a>00345             NodeTraits::set_right(temp, node2);
<a name="l00346"></a>00346          }
<a name="l00347"></a>00347       }
<a name="l00348"></a>00348    }
<a name="l00349"></a>00349 
<a name="l00366"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#afa39bece34175361e604aa053cb176fe">00366</a>    <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#afa39bece34175361e604aa053cb176fe">replace_node</a>(node_ptr node_to_be_replaced, node_ptr new_node)
<a name="l00367"></a>00367    {
<a name="l00368"></a>00368       <span class="keywordflow">if</span>(node_to_be_replaced == new_node)
<a name="l00369"></a>00369          <span class="keywordflow">return</span>;
<a name="l00370"></a>00370       <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#afa39bece34175361e604aa053cb176fe">replace_node</a>(node_to_be_replaced, get_header(node_to_be_replaced), new_node);
<a name="l00371"></a>00371    }
<a name="l00372"></a>00372 
<a name="l00389"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a527daab6b606be96b98f2cee1d7332e7">00389</a>    <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#afa39bece34175361e604aa053cb176fe">replace_node</a>(node_ptr node_to_be_replaced, node_ptr header, node_ptr new_node)
<a name="l00390"></a>00390    {
<a name="l00391"></a>00391       <span class="keywordflow">if</span>(node_to_be_replaced == new_node)
<a name="l00392"></a>00392          <span class="keywordflow">return</span>;
<a name="l00393"></a>00393    
<a name="l00394"></a>00394       <span class="comment">//Update header if necessary</span>
<a name="l00395"></a>00395       <span class="keywordflow">if</span>(node_to_be_replaced == NodeTraits::get_left(header)){
<a name="l00396"></a>00396          NodeTraits::set_left(header, new_node);
<a name="l00397"></a>00397       }
<a name="l00398"></a>00398 
<a name="l00399"></a>00399       <span class="keywordflow">if</span>(node_to_be_replaced == NodeTraits::get_right(header)){
<a name="l00400"></a>00400          NodeTraits::set_right(header, new_node);
<a name="l00401"></a>00401       }
<a name="l00402"></a>00402 
<a name="l00403"></a>00403       <span class="keywordflow">if</span>(node_to_be_replaced == NodeTraits::get_parent(header)){
<a name="l00404"></a>00404          NodeTraits::set_parent(header, new_node);
<a name="l00405"></a>00405       }
<a name="l00406"></a>00406 
<a name="l00407"></a>00407       <span class="comment">//Now set data from the original node</span>
<a name="l00408"></a>00408       node_ptr temp;
<a name="l00409"></a>00409       NodeTraits::set_left(new_node, NodeTraits::get_left(node_to_be_replaced));
<a name="l00410"></a>00410       NodeTraits::set_right(new_node, NodeTraits::get_right(node_to_be_replaced));
<a name="l00411"></a>00411       NodeTraits::set_parent(new_node, NodeTraits::get_parent(node_to_be_replaced));
<a name="l00412"></a>00412 
<a name="l00413"></a>00413       <span class="comment">//Now adjust adjacent nodes for newly inserted node</span>
<a name="l00414"></a>00414       <span class="keywordflow">if</span>((temp = NodeTraits::get_left(new_node))){
<a name="l00415"></a>00415          NodeTraits::set_parent(temp, new_node);
<a name="l00416"></a>00416       }
<a name="l00417"></a>00417       <span class="keywordflow">if</span>((temp = NodeTraits::get_right(new_node))){
<a name="l00418"></a>00418          NodeTraits::set_parent(temp, new_node);
<a name="l00419"></a>00419       }
<a name="l00420"></a>00420       <span class="keywordflow">if</span>((temp = NodeTraits::get_parent(new_node)) &amp;&amp;
<a name="l00421"></a>00421          <span class="comment">//The header has been already updated so avoid it</span>
<a name="l00422"></a>00422          temp != header){
<a name="l00423"></a>00423          <span class="keywordflow">if</span>(NodeTraits::get_left(temp) == node_to_be_replaced){
<a name="l00424"></a>00424             NodeTraits::set_left(temp, new_node);
<a name="l00425"></a>00425          }
<a name="l00426"></a>00426          <span class="keywordflow">if</span>(NodeTraits::get_right(temp) == node_to_be_replaced){
<a name="l00427"></a>00427             NodeTraits::set_right(temp, new_node);
<a name="l00428"></a>00428          }
<a name="l00429"></a>00429       }
<a name="l00430"></a>00430    }
<a name="l00431"></a>00431 
<a name="l00439"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#acd4e8123764a421ddef027f44f24322f">00439</a>    <span class="keyword">static</span> node_ptr <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#acd4e8123764a421ddef027f44f24322f">next_node</a>(node_ptr p)
<a name="l00440"></a>00440    {
<a name="l00441"></a>00441       node_ptr p_right(NodeTraits::get_right(p));
<a name="l00442"></a>00442       <span class="keywordflow">if</span>(p_right){
<a name="l00443"></a>00443          <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a4714649b6fc5ab9290ec47804edb2634">minimum</a>(p_right);
<a name="l00444"></a>00444       }
<a name="l00445"></a>00445       <span class="keywordflow">else</span> {
<a name="l00446"></a>00446          node_ptr x = NodeTraits::get_parent(p);
<a name="l00447"></a>00447          <span class="keywordflow">while</span>(p == NodeTraits::get_right(x)){
<a name="l00448"></a>00448             p = x;
<a name="l00449"></a>00449             x = NodeTraits::get_parent(x);
<a name="l00450"></a>00450          }
<a name="l00451"></a>00451          <span class="keywordflow">return</span> NodeTraits::get_right(p) != x ? x : uncast(p);
<a name="l00452"></a>00452       }
<a name="l00453"></a>00453    }
<a name="l00454"></a>00454 
<a name="l00462"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a031f097c83f885656de39e57d440b9bc">00462</a>    <span class="keyword">static</span> node_ptr <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a031f097c83f885656de39e57d440b9bc">prev_node</a>(node_ptr p)
<a name="l00463"></a>00463    {
<a name="l00464"></a>00464       <span class="keywordflow">if</span>(is_header(p)){
<a name="l00465"></a>00465          <span class="keywordflow">return</span> NodeTraits::get_right(p);
<a name="l00466"></a>00466          <span class="comment">//return maximum(NodeTraits::get_parent(p));</span>
<a name="l00467"></a>00467       }
<a name="l00468"></a>00468       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(NodeTraits::get_left(p)){
<a name="l00469"></a>00469          <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a877e439c124563c571b69528e11a3292">maximum</a>(NodeTraits::get_left(p));
<a name="l00470"></a>00470       }
<a name="l00471"></a>00471       <span class="keywordflow">else</span> {
<a name="l00472"></a>00472          node_ptr x = NodeTraits::get_parent(p);
<a name="l00473"></a>00473          <span class="keywordflow">while</span>(p == NodeTraits::get_left(x)){
<a name="l00474"></a>00474             p = x;
<a name="l00475"></a>00475             x = NodeTraits::get_parent(x);
<a name="l00476"></a>00476          }
<a name="l00477"></a>00477          <span class="keywordflow">return</span> x;
<a name="l00478"></a>00478       }
<a name="l00479"></a>00479    }
<a name="l00480"></a>00480 
<a name="l00488"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a4714649b6fc5ab9290ec47804edb2634">00488</a>    <span class="keyword">static</span> node_ptr <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a4714649b6fc5ab9290ec47804edb2634">minimum</a> (node_ptr p)
<a name="l00489"></a>00489    {
<a name="l00490"></a>00490       <span class="keywordflow">for</span>(node_ptr p_left = NodeTraits::get_left(p)
<a name="l00491"></a>00491          ;p_left
<a name="l00492"></a>00492          ;p_left = NodeTraits::get_left(p)){
<a name="l00493"></a>00493          p = p_left;
<a name="l00494"></a>00494       }
<a name="l00495"></a>00495       <span class="keywordflow">return</span> p;
<a name="l00496"></a>00496    }
<a name="l00497"></a>00497 
<a name="l00505"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a877e439c124563c571b69528e11a3292">00505</a>    <span class="keyword">static</span> node_ptr <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a877e439c124563c571b69528e11a3292">maximum</a>(node_ptr p)
<a name="l00506"></a>00506    {
<a name="l00507"></a>00507       <span class="keywordflow">for</span>(node_ptr p_right = NodeTraits::get_right(p)
<a name="l00508"></a>00508          ;p_right
<a name="l00509"></a>00509          ;p_right = NodeTraits::get_right(p)){
<a name="l00510"></a>00510          p = p_right;
<a name="l00511"></a>00511       }
<a name="l00512"></a>00512       <span class="keywordflow">return</span> p;
<a name="l00513"></a>00513    }
<a name="l00514"></a>00514 
<a name="l00524"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#aa73ad70d186dd1d5fb55973249ddd518">00524</a>    <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#aa73ad70d186dd1d5fb55973249ddd518">init</a>(node_ptr node)
<a name="l00525"></a>00525    {
<a name="l00526"></a>00526       NodeTraits::set_parent(node, node_ptr(0));
<a name="l00527"></a>00527       NodeTraits::set_left(node, node_ptr(0));
<a name="l00528"></a>00528       NodeTraits::set_right(node, node_ptr(0)); 
<a name="l00529"></a>00529    };
<a name="l00530"></a>00530 
<a name="l00536"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a32ee0ad7b0db8edb5b9e6f8372e6c643">00536</a>    <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a32ee0ad7b0db8edb5b9e6f8372e6c643">inited</a>(const_node_ptr node)
<a name="l00537"></a>00537    {
<a name="l00538"></a>00538       <span class="keywordflow">return</span> !NodeTraits::get_parent(node) &amp;&amp; 
<a name="l00539"></a>00539              !NodeTraits::get_left(node)   &amp;&amp;
<a name="l00540"></a>00540              !NodeTraits::get_right(node)  ;
<a name="l00541"></a>00541    };
<a name="l00542"></a>00542 
<a name="l00553"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a7a16e0093a60bb3a643cd83ee83718be">00553</a>    <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a7a16e0093a60bb3a643cd83ee83718be">init_header</a>(node_ptr header)
<a name="l00554"></a>00554    {
<a name="l00555"></a>00555       NodeTraits::set_parent(header, node_ptr(0));
<a name="l00556"></a>00556       NodeTraits::set_left(header, header);
<a name="l00557"></a>00557       NodeTraits::set_right(header, header); 
<a name="l00558"></a>00558    }
<a name="l00559"></a>00559 
<a name="l00571"></a>00571    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Disposer&gt;
<a name="l00572"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a8628c5deba9f2749fe50226077c93d2f">00572</a>    <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a8628c5deba9f2749fe50226077c93d2f">clear_and_dispose</a>(node_ptr header, Disposer disposer)
<a name="l00573"></a>00573    {
<a name="l00574"></a>00574       node_ptr source_root = NodeTraits::get_parent(header);
<a name="l00575"></a>00575       <span class="keywordflow">if</span>(!source_root)
<a name="l00576"></a>00576          <span class="keywordflow">return</span>;
<a name="l00577"></a>00577       dispose_subtree(source_root, disposer);
<a name="l00578"></a>00578       <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a7a16e0093a60bb3a643cd83ee83718be">init_header</a>(header);
<a name="l00579"></a>00579    }
<a name="l00580"></a>00580 
<a name="l00594"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a340f66b7725b1bbcfd143ce3c203a8c7">00594</a>    <span class="keyword">static</span> node_ptr <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a340f66b7725b1bbcfd143ce3c203a8c7">unlink_leftmost_without_rebalance</a>(node_ptr header)
<a name="l00595"></a>00595    {
<a name="l00596"></a>00596       node_ptr leftmost = NodeTraits::get_left(header);
<a name="l00597"></a>00597       <span class="keywordflow">if</span> (leftmost == header)
<a name="l00598"></a>00598          <span class="keywordflow">return</span> node_ptr(0);
<a name="l00599"></a>00599       node_ptr leftmost_parent(NodeTraits::get_parent(leftmost));
<a name="l00600"></a>00600       node_ptr leftmost_right (NodeTraits::get_right(leftmost));
<a name="l00601"></a>00601       <span class="keywordtype">bool</span> is_root = leftmost_parent == header;
<a name="l00602"></a>00602 
<a name="l00603"></a>00603       <span class="keywordflow">if</span> (leftmost_right){
<a name="l00604"></a>00604          NodeTraits::set_parent(leftmost_right, leftmost_parent);
<a name="l00605"></a>00605          NodeTraits::set_left(header, <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a4714649b6fc5ab9290ec47804edb2634">tree_algorithms::minimum</a>(leftmost_right));
<a name="l00606"></a>00606 
<a name="l00607"></a>00607          <span class="keywordflow">if</span> (is_root)
<a name="l00608"></a>00608             NodeTraits::set_parent(header, leftmost_right);
<a name="l00609"></a>00609          <span class="keywordflow">else</span>
<a name="l00610"></a>00610             NodeTraits::set_left(NodeTraits::get_parent(header), leftmost_right);
<a name="l00611"></a>00611       }
<a name="l00612"></a>00612       <span class="keywordflow">else</span> <span class="keywordflow">if</span> (is_root){
<a name="l00613"></a>00613          NodeTraits::set_parent(header, node_ptr(0));
<a name="l00614"></a>00614          NodeTraits::set_left(header,  header);
<a name="l00615"></a>00615          NodeTraits::set_right(header, header);
<a name="l00616"></a>00616       }
<a name="l00617"></a>00617       <span class="keywordflow">else</span>{
<a name="l00618"></a>00618          NodeTraits::set_left(leftmost_parent, node_ptr(0));
<a name="l00619"></a>00619          NodeTraits::set_left(header, leftmost_parent);
<a name="l00620"></a>00620       }
<a name="l00621"></a>00621       <span class="keywordflow">return</span> leftmost;
<a name="l00622"></a>00622    }
<a name="l00623"></a>00623 
<a name="l00631"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a5b9be50c7c0396a44409c3a3eaa3385c">00631</a>    <span class="keyword">static</span> std::size_t <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a5b9be50c7c0396a44409c3a3eaa3385c">count</a>(const_node_ptr subtree)
<a name="l00632"></a>00632    {
<a name="l00633"></a>00633       <span class="keywordflow">if</span>(!subtree) <span class="keywordflow">return</span> 0;
<a name="l00634"></a>00634       std::size_t <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a5b9be50c7c0396a44409c3a3eaa3385c">count</a> = 0;
<a name="l00635"></a>00635       node_ptr p = <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a4714649b6fc5ab9290ec47804edb2634">minimum</a>(uncast(subtree));
<a name="l00636"></a>00636       <span class="keywordtype">bool</span> continue_looping = <span class="keyword">true</span>;
<a name="l00637"></a>00637       <span class="keywordflow">while</span>(continue_looping){
<a name="l00638"></a>00638          ++<a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a5b9be50c7c0396a44409c3a3eaa3385c">count</a>;
<a name="l00639"></a>00639          node_ptr p_right(NodeTraits::get_right(p));
<a name="l00640"></a>00640          <span class="keywordflow">if</span>(p_right){
<a name="l00641"></a>00641             p = <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a4714649b6fc5ab9290ec47804edb2634">minimum</a>(p_right);
<a name="l00642"></a>00642          }
<a name="l00643"></a>00643          <span class="keywordflow">else</span> {
<a name="l00644"></a>00644             <span class="keywordflow">for</span>(;;){
<a name="l00645"></a>00645                node_ptr q;
<a name="l00646"></a>00646                <span class="keywordflow">if</span> (p == subtree){
<a name="l00647"></a>00647                   continue_looping = <span class="keyword">false</span>;
<a name="l00648"></a>00648                   <span class="keywordflow">break</span>;
<a name="l00649"></a>00649                }
<a name="l00650"></a>00650                q = p;
<a name="l00651"></a>00651                p = NodeTraits::get_parent(p);
<a name="l00652"></a>00652                <span class="keywordflow">if</span> (NodeTraits::get_left(p) == q)
<a name="l00653"></a>00653                   <span class="keywordflow">break</span>;
<a name="l00654"></a>00654             }
<a name="l00655"></a>00655          }
<a name="l00656"></a>00656       }
<a name="l00657"></a>00657       <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a5b9be50c7c0396a44409c3a3eaa3385c">count</a>;
<a name="l00658"></a>00658    }
<a name="l00659"></a>00659 
<a name="l00667"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a9afd10f97cdb33df1a419fb57235058d">00667</a>    <span class="keyword">static</span> std::size_t <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a9afd10f97cdb33df1a419fb57235058d">size</a>(const_node_ptr header)
<a name="l00668"></a>00668    {
<a name="l00669"></a>00669       node_ptr beg(begin_node(header));
<a name="l00670"></a>00670       node_ptr end(end_node(header));
<a name="l00671"></a>00671       std::size_t i = 0;
<a name="l00672"></a>00672       <span class="keywordflow">for</span>(;beg != end; beg = <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#acd4e8123764a421ddef027f44f24322f">next_node</a>(beg)) ++i;
<a name="l00673"></a>00673       <span class="keywordflow">return</span> i;
<a name="l00674"></a>00674    }
<a name="l00675"></a>00675 
<a name="l00685"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a1f75d15af7cb9d281e0181bbe50bc7d1">00685</a>    <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a1f75d15af7cb9d281e0181bbe50bc7d1">swap_tree</a>(node_ptr header1, node_ptr header2)
<a name="l00686"></a>00686    {
<a name="l00687"></a>00687       <span class="keywordflow">if</span>(header1 == header2)
<a name="l00688"></a>00688          <span class="keywordflow">return</span>;
<a name="l00689"></a>00689    
<a name="l00690"></a>00690       node_ptr tmp;
<a name="l00691"></a>00691 
<a name="l00692"></a>00692       <span class="comment">//Parent swap</span>
<a name="l00693"></a>00693       tmp = NodeTraits::get_parent(header1);
<a name="l00694"></a>00694       NodeTraits::set_parent(header1, NodeTraits::get_parent(header2));
<a name="l00695"></a>00695       NodeTraits::set_parent(header2, tmp);
<a name="l00696"></a>00696       <span class="comment">//Left swap</span>
<a name="l00697"></a>00697       tmp = NodeTraits::get_left(header1);
<a name="l00698"></a>00698       NodeTraits::set_left(header1, NodeTraits::get_left(header2));
<a name="l00699"></a>00699       NodeTraits::set_left(header2, tmp);
<a name="l00700"></a>00700       <span class="comment">//Right swap</span>
<a name="l00701"></a>00701       tmp = NodeTraits::get_right(header1);
<a name="l00702"></a>00702       NodeTraits::set_right(header1, NodeTraits::get_right(header2));
<a name="l00703"></a>00703       NodeTraits::set_right(header2, tmp);
<a name="l00704"></a>00704 
<a name="l00705"></a>00705       <span class="comment">//Now test parent</span>
<a name="l00706"></a>00706       node_ptr h1_parent(NodeTraits::get_parent(header1));
<a name="l00707"></a>00707       <span class="keywordflow">if</span>(h1_parent){
<a name="l00708"></a>00708          NodeTraits::set_parent(h1_parent, header1);
<a name="l00709"></a>00709       }
<a name="l00710"></a>00710       <span class="keywordflow">else</span>{
<a name="l00711"></a>00711          NodeTraits::set_left(header1, header1);
<a name="l00712"></a>00712          NodeTraits::set_right(header1, header1);
<a name="l00713"></a>00713       }
<a name="l00714"></a>00714 
<a name="l00715"></a>00715       node_ptr h2_parent(NodeTraits::get_parent(header2));
<a name="l00716"></a>00716       <span class="keywordflow">if</span>(h2_parent){
<a name="l00717"></a>00717          NodeTraits::set_parent(h2_parent, header2);
<a name="l00718"></a>00718       }
<a name="l00719"></a>00719       <span class="keywordflow">else</span>{
<a name="l00720"></a>00720          NodeTraits::set_left(header2, header2);
<a name="l00721"></a>00721          NodeTraits::set_right(header2, header2);
<a name="l00722"></a>00722       }
<a name="l00723"></a>00723    }
<a name="l00724"></a>00724 
<a name="l00725"></a>00725    <span class="keyword">static</span> <span class="keywordtype">bool</span> is_header(const_node_ptr p)
<a name="l00726"></a>00726    {
<a name="l00727"></a>00727       node_ptr p_left (NodeTraits::get_left(p));
<a name="l00728"></a>00728       node_ptr p_right(NodeTraits::get_right(p));
<a name="l00729"></a>00729       <span class="keywordflow">if</span>(!NodeTraits::get_parent(p) || <span class="comment">//Header condition when empty tree</span>
<a name="l00730"></a>00730          (p_left &amp;&amp; p_right &amp;&amp;         <span class="comment">//Header always has leftmost and rightmost</span>
<a name="l00731"></a>00731             (p_left == p_right ||      <span class="comment">//Header condition when only node</span>
<a name="l00732"></a>00732                (NodeTraits::get_parent(p_left)  != p ||
<a name="l00733"></a>00733                 NodeTraits::get_parent(p_right) != p ))
<a name="l00734"></a>00734                <span class="comment">//When tree size &gt; 1 headers can&#39;t be leftmost&#39;s</span>
<a name="l00735"></a>00735                <span class="comment">//and rightmost&#39;s parent </span>
<a name="l00736"></a>00736           )){
<a name="l00737"></a>00737          <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00738"></a>00738       }
<a name="l00739"></a>00739       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00740"></a>00740    }
<a name="l00741"></a>00741 
<a name="l00753"></a>00753    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyNodePtrCompare&gt;
<a name="l00754"></a>00754    <span class="keyword">static</span> node_ptr <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a82756911cef90a5e505eb111183b03c9">find</a>
<a name="l00755"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a82756911cef90a5e505eb111183b03c9">00755</a>       (const_node_ptr header, <span class="keyword">const</span> KeyType &amp;key, KeyNodePtrCompare comp)
<a name="l00756"></a>00756    {
<a name="l00757"></a>00757       node_ptr end = uncast(header);
<a name="l00758"></a>00758       node_ptr y = <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a5aabed119755edc8ac85158ebdcdb72d">lower_bound</a>(header, key, comp);
<a name="l00759"></a>00759       <span class="keywordflow">return</span> (y == end || comp(key, y)) ? end : y;
<a name="l00760"></a>00760    }
<a name="l00761"></a>00761 
<a name="l00775"></a>00775    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyNodePtrCompare&gt;
<a name="l00776"></a>00776    <span class="keyword">static</span> std::pair&lt;node_ptr, node_ptr&gt; <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a8e9155155f438805fc71edcc9c88e9d2">equal_range</a>
<a name="l00777"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a8e9155155f438805fc71edcc9c88e9d2">00777</a>       (const_node_ptr header, <span class="keyword">const</span> KeyType &amp;key, KeyNodePtrCompare comp)
<a name="l00778"></a>00778    {
<a name="l00779"></a>00779       node_ptr y = uncast(header);
<a name="l00780"></a>00780       node_ptr x = NodeTraits::get_parent(header);
<a name="l00781"></a>00781 
<a name="l00782"></a>00782       <span class="keywordflow">while</span>(x){
<a name="l00783"></a>00783          <span class="keywordflow">if</span>(comp(x, key)){
<a name="l00784"></a>00784             x = NodeTraits::get_right(x);
<a name="l00785"></a>00785          }
<a name="l00786"></a>00786          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(comp(key, x)){
<a name="l00787"></a>00787             y = x;
<a name="l00788"></a>00788             x = NodeTraits::get_left(x);
<a name="l00789"></a>00789          }
<a name="l00790"></a>00790          <span class="keywordflow">else</span>{
<a name="l00791"></a>00791             node_ptr xu(x), yu(y);
<a name="l00792"></a>00792             y = x, x = NodeTraits::get_left(x);
<a name="l00793"></a>00793             xu = NodeTraits::get_right(xu);
<a name="l00794"></a>00794 
<a name="l00795"></a>00795             <span class="keywordflow">while</span>(x){
<a name="l00796"></a>00796                <span class="keywordflow">if</span>(comp(x, key)){
<a name="l00797"></a>00797                   x = NodeTraits::get_right(x);
<a name="l00798"></a>00798                }
<a name="l00799"></a>00799                <span class="keywordflow">else</span> {
<a name="l00800"></a>00800                   y = x;
<a name="l00801"></a>00801                   x = NodeTraits::get_left(x);
<a name="l00802"></a>00802                }
<a name="l00803"></a>00803             }
<a name="l00804"></a>00804 
<a name="l00805"></a>00805             <span class="keywordflow">while</span>(xu){
<a name="l00806"></a>00806                <span class="keywordflow">if</span>(comp(key, xu)){
<a name="l00807"></a>00807                   yu = xu;
<a name="l00808"></a>00808                   xu = NodeTraits::get_left(xu);
<a name="l00809"></a>00809                }
<a name="l00810"></a>00810                <span class="keywordflow">else</span> {
<a name="l00811"></a>00811                   xu = NodeTraits::get_right(xu);
<a name="l00812"></a>00812                }
<a name="l00813"></a>00813             }
<a name="l00814"></a>00814             <span class="keywordflow">return</span> std::pair&lt;node_ptr,node_ptr&gt; (y, yu);
<a name="l00815"></a>00815          }
<a name="l00816"></a>00816       }
<a name="l00817"></a>00817       <span class="keywordflow">return</span> std::pair&lt;node_ptr,node_ptr&gt; (y, y);
<a name="l00818"></a>00818    }
<a name="l00819"></a>00819 
<a name="l00832"></a>00832    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyNodePtrCompare&gt;
<a name="l00833"></a>00833    <span class="keyword">static</span> node_ptr <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a5aabed119755edc8ac85158ebdcdb72d">lower_bound</a>
<a name="l00834"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a5aabed119755edc8ac85158ebdcdb72d">00834</a>       (const_node_ptr header, <span class="keyword">const</span> KeyType &amp;key, KeyNodePtrCompare comp)
<a name="l00835"></a>00835    {
<a name="l00836"></a>00836       node_ptr y = uncast(header);
<a name="l00837"></a>00837       node_ptr x = NodeTraits::get_parent(header);
<a name="l00838"></a>00838       <span class="keywordflow">while</span>(x){
<a name="l00839"></a>00839          <span class="keywordflow">if</span>(comp(x, key)){
<a name="l00840"></a>00840             x = NodeTraits::get_right(x);
<a name="l00841"></a>00841          }
<a name="l00842"></a>00842          <span class="keywordflow">else</span> {
<a name="l00843"></a>00843             y = x;
<a name="l00844"></a>00844             x = NodeTraits::get_left(x);
<a name="l00845"></a>00845          }
<a name="l00846"></a>00846       }
<a name="l00847"></a>00847       <span class="keywordflow">return</span> y;
<a name="l00848"></a>00848    }
<a name="l00849"></a>00849 
<a name="l00861"></a>00861    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyNodePtrCompare&gt;
<a name="l00862"></a>00862    <span class="keyword">static</span> node_ptr <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a64c8f8fd573dc1ffc9674863b8dab9c8">upper_bound</a>
<a name="l00863"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a64c8f8fd573dc1ffc9674863b8dab9c8">00863</a>       (const_node_ptr header, <span class="keyword">const</span> KeyType &amp;key, KeyNodePtrCompare comp)
<a name="l00864"></a>00864    {
<a name="l00865"></a>00865       node_ptr y = uncast(header);
<a name="l00866"></a>00866       node_ptr x = NodeTraits::get_parent(header);
<a name="l00867"></a>00867       <span class="keywordflow">while</span>(x){
<a name="l00868"></a>00868          <span class="keywordflow">if</span>(comp(key, x)){
<a name="l00869"></a>00869             y = x;
<a name="l00870"></a>00870             x = NodeTraits::get_left(x);
<a name="l00871"></a>00871          }
<a name="l00872"></a>00872          <span class="keywordflow">else</span> {
<a name="l00873"></a>00873             x = NodeTraits::get_right(x);
<a name="l00874"></a>00874          }
<a name="l00875"></a>00875       }
<a name="l00876"></a>00876       <span class="keywordflow">return</span> y;
<a name="l00877"></a>00877    }
<a name="l00878"></a>00878 
<a name="l00896"></a>00896    <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a13a39de9deb6c6e7b46bdab78e901ae5">insert_unique_commit</a>
<a name="l00897"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a13a39de9deb6c6e7b46bdab78e901ae5">00897</a>       (node_ptr header, node_ptr new_value, <span class="keyword">const</span> <a class="code" href="structboost_1_1intrusive_1_1detail_1_1tree__algorithms_1_1insert__commit__data.html" title="This type is the information that will be filled by insert_unique_check.">insert_commit_data</a> &amp;commit_data)
<a name="l00898"></a>00898    {  <span class="keywordflow">return</span> insert_commit(header, new_value, commit_data); }
<a name="l00899"></a>00899 
<a name="l00900"></a>00900    <span class="keyword">static</span> <span class="keywordtype">void</span> insert_commit
<a name="l00901"></a>00901       (node_ptr header, node_ptr new_node, <span class="keyword">const</span> insert_commit_data &amp;commit_data)
<a name="l00902"></a>00902    {
<a name="l00903"></a>00903       <span class="comment">//Check if commit_data has not been initialized by a insert_unique_check call.</span>
<a name="l00904"></a>00904       BOOST_INTRUSIVE_INVARIANT_ASSERT(commit_data.node != 0);
<a name="l00905"></a>00905       node_ptr parent_node(commit_data.node);
<a name="l00906"></a>00906       <span class="keywordflow">if</span>(parent_node == header){
<a name="l00907"></a>00907          NodeTraits::set_parent(header, new_node);
<a name="l00908"></a>00908          NodeTraits::set_right(header, new_node);
<a name="l00909"></a>00909          NodeTraits::set_left(header, new_node);
<a name="l00910"></a>00910       }
<a name="l00911"></a>00911       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(commit_data.link_left){
<a name="l00912"></a>00912          NodeTraits::set_left(parent_node, new_node);
<a name="l00913"></a>00913          <span class="keywordflow">if</span>(parent_node == NodeTraits::get_left(header))
<a name="l00914"></a>00914              NodeTraits::set_left(header, new_node);
<a name="l00915"></a>00915       }
<a name="l00916"></a>00916       <span class="keywordflow">else</span>{
<a name="l00917"></a>00917          NodeTraits::set_right(parent_node, new_node);
<a name="l00918"></a>00918          <span class="keywordflow">if</span>(parent_node == NodeTraits::get_right(header))
<a name="l00919"></a>00919              NodeTraits::set_right(header, new_node);
<a name="l00920"></a>00920       }
<a name="l00921"></a>00921       NodeTraits::set_parent(new_node, parent_node);
<a name="l00922"></a>00922       NodeTraits::set_right(new_node, node_ptr(0));
<a name="l00923"></a>00923       NodeTraits::set_left(new_node, node_ptr(0));
<a name="l00924"></a>00924    }
<a name="l00925"></a>00925 
<a name="l00960"></a>00960    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyNodePtrCompare&gt;
<a name="l00961"></a>00961    <span class="keyword">static</span> std::pair&lt;node_ptr, bool&gt; <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a182b507c64cbd04241ab9643ec454e67">insert_unique_check</a>
<a name="l00962"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a182b507c64cbd04241ab9643ec454e67">00962</a>       (const_node_ptr header,  <span class="keyword">const</span> KeyType &amp;key
<a name="l00963"></a>00963       ,KeyNodePtrCompare comp, <a class="code" href="structboost_1_1intrusive_1_1detail_1_1tree__algorithms_1_1insert__commit__data.html" title="This type is the information that will be filled by insert_unique_check.">insert_commit_data</a> &amp;commit_data, std::size_t *pdepth = 0)
<a name="l00964"></a>00964    {
<a name="l00965"></a>00965       std::size_t <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a23388346048ca3f041c9ad176f02b8d0">depth</a> = 0;
<a name="l00966"></a>00966       node_ptr h(uncast(header));
<a name="l00967"></a>00967       node_ptr y(h);
<a name="l00968"></a>00968       node_ptr x(NodeTraits::get_parent(y));
<a name="l00969"></a>00969       node_ptr prev(0);
<a name="l00970"></a>00970 
<a name="l00971"></a>00971       <span class="comment">//Find the upper bound, cache the previous value and if we should</span>
<a name="l00972"></a>00972       <span class="comment">//store it in the left or right node</span>
<a name="l00973"></a>00973       <span class="keywordtype">bool</span> left_child = <span class="keyword">true</span>;
<a name="l00974"></a>00974       <span class="keywordflow">while</span>(x){
<a name="l00975"></a>00975          ++<a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a23388346048ca3f041c9ad176f02b8d0">depth</a>;
<a name="l00976"></a>00976          y = x;
<a name="l00977"></a>00977          x = (left_child = comp(key, x)) ? 
<a name="l00978"></a>00978                NodeTraits::get_left(x) : (prev = y, NodeTraits::get_right(x));
<a name="l00979"></a>00979       }
<a name="l00980"></a>00980 
<a name="l00981"></a>00981       <span class="keywordflow">if</span>(pdepth)  *pdepth = <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a23388346048ca3f041c9ad176f02b8d0">depth</a>;
<a name="l00982"></a>00982 
<a name="l00983"></a>00983       <span class="comment">//Since we&#39;ve found the upper bound there is no other value with the same key if:</span>
<a name="l00984"></a>00984       <span class="comment">//    - There is no previous node</span>
<a name="l00985"></a>00985       <span class="comment">//    - The previous node is less than the key</span>
<a name="l00986"></a>00986       <span class="keywordflow">if</span>(!prev || comp(prev, key)){
<a name="l00987"></a>00987          commit_data.link_left = left_child;
<a name="l00988"></a>00988          commit_data.node      = y;
<a name="l00989"></a>00989          <span class="keywordflow">return</span> std::pair&lt;node_ptr, bool&gt;(node_ptr(), <span class="keyword">true</span>);
<a name="l00990"></a>00990       }
<a name="l00991"></a>00991       <span class="comment">//If the previous value was not less than key, it means that it&#39;s equal</span>
<a name="l00992"></a>00992       <span class="comment">//(because we&#39;ve checked the upper bound)</span>
<a name="l00993"></a>00993       <span class="keywordflow">else</span>{
<a name="l00994"></a>00994          <span class="keywordflow">return</span> std::pair&lt;node_ptr, bool&gt;(prev, <span class="keyword">false</span>);
<a name="l00995"></a>00995       }
<a name="l00996"></a>00996    }
<a name="l00997"></a>00997 
<a name="l00998"></a>00998    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyNodePtrCompare&gt;
<a name="l00999"></a>00999    <span class="keyword">static</span> std::pair&lt;node_ptr, bool&gt; <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a182b507c64cbd04241ab9643ec454e67">insert_unique_check</a>
<a name="l01000"></a>01000       (const_node_ptr header,  node_ptr hint, <span class="keyword">const</span> KeyType &amp;key
<a name="l01001"></a>01001       ,KeyNodePtrCompare comp, insert_commit_data &amp;commit_data, std::size_t *pdepth = 0)
<a name="l01002"></a>01002    {
<a name="l01003"></a>01003       <span class="comment">//hint must be bigger than the key</span>
<a name="l01004"></a>01004       <span class="keywordflow">if</span>(hint == header || comp(key, hint)){
<a name="l01005"></a>01005          node_ptr prev(hint);
<a name="l01006"></a>01006          <span class="comment">//Previous value should be less than the key</span>
<a name="l01007"></a>01007          <span class="keywordflow">if</span>(hint == begin_node(header)|| comp((prev = <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a031f097c83f885656de39e57d440b9bc">prev_node</a>(hint)), key)){
<a name="l01008"></a>01008             commit_data.link_left = <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a3122e5511a7e34a27defd69c8c1754ad">unique</a>(header) || !NodeTraits::get_left(hint);
<a name="l01009"></a>01009             commit_data.node      = commit_data.link_left ? hint : prev;
<a name="l01010"></a>01010             <span class="keywordflow">if</span>(pdepth){
<a name="l01011"></a>01011                *pdepth = commit_data.node == header ? 0 : <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a23388346048ca3f041c9ad176f02b8d0">depth</a>(commit_data.node) + 1;
<a name="l01012"></a>01012             }
<a name="l01013"></a>01013             <span class="keywordflow">return</span> std::pair&lt;node_ptr, bool&gt;(node_ptr(), <span class="keyword">true</span>);
<a name="l01014"></a>01014          }
<a name="l01015"></a>01015       }
<a name="l01016"></a>01016       <span class="comment">//Hint was wrong, use hintless insertion</span>
<a name="l01017"></a>01017       <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a182b507c64cbd04241ab9643ec454e67">insert_unique_check</a>(header, key, comp, commit_data, pdepth);
<a name="l01018"></a>01018    }
<a name="l01019"></a>01019 
<a name="l01020"></a>01020    <span class="keyword">template</span>&lt;<span class="keyword">class</span> NodePtrCompare&gt;
<a name="l01021"></a>01021    <span class="keyword">static</span> <span class="keywordtype">void</span> insert_equal_check
<a name="l01022"></a>01022       ( node_ptr header, node_ptr hint, node_ptr new_node, NodePtrCompare comp
<a name="l01023"></a>01023       , insert_commit_data &amp;commit_data, std::size_t *pdepth = 0)
<a name="l01024"></a>01024    {
<a name="l01025"></a>01025       <span class="keywordflow">if</span>(hint == header || !comp(hint, new_node)){
<a name="l01026"></a>01026          node_ptr prev(hint);
<a name="l01027"></a>01027          <span class="keywordflow">if</span>(hint == NodeTraits::get_left(header) || 
<a name="l01028"></a>01028             !comp(new_node, (prev = <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a031f097c83f885656de39e57d440b9bc">prev_node</a>(hint)))){
<a name="l01029"></a>01029             <span class="keywordtype">bool</span> link_left = <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a3122e5511a7e34a27defd69c8c1754ad">unique</a>(header) || !NodeTraits::get_left(hint);
<a name="l01030"></a>01030             commit_data.link_left = link_left;
<a name="l01031"></a>01031             commit_data.node = link_left ? hint : prev;
<a name="l01032"></a>01032             <span class="keywordflow">if</span>(pdepth){
<a name="l01033"></a>01033                *pdepth = commit_data.node == header ? 0 : <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a23388346048ca3f041c9ad176f02b8d0">depth</a>(commit_data.node) + 1;
<a name="l01034"></a>01034             }
<a name="l01035"></a>01035          }
<a name="l01036"></a>01036          <span class="keywordflow">else</span>{
<a name="l01037"></a>01037             insert_equal_upper_bound_check(header, new_node, comp, commit_data, pdepth);
<a name="l01038"></a>01038          }
<a name="l01039"></a>01039       }
<a name="l01040"></a>01040       <span class="keywordflow">else</span>{
<a name="l01041"></a>01041          insert_equal_lower_bound_check(header, new_node, comp, commit_data, pdepth);
<a name="l01042"></a>01042       }
<a name="l01043"></a>01043    }
<a name="l01044"></a>01044 
<a name="l01045"></a>01045    <span class="keyword">template</span>&lt;<span class="keyword">class</span> NodePtrCompare&gt;
<a name="l01046"></a>01046    <span class="keyword">static</span> <span class="keywordtype">void</span> insert_equal_upper_bound_check
<a name="l01047"></a>01047       (node_ptr h, node_ptr new_node, NodePtrCompare comp, insert_commit_data &amp; commit_data, std::size_t *pdepth = 0)
<a name="l01048"></a>01048    {  insert_equal_check_impl(<span class="keyword">true</span>, h, new_node, comp, commit_data, pdepth);  }
<a name="l01049"></a>01049 
<a name="l01050"></a>01050    <span class="keyword">template</span>&lt;<span class="keyword">class</span> NodePtrCompare&gt;
<a name="l01051"></a>01051    <span class="keyword">static</span> <span class="keywordtype">void</span> insert_equal_lower_bound_check
<a name="l01052"></a>01052       (node_ptr h, node_ptr new_node, NodePtrCompare comp, insert_commit_data &amp; commit_data, std::size_t *pdepth = 0)
<a name="l01053"></a>01053    {  insert_equal_check_impl(<span class="keyword">false</span>, h, new_node, comp, commit_data, pdepth);  }
<a name="l01054"></a>01054 
<a name="l01055"></a>01055    <span class="keyword">template</span>&lt;<span class="keyword">class</span> NodePtrCompare&gt;
<a name="l01056"></a>01056    <span class="keyword">static</span> node_ptr insert_equal
<a name="l01057"></a>01057       (node_ptr h, node_ptr hint, node_ptr new_node, NodePtrCompare comp, std::size_t *pdepth = 0)
<a name="l01058"></a>01058    {
<a name="l01059"></a>01059       insert_commit_data commit_data;
<a name="l01060"></a>01060       insert_equal_check(h, hint, new_node, comp, commit_data, pdepth);
<a name="l01061"></a>01061       insert_commit(h, new_node, commit_data);
<a name="l01062"></a>01062       <span class="keywordflow">return</span> new_node;
<a name="l01063"></a>01063    }
<a name="l01064"></a>01064 
<a name="l01065"></a>01065    <span class="keyword">template</span>&lt;<span class="keyword">class</span> NodePtrCompare&gt;
<a name="l01066"></a>01066    <span class="keyword">static</span> node_ptr insert_equal_upper_bound
<a name="l01067"></a>01067       (node_ptr h, node_ptr new_node, NodePtrCompare comp, std::size_t *pdepth = 0)
<a name="l01068"></a>01068    {
<a name="l01069"></a>01069       insert_commit_data commit_data;
<a name="l01070"></a>01070       insert_equal_upper_bound_check(h, new_node, comp, commit_data, pdepth);
<a name="l01071"></a>01071       insert_commit(h, new_node, commit_data);
<a name="l01072"></a>01072       <span class="keywordflow">return</span> new_node;
<a name="l01073"></a>01073    }
<a name="l01074"></a>01074 
<a name="l01075"></a>01075    <span class="keyword">template</span>&lt;<span class="keyword">class</span> NodePtrCompare&gt;
<a name="l01076"></a>01076    <span class="keyword">static</span> node_ptr insert_equal_lower_bound
<a name="l01077"></a>01077       (node_ptr h, node_ptr new_node, NodePtrCompare comp, std::size_t *pdepth = 0)
<a name="l01078"></a>01078    {
<a name="l01079"></a>01079       insert_commit_data commit_data;
<a name="l01080"></a>01080       insert_equal_lower_bound_check(h, new_node, comp, commit_data, pdepth);
<a name="l01081"></a>01081       insert_commit(h, new_node, commit_data);
<a name="l01082"></a>01082       <span class="keywordflow">return</span> new_node;
<a name="l01083"></a>01083    }
<a name="l01084"></a>01084 
<a name="l01085"></a>01085    <span class="keyword">static</span> node_ptr insert_before
<a name="l01086"></a>01086       (node_ptr header, node_ptr pos, node_ptr new_node, std::size_t *pdepth = 0)
<a name="l01087"></a>01087    {
<a name="l01088"></a>01088       insert_commit_data commit_data;
<a name="l01089"></a>01089       insert_before_check(header, pos, commit_data, pdepth);
<a name="l01090"></a>01090       insert_commit(header, new_node, commit_data);
<a name="l01091"></a>01091       <span class="keywordflow">return</span> new_node;
<a name="l01092"></a>01092    }
<a name="l01093"></a>01093 
<a name="l01094"></a>01094    <span class="keyword">static</span> <span class="keywordtype">void</span> insert_before_check
<a name="l01095"></a>01095       ( node_ptr header, node_ptr pos
<a name="l01096"></a>01096       , insert_commit_data &amp;commit_data, std::size_t *pdepth = 0)
<a name="l01097"></a>01097    {
<a name="l01098"></a>01098       node_ptr prev(pos);
<a name="l01099"></a>01099       <span class="keywordflow">if</span>(pos != NodeTraits::get_left(header))
<a name="l01100"></a>01100          prev = <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a031f097c83f885656de39e57d440b9bc">prev_node</a>(pos);
<a name="l01101"></a>01101       <span class="keywordtype">bool</span> link_left = <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a3122e5511a7e34a27defd69c8c1754ad">unique</a>(header) || !NodeTraits::get_left(pos);
<a name="l01102"></a>01102       commit_data.link_left = link_left;
<a name="l01103"></a>01103       commit_data.node = link_left ? pos : prev;
<a name="l01104"></a>01104       <span class="keywordflow">if</span>(pdepth){
<a name="l01105"></a>01105          *pdepth = commit_data.node == header ? 0 : <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a23388346048ca3f041c9ad176f02b8d0">depth</a>(commit_data.node) + 1;
<a name="l01106"></a>01106       }
<a name="l01107"></a>01107    }
<a name="l01108"></a>01108 
<a name="l01109"></a>01109    <span class="keyword">static</span> <span class="keywordtype">void</span> push_back
<a name="l01110"></a>01110       (node_ptr header, node_ptr new_node, std::size_t *pdepth = 0)
<a name="l01111"></a>01111    {
<a name="l01112"></a>01112       insert_commit_data commit_data;
<a name="l01113"></a>01113       push_back_check(header, commit_data, pdepth);
<a name="l01114"></a>01114       insert_commit(header, new_node, commit_data);
<a name="l01115"></a>01115    }
<a name="l01116"></a>01116 
<a name="l01117"></a>01117    <span class="keyword">static</span> <span class="keywordtype">void</span> push_back_check
<a name="l01118"></a>01118       (node_ptr header, insert_commit_data &amp;commit_data, std::size_t *pdepth = 0)
<a name="l01119"></a>01119    {
<a name="l01120"></a>01120       node_ptr prev(NodeTraits::get_right(header));
<a name="l01121"></a>01121       <span class="keywordflow">if</span>(pdepth){
<a name="l01122"></a>01122          *pdepth = prev == header ? 0 : <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a23388346048ca3f041c9ad176f02b8d0">depth</a>(prev) + 1;
<a name="l01123"></a>01123       }
<a name="l01124"></a>01124       commit_data.link_left = <span class="keyword">false</span>;
<a name="l01125"></a>01125       commit_data.node = prev;
<a name="l01126"></a>01126    }
<a name="l01127"></a>01127 
<a name="l01128"></a>01128    <span class="keyword">static</span> <span class="keywordtype">void</span> push_front
<a name="l01129"></a>01129       (node_ptr header, node_ptr new_node, std::size_t *pdepth = 0)
<a name="l01130"></a>01130    {
<a name="l01131"></a>01131       insert_commit_data commit_data;
<a name="l01132"></a>01132       push_front_check(header, commit_data, pdepth);
<a name="l01133"></a>01133       insert_commit(header, new_node, commit_data);
<a name="l01134"></a>01134    }
<a name="l01135"></a>01135 
<a name="l01136"></a>01136    <span class="keyword">static</span> <span class="keywordtype">void</span> push_front_check
<a name="l01137"></a>01137       (node_ptr header, insert_commit_data &amp;commit_data, std::size_t *pdepth = 0)
<a name="l01138"></a>01138    {
<a name="l01139"></a>01139       node_ptr pos(NodeTraits::get_left(header));
<a name="l01140"></a>01140       <span class="keywordflow">if</span>(pdepth){
<a name="l01141"></a>01141          *pdepth = pos == header ? 0 : <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a23388346048ca3f041c9ad176f02b8d0">depth</a>(pos) + 1;
<a name="l01142"></a>01142       }
<a name="l01143"></a>01143       commit_data.link_left = <span class="keyword">true</span>;
<a name="l01144"></a>01144       commit_data.node = pos;
<a name="l01145"></a>01145    }
<a name="l01146"></a>01146 
<a name="l01156"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a23388346048ca3f041c9ad176f02b8d0">01156</a>    <span class="keyword">static</span> std::size_t <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a23388346048ca3f041c9ad176f02b8d0">depth</a>(const_node_ptr p)
<a name="l01157"></a>01157    {
<a name="l01158"></a>01158       std::size_t <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a23388346048ca3f041c9ad176f02b8d0">depth</a> = 0;
<a name="l01159"></a>01159       node_ptr p_parent;
<a name="l01160"></a>01160       <span class="keywordflow">while</span>(p != NodeTraits::get_parent(p_parent = NodeTraits::get_parent(p))){
<a name="l01161"></a>01161          ++<a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a23388346048ca3f041c9ad176f02b8d0">depth</a>;
<a name="l01162"></a>01162          p = p_parent;
<a name="l01163"></a>01163       }
<a name="l01164"></a>01164       <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a23388346048ca3f041c9ad176f02b8d0">depth</a>;
<a name="l01165"></a>01165    }
<a name="l01166"></a>01166 
<a name="l01184"></a>01184    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Cloner, <span class="keyword">class</span> Disposer&gt;
<a name="l01185"></a>01185    <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a61fb855604432c90781212781d45d771">clone</a>
<a name="l01186"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a61fb855604432c90781212781d45d771">01186</a>       (const_node_ptr source_header, node_ptr target_header, Cloner cloner, Disposer disposer)
<a name="l01187"></a>01187    {
<a name="l01188"></a>01188       <span class="keywordflow">if</span>(!<a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a3122e5511a7e34a27defd69c8c1754ad">unique</a>(target_header)){
<a name="l01189"></a>01189          <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a8628c5deba9f2749fe50226077c93d2f">clear_and_dispose</a>(target_header, disposer);
<a name="l01190"></a>01190       }
<a name="l01191"></a>01191 
<a name="l01192"></a>01192       node_ptr leftmost, rightmost;
<a name="l01193"></a>01193       node_ptr new_root = clone_subtree
<a name="l01194"></a>01194          (source_header, target_header, cloner, disposer, leftmost, rightmost);
<a name="l01195"></a>01195 
<a name="l01196"></a>01196       <span class="comment">//Now update header node</span>
<a name="l01197"></a>01197       NodeTraits::set_parent(target_header, new_root);
<a name="l01198"></a>01198       NodeTraits::set_left  (target_header, leftmost);
<a name="l01199"></a>01199       NodeTraits::set_right (target_header, rightmost);
<a name="l01200"></a>01200    }
<a name="l01201"></a>01201 
<a name="l01202"></a>01202    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Cloner, <span class="keyword">class</span> Disposer&gt;
<a name="l01203"></a>01203    <span class="keyword">static</span> node_ptr clone_subtree
<a name="l01204"></a>01204       ( const_node_ptr source_parent,  node_ptr target_parent
<a name="l01205"></a>01205       , Cloner cloner,                 Disposer disposer
<a name="l01206"></a>01206       , node_ptr &amp;leftmost_out,        node_ptr &amp;rightmost_out
<a name="l01207"></a>01207       )
<a name="l01208"></a>01208    {
<a name="l01209"></a>01209       node_ptr target_sub_root = target_parent;
<a name="l01210"></a>01210       node_ptr source_root = NodeTraits::get_parent(source_parent);
<a name="l01211"></a>01211       <span class="keywordflow">if</span>(!source_root){
<a name="l01212"></a>01212          leftmost_out = rightmost_out = source_root;
<a name="l01213"></a>01213       }
<a name="l01214"></a>01214       <span class="keywordflow">else</span>{
<a name="l01215"></a>01215          <span class="comment">//We&#39;ll calculate leftmost and rightmost nodes while iterating</span>
<a name="l01216"></a>01216          node_ptr current = source_root;
<a name="l01217"></a>01217          node_ptr insertion_point = target_sub_root = cloner(current);
<a name="l01218"></a>01218 
<a name="l01219"></a>01219          <span class="comment">//We&#39;ll calculate leftmost and rightmost nodes while iterating</span>
<a name="l01220"></a>01220          node_ptr leftmost  = target_sub_root;
<a name="l01221"></a>01221          node_ptr rightmost = target_sub_root;
<a name="l01222"></a>01222 
<a name="l01223"></a>01223          <span class="comment">//First set the subroot</span>
<a name="l01224"></a>01224          NodeTraits::set_left(target_sub_root, node_ptr(0));
<a name="l01225"></a>01225          NodeTraits::set_right(target_sub_root, node_ptr(0));
<a name="l01226"></a>01226          NodeTraits::set_parent(target_sub_root, target_parent);
<a name="l01227"></a>01227 
<a name="l01228"></a>01228          dispose_subtree_disposer&lt;Disposer&gt; rollback(disposer, target_sub_root);
<a name="l01229"></a>01229          <span class="keywordflow">while</span>(<span class="keyword">true</span>) {
<a name="l01230"></a>01230             <span class="comment">//First clone left nodes</span>
<a name="l01231"></a>01231             <span class="keywordflow">if</span>( NodeTraits::get_left(current) &amp;&amp;
<a name="l01232"></a>01232                !NodeTraits::get_left(insertion_point)) {
<a name="l01233"></a>01233                current = NodeTraits::get_left(current);
<a name="l01234"></a>01234                node_ptr temp = insertion_point;
<a name="l01235"></a>01235                <span class="comment">//Clone and mark as leaf</span>
<a name="l01236"></a>01236                insertion_point = cloner(current);
<a name="l01237"></a>01237                NodeTraits::set_left  (insertion_point, node_ptr(0));
<a name="l01238"></a>01238                NodeTraits::set_right (insertion_point, node_ptr(0));
<a name="l01239"></a>01239                <span class="comment">//Insert left</span>
<a name="l01240"></a>01240                NodeTraits::set_parent(insertion_point, temp);
<a name="l01241"></a>01241                NodeTraits::set_left  (temp, insertion_point);
<a name="l01242"></a>01242                <span class="comment">//Update leftmost</span>
<a name="l01243"></a>01243                <span class="keywordflow">if</span>(rightmost == target_sub_root)
<a name="l01244"></a>01244                   leftmost = insertion_point;
<a name="l01245"></a>01245             }
<a name="l01246"></a>01246             <span class="comment">//Then clone right nodes</span>
<a name="l01247"></a>01247             <span class="keywordflow">else</span> <span class="keywordflow">if</span>( NodeTraits::get_right(current) &amp;&amp; 
<a name="l01248"></a>01248                      !NodeTraits::get_right(insertion_point)){
<a name="l01249"></a>01249                current = NodeTraits::get_right(current);
<a name="l01250"></a>01250                node_ptr temp = insertion_point;
<a name="l01251"></a>01251                <span class="comment">//Clone and mark as leaf</span>
<a name="l01252"></a>01252                insertion_point = cloner(current);
<a name="l01253"></a>01253                NodeTraits::set_left  (insertion_point, node_ptr(0));
<a name="l01254"></a>01254                NodeTraits::set_right (insertion_point, node_ptr(0));
<a name="l01255"></a>01255                <span class="comment">//Insert right</span>
<a name="l01256"></a>01256                NodeTraits::set_parent(insertion_point, temp);
<a name="l01257"></a>01257                NodeTraits::set_right (temp, insertion_point);
<a name="l01258"></a>01258                <span class="comment">//Update rightmost</span>
<a name="l01259"></a>01259                rightmost = insertion_point;
<a name="l01260"></a>01260             }
<a name="l01261"></a>01261             <span class="comment">//If not, go up</span>
<a name="l01262"></a>01262             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(current == source_root){
<a name="l01263"></a>01263                <span class="keywordflow">break</span>;
<a name="l01264"></a>01264             }
<a name="l01265"></a>01265             <span class="keywordflow">else</span>{
<a name="l01266"></a>01266                <span class="comment">//Branch completed, go up searching more nodes to clone</span>
<a name="l01267"></a>01267                current = NodeTraits::get_parent(current);
<a name="l01268"></a>01268                insertion_point = NodeTraits::get_parent(insertion_point);
<a name="l01269"></a>01269             }
<a name="l01270"></a>01270          }
<a name="l01271"></a>01271          rollback.release();
<a name="l01272"></a>01272          leftmost_out   = leftmost;
<a name="l01273"></a>01273          rightmost_out  = rightmost;
<a name="l01274"></a>01274       }
<a name="l01275"></a>01275       <span class="keywordflow">return</span> target_sub_root;
<a name="l01276"></a>01276    }
<a name="l01277"></a>01277 
<a name="l01278"></a>01278    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Disposer&gt;
<a name="l01279"></a>01279    <span class="keyword">static</span> <span class="keywordtype">void</span> dispose_subtree(node_ptr x, Disposer disposer)
<a name="l01280"></a>01280    {
<a name="l01281"></a>01281       node_ptr save;
<a name="l01282"></a>01282       <span class="keywordflow">while</span> (x){
<a name="l01283"></a>01283          save = NodeTraits::get_left(x);
<a name="l01284"></a>01284          <span class="keywordflow">if</span> (save) {
<a name="l01285"></a>01285             <span class="comment">// Right rotation</span>
<a name="l01286"></a>01286             NodeTraits::set_left(x, NodeTraits::get_right(save));
<a name="l01287"></a>01287             NodeTraits::set_right(save, x);
<a name="l01288"></a>01288          }
<a name="l01289"></a>01289          <span class="keywordflow">else</span> {
<a name="l01290"></a>01290             save = NodeTraits::get_right(x);
<a name="l01291"></a>01291             <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#aa73ad70d186dd1d5fb55973249ddd518">init</a>(x);
<a name="l01292"></a>01292             disposer(x);
<a name="l01293"></a>01293          }
<a name="l01294"></a>01294          x = save;
<a name="l01295"></a>01295       }
<a name="l01296"></a>01296    }
<a name="l01297"></a>01297 
<a name="l01305"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a5dac39e7968b060a0b361bca2f69cf34">01305</a>    <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a5dac39e7968b060a0b361bca2f69cf34">is_left_child</a>(node_ptr p)
<a name="l01306"></a>01306    {  <span class="keywordflow">return</span> NodeTraits::get_left(NodeTraits::get_parent(p)) == p;  }
<a name="l01307"></a>01307 
<a name="l01315"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a6363253158a6be8da006ea7f16b1e073">01315</a>    <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a6363253158a6be8da006ea7f16b1e073">is_right_child</a>(node_ptr p)
<a name="l01316"></a>01316    {  <span class="keywordflow">return</span> NodeTraits::get_right(NodeTraits::get_parent(p)) == p;  }
<a name="l01317"></a>01317 
<a name="l01318"></a>01318    <span class="comment">//Fix header and own&#39;s parent data when replacing x with own, providing own&#39;s old data with parent</span>
<a name="l01319"></a>01319    <span class="keyword">static</span> <span class="keywordtype">void</span> replace_own_impl(node_ptr own, node_ptr x, node_ptr header, node_ptr own_parent, <span class="keywordtype">bool</span> own_was_left)
<a name="l01320"></a>01320    {
<a name="l01321"></a>01321       <span class="keywordflow">if</span>(NodeTraits::get_parent(header) == own)
<a name="l01322"></a>01322          NodeTraits::set_parent(header, x);
<a name="l01323"></a>01323       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(own_was_left)
<a name="l01324"></a>01324          NodeTraits::set_left(own_parent, x);
<a name="l01325"></a>01325       <span class="keywordflow">else</span>
<a name="l01326"></a>01326          NodeTraits::set_right(own_parent, x);
<a name="l01327"></a>01327    }
<a name="l01328"></a>01328 
<a name="l01329"></a>01329    <span class="comment">//Fix header and own&#39;s parent data when replacing x with own, supposing own</span>
<a name="l01330"></a>01330    <span class="comment">//links with its parent are still ok</span>
<a name="l01331"></a>01331    <span class="keyword">static</span> <span class="keywordtype">void</span> replace_own(node_ptr own, node_ptr x, node_ptr header)
<a name="l01332"></a>01332    {
<a name="l01333"></a>01333       node_ptr own_parent(NodeTraits::get_parent(own));
<a name="l01334"></a>01334       <span class="keywordtype">bool</span> own_is_left(NodeTraits::get_left(own_parent) == own);
<a name="l01335"></a>01335       replace_own_impl(own, x, header, own_parent, own_is_left);
<a name="l01336"></a>01336    }
<a name="l01337"></a>01337 
<a name="l01338"></a>01338    <span class="comment">// rotate parent p to left (no header and p&#39;s parent fixup)</span>
<a name="l01339"></a>01339    <span class="keyword">static</span> node_ptr rotate_left(node_ptr p)
<a name="l01340"></a>01340    {
<a name="l01341"></a>01341       node_ptr x(NodeTraits::get_right(p));
<a name="l01342"></a>01342       node_ptr x_left(NodeTraits::get_left(x));
<a name="l01343"></a>01343       NodeTraits::set_right(p, x_left);
<a name="l01344"></a>01344       <span class="keywordflow">if</span>(x_left){
<a name="l01345"></a>01345          NodeTraits::set_parent(x_left, p);
<a name="l01346"></a>01346       }
<a name="l01347"></a>01347       NodeTraits::set_left(x, p);
<a name="l01348"></a>01348       NodeTraits::set_parent(p, x);
<a name="l01349"></a>01349       <span class="keywordflow">return</span> x;
<a name="l01350"></a>01350    }
<a name="l01351"></a>01351 
<a name="l01352"></a>01352    <span class="comment">// rotate parent p to left (with header and p&#39;s parent fixup)</span>
<a name="l01353"></a>01353    <span class="keyword">static</span> <span class="keywordtype">void</span> rotate_left(node_ptr p, node_ptr header)
<a name="l01354"></a>01354    {
<a name="l01355"></a>01355       <span class="keywordtype">bool</span>     p_was_left(<a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a5dac39e7968b060a0b361bca2f69cf34">is_left_child</a>(p));
<a name="l01356"></a>01356       node_ptr p_old_parent(NodeTraits::get_parent(p));
<a name="l01357"></a>01357       node_ptr x(rotate_left(p));
<a name="l01358"></a>01358       NodeTraits::set_parent(x, p_old_parent);
<a name="l01359"></a>01359       replace_own_impl(p, x, header, p_old_parent, p_was_left);
<a name="l01360"></a>01360    }
<a name="l01361"></a>01361 
<a name="l01362"></a>01362    <span class="comment">// rotate parent p to right (no header and p&#39;s parent fixup)</span>
<a name="l01363"></a>01363    <span class="keyword">static</span> node_ptr rotate_right(node_ptr p)
<a name="l01364"></a>01364    {
<a name="l01365"></a>01365       node_ptr x(NodeTraits::get_left(p));
<a name="l01366"></a>01366       node_ptr x_right(NodeTraits::get_right(x));
<a name="l01367"></a>01367       NodeTraits::set_left(p, x_right);
<a name="l01368"></a>01368       <span class="keywordflow">if</span>(x_right){
<a name="l01369"></a>01369          NodeTraits::set_parent(x_right, p);
<a name="l01370"></a>01370       }
<a name="l01371"></a>01371       NodeTraits::set_right(x, p);
<a name="l01372"></a>01372       NodeTraits::set_parent(p, x);
<a name="l01373"></a>01373       <span class="keywordflow">return</span> x;
<a name="l01374"></a>01374    }
<a name="l01375"></a>01375 
<a name="l01376"></a>01376    <span class="comment">// rotate parent p to right (with header and p&#39;s parent fixup)</span>
<a name="l01377"></a>01377    <span class="keyword">static</span> <span class="keywordtype">void</span> rotate_right(node_ptr p, node_ptr header)
<a name="l01378"></a>01378    {
<a name="l01379"></a>01379       <span class="keywordtype">bool</span>     p_was_left(<a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a5dac39e7968b060a0b361bca2f69cf34">is_left_child</a>(p));
<a name="l01380"></a>01380       node_ptr p_old_parent(NodeTraits::get_parent(p));
<a name="l01381"></a>01381       node_ptr x(rotate_right(p));
<a name="l01382"></a>01382       NodeTraits::set_parent(x, p_old_parent);
<a name="l01383"></a>01383       replace_own_impl(p, x, header, p_old_parent, p_was_left);
<a name="l01384"></a>01384    }
<a name="l01385"></a>01385 
<a name="l01386"></a>01386    <span class="keyword">static</span> <span class="keywordtype">void</span> erase(node_ptr header, node_ptr z)
<a name="l01387"></a>01387    {
<a name="l01388"></a>01388       data_for_rebalance ignored;
<a name="l01389"></a>01389       erase_impl(header, z, ignored);
<a name="l01390"></a>01390    }
<a name="l01391"></a>01391 
<a name="l01392"></a><a class="code" href="structboost_1_1intrusive_1_1detail_1_1tree__algorithms_1_1data__for__rebalance.html">01392</a>    <span class="keyword">struct </span><a class="code" href="structboost_1_1intrusive_1_1detail_1_1tree__algorithms_1_1data__for__rebalance.html">data_for_rebalance</a>
<a name="l01393"></a>01393    {
<a name="l01394"></a>01394       node_ptr x;
<a name="l01395"></a>01395       node_ptr x_parent;
<a name="l01396"></a>01396       node_ptr y;
<a name="l01397"></a>01397    };
<a name="l01398"></a>01398 
<a name="l01399"></a>01399    <span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;
<a name="l01400"></a>01400    <span class="keyword">static</span> <span class="keywordtype">void</span> erase(node_ptr header, node_ptr z, F z_and_successor_fixup, <a class="code" href="structboost_1_1intrusive_1_1detail_1_1tree__algorithms_1_1data__for__rebalance.html">data_for_rebalance</a> &amp;info)
<a name="l01401"></a>01401    {
<a name="l01402"></a>01402       erase_impl(header, z, info);
<a name="l01403"></a>01403       <span class="keywordflow">if</span>(info.y != z){
<a name="l01404"></a>01404          z_and_successor_fixup(z, info.y);
<a name="l01405"></a>01405       }
<a name="l01406"></a>01406    }
<a name="l01407"></a>01407 
<a name="l01408"></a>01408    <span class="keyword">static</span> <span class="keywordtype">void</span> unlink(node_ptr node)
<a name="l01409"></a>01409    {
<a name="l01410"></a>01410       node_ptr x = NodeTraits::get_parent(node);
<a name="l01411"></a>01411       <span class="keywordflow">if</span>(x){
<a name="l01412"></a>01412          <span class="keywordflow">while</span>(!is_header(x))
<a name="l01413"></a>01413             x = NodeTraits::get_parent(x);
<a name="l01414"></a>01414          erase(x, node);
<a name="l01415"></a>01415       }
<a name="l01416"></a>01416    }
<a name="l01417"></a>01417 
<a name="l01418"></a>01418    <span class="keyword">static</span> <span class="keywordtype">void</span> tree_to_vine(node_ptr header)
<a name="l01419"></a>01419    {  subtree_to_vine(NodeTraits::get_parent(header)); }
<a name="l01420"></a>01420 
<a name="l01421"></a>01421    <span class="keyword">static</span> <span class="keywordtype">void</span> vine_to_tree(node_ptr header, std::size_t <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a5b9be50c7c0396a44409c3a3eaa3385c">count</a>)
<a name="l01422"></a>01422    {  vine_to_subtree(NodeTraits::get_parent(header), count);  }
<a name="l01423"></a>01423 
<a name="l01424"></a>01424    <span class="keyword">static</span> <span class="keywordtype">void</span> rebalance(node_ptr header)
<a name="l01425"></a>01425    {
<a name="l01426"></a>01426       <span class="comment">//Taken from:</span>
<a name="l01427"></a>01427       <span class="comment">//&quot;Tree rebalancing in optimal time and space&quot;</span>
<a name="l01428"></a>01428       <span class="comment">//Quentin F. Stout and Bette L. Warren</span>
<a name="l01429"></a>01429       std::size_t len = 0;
<a name="l01430"></a>01430       subtree_to_vine(NodeTraits::get_parent(header), &amp;len);
<a name="l01431"></a>01431       vine_to_subtree(NodeTraits::get_parent(header), len);
<a name="l01432"></a>01432    }
<a name="l01433"></a>01433 
<a name="l01434"></a>01434    <span class="keyword">static</span> node_ptr rebalance_subtree(node_ptr old_root)
<a name="l01435"></a>01435    {
<a name="l01436"></a>01436       std::size_t len = 0;
<a name="l01437"></a>01437       node_ptr new_root = subtree_to_vine(old_root, &amp;len);
<a name="l01438"></a>01438       <span class="keywordflow">return</span> vine_to_subtree(new_root, len);
<a name="l01439"></a>01439    }
<a name="l01440"></a>01440 
<a name="l01441"></a>01441    <span class="keyword">static</span> node_ptr subtree_to_vine(node_ptr old_root, std::size_t *plen = 0)
<a name="l01442"></a>01442    {
<a name="l01443"></a>01443       std::size_t len;
<a name="l01444"></a>01444       len = 0;
<a name="l01445"></a>01445       <span class="keywordflow">if</span>(!old_root)   <span class="keywordflow">return</span> node_ptr(0);
<a name="l01446"></a>01446 
<a name="l01447"></a>01447       <span class="comment">//To avoid irregularities in the algorithm (old_root can be a</span>
<a name="l01448"></a>01448       <span class="comment">//left or right child or even the root of the tree) just put the </span>
<a name="l01449"></a>01449       <span class="comment">//root as the right child of its parent. Before doing this backup</span>
<a name="l01450"></a>01450       <span class="comment">//information to restore the original relationship after</span>
<a name="l01451"></a>01451       <span class="comment">//the algorithm is applied.</span>
<a name="l01452"></a>01452       node_ptr super_root = NodeTraits::get_parent(old_root);
<a name="l01453"></a>01453       BOOST_INTRUSIVE_INVARIANT_ASSERT(super_root);
<a name="l01454"></a>01454 
<a name="l01455"></a>01455       <span class="comment">//Get info</span>
<a name="l01456"></a>01456       node_ptr super_root_right_backup = NodeTraits::get_right(super_root);
<a name="l01457"></a>01457       <span class="keywordtype">bool</span> super_root_is_header   = is_header(super_root);
<a name="l01458"></a>01458       <span class="keywordtype">bool</span> old_root_is_right  = <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a6363253158a6be8da006ea7f16b1e073">is_right_child</a>(old_root);
<a name="l01459"></a>01459 
<a name="l01460"></a>01460       node_ptr x(old_root);
<a name="l01461"></a>01461       node_ptr new_root(x);
<a name="l01462"></a>01462       node_ptr save;
<a name="l01463"></a>01463       <span class="keywordtype">bool</span> moved_to_right = <span class="keyword">false</span>;
<a name="l01464"></a>01464       <span class="keywordflow">for</span>( ; x; x = save){
<a name="l01465"></a>01465          save = NodeTraits::get_left(x);
<a name="l01466"></a>01466          <span class="keywordflow">if</span>(save){
<a name="l01467"></a>01467             <span class="comment">// Right rotation</span>
<a name="l01468"></a>01468             node_ptr save_right = NodeTraits::get_right(save);
<a name="l01469"></a>01469             node_ptr x_parent   = NodeTraits::get_parent(x);
<a name="l01470"></a>01470             NodeTraits::set_parent(save, x_parent);
<a name="l01471"></a>01471             NodeTraits::set_right (x_parent, save);
<a name="l01472"></a>01472             NodeTraits::set_parent(x, save);
<a name="l01473"></a>01473             NodeTraits::set_right (save, x);
<a name="l01474"></a>01474             NodeTraits::set_left(x, save_right);
<a name="l01475"></a>01475             <span class="keywordflow">if</span>(save_right)
<a name="l01476"></a>01476                NodeTraits::set_parent(save_right, x);
<a name="l01477"></a>01477             <span class="keywordflow">if</span>(!moved_to_right)
<a name="l01478"></a>01478                new_root = save;
<a name="l01479"></a>01479          }
<a name="l01480"></a>01480          <span class="keywordflow">else</span>{
<a name="l01481"></a>01481             moved_to_right = <span class="keyword">true</span>;
<a name="l01482"></a>01482             save = NodeTraits::get_right(x);
<a name="l01483"></a>01483             ++len;
<a name="l01484"></a>01484          }
<a name="l01485"></a>01485       }
<a name="l01486"></a>01486 
<a name="l01487"></a>01487       <span class="keywordflow">if</span>(super_root_is_header){
<a name="l01488"></a>01488          NodeTraits::set_right(super_root, super_root_right_backup);
<a name="l01489"></a>01489          NodeTraits::set_parent(super_root, new_root);
<a name="l01490"></a>01490       }
<a name="l01491"></a>01491       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(old_root_is_right){
<a name="l01492"></a>01492          NodeTraits::set_right(super_root, new_root);
<a name="l01493"></a>01493       }
<a name="l01494"></a>01494       <span class="keywordflow">else</span>{
<a name="l01495"></a>01495          NodeTraits::set_right(super_root, super_root_right_backup);
<a name="l01496"></a>01496          NodeTraits::set_left(super_root, new_root);
<a name="l01497"></a>01497       }
<a name="l01498"></a>01498       <span class="keywordflow">if</span>(plen) *plen = len;
<a name="l01499"></a>01499       <span class="keywordflow">return</span> new_root;
<a name="l01500"></a>01500    }
<a name="l01501"></a>01501 
<a name="l01502"></a>01502    <span class="keyword">static</span> node_ptr vine_to_subtree(node_ptr old_root, std::size_t count)
<a name="l01503"></a>01503    {
<a name="l01504"></a>01504       std::size_t leaf_nodes = count + 1 - ((std::size_t) 1 &lt;&lt; floor_log2 (count + 1));
<a name="l01505"></a>01505       std::size_t vine_nodes = count - leaf_nodes;
<a name="l01506"></a>01506 
<a name="l01507"></a>01507       node_ptr new_root = compress_subtree(old_root, leaf_nodes);
<a name="l01508"></a>01508       <span class="keywordflow">while</span>(vine_nodes &gt; 1){
<a name="l01509"></a>01509          vine_nodes /= 2;
<a name="l01510"></a>01510          new_root = compress_subtree(new_root, vine_nodes);
<a name="l01511"></a>01511       }
<a name="l01512"></a>01512       <span class="keywordflow">return</span> new_root;
<a name="l01513"></a>01513    }
<a name="l01514"></a>01514 
<a name="l01515"></a>01515    <span class="keyword">static</span> node_ptr compress_subtree(node_ptr old_root, std::size_t count)
<a name="l01516"></a>01516    {
<a name="l01517"></a>01517       <span class="keywordflow">if</span>(!old_root)   <span class="keywordflow">return</span> old_root;
<a name="l01518"></a>01518 
<a name="l01519"></a>01519       <span class="comment">//To avoid irregularities in the algorithm (old_root can be</span>
<a name="l01520"></a>01520       <span class="comment">//left or right child or even the root of the tree) just put the </span>
<a name="l01521"></a>01521       <span class="comment">//root as the right child of its parent. First obtain</span>
<a name="l01522"></a>01522       <span class="comment">//information to restore the original relationship after</span>
<a name="l01523"></a>01523       <span class="comment">//the algorithm is applied.</span>
<a name="l01524"></a>01524       node_ptr super_root = NodeTraits::get_parent(old_root);
<a name="l01525"></a>01525       BOOST_INTRUSIVE_INVARIANT_ASSERT(super_root);
<a name="l01526"></a>01526 
<a name="l01527"></a>01527       <span class="comment">//Get info</span>
<a name="l01528"></a>01528       node_ptr super_root_right_backup = NodeTraits::get_right(super_root);
<a name="l01529"></a>01529       <span class="keywordtype">bool</span> super_root_is_header   = is_header(super_root);
<a name="l01530"></a>01530       <span class="keywordtype">bool</span> old_root_is_right  = <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a6363253158a6be8da006ea7f16b1e073">is_right_child</a>(old_root);
<a name="l01531"></a>01531 
<a name="l01532"></a>01532       <span class="comment">//Put old_root as right child</span>
<a name="l01533"></a>01533       NodeTraits::set_right(super_root, old_root);
<a name="l01534"></a>01534 
<a name="l01535"></a>01535       <span class="comment">//Start the compression algorithm            </span>
<a name="l01536"></a>01536       node_ptr even_parent = super_root;
<a name="l01537"></a>01537       node_ptr new_root = old_root;
<a name="l01538"></a>01538 
<a name="l01539"></a>01539       <span class="keywordflow">while</span>(count--){
<a name="l01540"></a>01540          node_ptr even = NodeTraits::get_right(even_parent);
<a name="l01541"></a>01541          node_ptr odd = NodeTraits::get_right(even);
<a name="l01542"></a>01542 
<a name="l01543"></a>01543          <span class="keywordflow">if</span>(new_root == old_root)
<a name="l01544"></a>01544             new_root = odd;
<a name="l01545"></a>01545 
<a name="l01546"></a>01546          node_ptr even_right = NodeTraits::get_left(odd);
<a name="l01547"></a>01547          NodeTraits::set_right(even, even_right);
<a name="l01548"></a>01548          <span class="keywordflow">if</span> (even_right)
<a name="l01549"></a>01549             NodeTraits::set_parent(even_right, even);
<a name="l01550"></a>01550 
<a name="l01551"></a>01551          NodeTraits::set_right(even_parent, odd);
<a name="l01552"></a>01552          NodeTraits::set_parent(odd, even_parent);
<a name="l01553"></a>01553          NodeTraits::set_left(odd, even);
<a name="l01554"></a>01554          NodeTraits::set_parent(even, odd);
<a name="l01555"></a>01555          even_parent = odd;
<a name="l01556"></a>01556       }
<a name="l01557"></a>01557 
<a name="l01558"></a>01558       <span class="keywordflow">if</span>(super_root_is_header){
<a name="l01559"></a>01559          NodeTraits::set_parent(super_root, new_root);
<a name="l01560"></a>01560          NodeTraits::set_right(super_root, super_root_right_backup);
<a name="l01561"></a>01561       }
<a name="l01562"></a>01562       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(old_root_is_right){
<a name="l01563"></a>01563          NodeTraits::set_right(super_root, new_root);
<a name="l01564"></a>01564       }
<a name="l01565"></a>01565       <span class="keywordflow">else</span>{
<a name="l01566"></a>01566          NodeTraits::set_left(super_root, new_root);
<a name="l01567"></a>01567          NodeTraits::set_right(super_root, super_root_right_backup);
<a name="l01568"></a>01568       }
<a name="l01569"></a>01569       <span class="keywordflow">return</span> new_root;
<a name="l01570"></a>01570    }
<a name="l01571"></a>01571 
<a name="l01579"></a><a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#ac90ac82e5a652b63e62ed80c2eed0c27">01579</a>    <span class="keyword">static</span> node_ptr <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#ac90ac82e5a652b63e62ed80c2eed0c27">get_root</a>(node_ptr node)
<a name="l01580"></a>01580    {
<a name="l01581"></a>01581       BOOST_INTRUSIVE_INVARIANT_ASSERT((!<a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a32ee0ad7b0db8edb5b9e6f8372e6c643">inited</a>(node)));
<a name="l01582"></a>01582       node_ptr x = NodeTraits::get_parent(node);
<a name="l01583"></a>01583       <span class="keywordflow">if</span>(x){
<a name="l01584"></a>01584          <span class="keywordflow">while</span>(!is_header(x)){
<a name="l01585"></a>01585             x = NodeTraits::get_parent(x);
<a name="l01586"></a>01586          }
<a name="l01587"></a>01587          <span class="keywordflow">return</span> x;
<a name="l01588"></a>01588       }
<a name="l01589"></a>01589       <span class="keywordflow">else</span>{
<a name="l01590"></a>01590          <span class="keywordflow">return</span> node;
<a name="l01591"></a>01591       }
<a name="l01592"></a>01592    }
<a name="l01593"></a>01593 
<a name="l01594"></a>01594    <span class="keyword">private</span>:
<a name="l01595"></a>01595    <span class="keyword">template</span>&lt;<span class="keyword">class</span> NodePtrCompare&gt;
<a name="l01596"></a>01596    <span class="keyword">static</span> <span class="keywordtype">void</span> insert_equal_check_impl
<a name="l01597"></a>01597       (<span class="keywordtype">bool</span> upper, node_ptr h, node_ptr new_node, NodePtrCompare comp, insert_commit_data &amp; commit_data, std::size_t *pdepth = 0)
<a name="l01598"></a>01598    {
<a name="l01599"></a>01599       std::size_t <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a23388346048ca3f041c9ad176f02b8d0">depth</a> = 0;
<a name="l01600"></a>01600       node_ptr y(h);
<a name="l01601"></a>01601       node_ptr x(NodeTraits::get_parent(y));
<a name="l01602"></a>01602       <span class="keywordtype">bool</span> link_left;
<a name="l01603"></a>01603 
<a name="l01604"></a>01604       <span class="keywordflow">if</span>(upper){
<a name="l01605"></a>01605          <span class="keywordflow">while</span>(x){
<a name="l01606"></a>01606             ++<a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a23388346048ca3f041c9ad176f02b8d0">depth</a>;
<a name="l01607"></a>01607             y = x;
<a name="l01608"></a>01608             x = comp(new_node, x) ? 
<a name="l01609"></a>01609                   NodeTraits::get_left(x) : NodeTraits::get_right(x);
<a name="l01610"></a>01610          }
<a name="l01611"></a>01611          link_left = (y == h) || comp(new_node, y);
<a name="l01612"></a>01612       }
<a name="l01613"></a>01613       <span class="keywordflow">else</span>{
<a name="l01614"></a>01614          <span class="keywordflow">while</span>(x){
<a name="l01615"></a>01615             ++<a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a23388346048ca3f041c9ad176f02b8d0">depth</a>;
<a name="l01616"></a>01616             y = x;
<a name="l01617"></a>01617             x = !comp(x, new_node) ? 
<a name="l01618"></a>01618                   NodeTraits::get_left(x) : NodeTraits::get_right(x);
<a name="l01619"></a>01619          }
<a name="l01620"></a>01620          link_left = (y == h) || !comp(y, new_node);
<a name="l01621"></a>01621       }
<a name="l01622"></a>01622 
<a name="l01623"></a>01623       commit_data.link_left = link_left;
<a name="l01624"></a>01624       commit_data.node = y;
<a name="l01625"></a>01625       <span class="keywordflow">if</span>(pdepth)  *pdepth = <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a23388346048ca3f041c9ad176f02b8d0">depth</a>;
<a name="l01626"></a>01626    }
<a name="l01627"></a>01627 
<a name="l01628"></a>01628    <span class="keyword">static</span> <span class="keywordtype">void</span> erase_impl(node_ptr header, node_ptr z, data_for_rebalance &amp;info)
<a name="l01629"></a>01629    {
<a name="l01630"></a>01630       node_ptr y(z);
<a name="l01631"></a>01631       node_ptr x;
<a name="l01632"></a>01632       node_ptr x_parent(0);
<a name="l01633"></a>01633       node_ptr z_left(NodeTraits::get_left(z));
<a name="l01634"></a>01634       node_ptr z_right(NodeTraits::get_right(z));
<a name="l01635"></a>01635       <span class="keywordflow">if</span>(!z_left){
<a name="l01636"></a>01636          x = z_right;    <span class="comment">// x might be null.</span>
<a name="l01637"></a>01637       }
<a name="l01638"></a>01638       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!z_right){ <span class="comment">// z has exactly one non-null child. y == z.</span>
<a name="l01639"></a>01639          x = z_left;       <span class="comment">// x is not null.</span>
<a name="l01640"></a>01640       }
<a name="l01641"></a>01641       <span class="keywordflow">else</span>{
<a name="l01642"></a>01642          <span class="comment">// find z&#39;s successor</span>
<a name="l01643"></a>01643          y = <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a4714649b6fc5ab9290ec47804edb2634">tree_algorithms::minimum</a> (z_right);
<a name="l01644"></a>01644          x = NodeTraits::get_right(y);     <span class="comment">// x might be null.</span>
<a name="l01645"></a>01645       }
<a name="l01646"></a>01646 
<a name="l01647"></a>01647       <span class="keywordflow">if</span>(y != z){
<a name="l01648"></a>01648          <span class="comment">// relink y in place of z.  y is z&#39;s successor</span>
<a name="l01649"></a>01649          NodeTraits::set_parent(NodeTraits::get_left(z), y);
<a name="l01650"></a>01650          NodeTraits::set_left(y, NodeTraits::get_left(z));
<a name="l01651"></a>01651          <span class="keywordflow">if</span>(y != NodeTraits::get_right(z)){
<a name="l01652"></a>01652             x_parent = NodeTraits::get_parent(y);
<a name="l01653"></a>01653             <span class="keywordflow">if</span>(x)
<a name="l01654"></a>01654                NodeTraits::set_parent(x, x_parent);
<a name="l01655"></a>01655             NodeTraits::set_left(x_parent, x);   <span class="comment">// y must be a child of left_</span>
<a name="l01656"></a>01656             NodeTraits::set_right(y, NodeTraits::get_right(z));
<a name="l01657"></a>01657             NodeTraits::set_parent(NodeTraits::get_right(z), y);
<a name="l01658"></a>01658          }
<a name="l01659"></a>01659          <span class="keywordflow">else</span>
<a name="l01660"></a>01660             x_parent = y;
<a name="l01661"></a>01661          tree_algorithms::replace_own (z, y, header);
<a name="l01662"></a>01662          NodeTraits::set_parent(y, NodeTraits::get_parent(z));
<a name="l01663"></a>01663       }
<a name="l01664"></a>01664       <span class="keywordflow">else</span> {   <span class="comment">// y == z --&gt; z has only one child, or none</span>
<a name="l01665"></a>01665          x_parent = NodeTraits::get_parent(z);
<a name="l01666"></a>01666          <span class="keywordflow">if</span>(x)
<a name="l01667"></a>01667             NodeTraits::set_parent(x, x_parent);
<a name="l01668"></a>01668          tree_algorithms::replace_own (z, x, header);
<a name="l01669"></a>01669          <span class="keywordflow">if</span>(NodeTraits::get_left(header) == z){
<a name="l01670"></a>01670             NodeTraits::set_left(header, !NodeTraits::get_right(z) ?        <span class="comment">// z-&gt;get_left() must be null also</span>
<a name="l01671"></a>01671                NodeTraits::get_parent(z) :  <span class="comment">// makes leftmost == header if z == root</span>
<a name="l01672"></a>01672                <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a4714649b6fc5ab9290ec47804edb2634">tree_algorithms::minimum</a> (x));
<a name="l01673"></a>01673          }
<a name="l01674"></a>01674          <span class="keywordflow">if</span>(NodeTraits::get_right(header) == z){
<a name="l01675"></a>01675             NodeTraits::set_right(header, !NodeTraits::get_left(z) ?        <span class="comment">// z-&gt;get_right() must be null also</span>
<a name="l01676"></a>01676                               NodeTraits::get_parent(z) :  <span class="comment">// makes rightmost == header if z == root</span>
<a name="l01677"></a>01677                               <a class="code" href="classboost_1_1intrusive_1_1detail_1_1tree__algorithms.html#a877e439c124563c571b69528e11a3292">tree_algorithms::maximum</a>(x));
<a name="l01678"></a>01678          }
<a name="l01679"></a>01679       }
<a name="l01680"></a>01680 
<a name="l01681"></a>01681       info.x = x;
<a name="l01682"></a>01682       info.x_parent = x_parent;
<a name="l01683"></a>01683       info.y = y;
<a name="l01684"></a>01684    }
<a name="l01685"></a>01685 };
<a name="l01686"></a>01686 
<a name="l01687"></a>01687 }  <span class="comment">//namespace detail {</span>
<a name="l01688"></a>01688 }  <span class="comment">//namespace intrusive </span>
<a name="l01689"></a>01689 }  <span class="comment">//namespace boost </span>
<a name="l01690"></a>01690 
<a name="l01691"></a>01691 <span class="preprocessor">#include &lt;boost/intrusive/detail/config_end.hpp&gt;</span>
<a name="l01692"></a>01692 
<a name="l01693"></a>01693 <span class="preprocessor">#endif //BOOST_INTRUSIVE_TREE_ALGORITHMS_HPP</span>
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Apr 27 2011 00:50:08 for Nutcracker by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
