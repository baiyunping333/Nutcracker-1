<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nutcracker: map.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>map.hpp</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00002"></a>00002 <span class="comment">//</span>
<a name="l00003"></a>00003 <span class="comment">// (C) Copyright Ion Gaztanaga 2005-2009. Distributed under the Boost</span>
<a name="l00004"></a>00004 <span class="comment">// Software License, Version 1.0. (See accompanying file</span>
<a name="l00005"></a>00005 <span class="comment">// LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)</span>
<a name="l00006"></a>00006 <span class="comment">//</span>
<a name="l00007"></a>00007 <span class="comment">// See http://www.boost.org/libs/container for documentation.</span>
<a name="l00008"></a>00008 <span class="comment">//</span>
<a name="l00010"></a>00010 <span class="comment"></span><span class="comment">//</span>
<a name="l00011"></a>00011 <span class="comment">// This file comes from SGI&#39;s stl_map/stl_multimap files. Modified by Ion Gaztanaga.</span>
<a name="l00012"></a>00012 <span class="comment">// Renaming, isolating and porting to generic algorithms. Pointer typedef </span>
<a name="l00013"></a>00013 <span class="comment">// set to allocator::pointer to allow placing it in shared memory.</span>
<a name="l00014"></a>00014 <span class="comment">//</span>
<a name="l00016"></a>00016 <span class="comment"></span><span class="comment">/*</span>
<a name="l00017"></a>00017 <span class="comment"> *</span>
<a name="l00018"></a>00018 <span class="comment"> * Copyright (c) 1994</span>
<a name="l00019"></a>00019 <span class="comment"> * Hewlett-Packard Company</span>
<a name="l00020"></a>00020 <span class="comment"> *</span>
<a name="l00021"></a>00021 <span class="comment"> * Permission to use, copy, modify, distribute and sell this software</span>
<a name="l00022"></a>00022 <span class="comment"> * and its documentation for any purpose is hereby granted without fee,</span>
<a name="l00023"></a>00023 <span class="comment"> * provided that the above copyright notice appear in all copies and</span>
<a name="l00024"></a>00024 <span class="comment"> * that both that copyright notice and this permission notice appear</span>
<a name="l00025"></a>00025 <span class="comment"> * in supporting documentation.  Hewlett-Packard Company makes no</span>
<a name="l00026"></a>00026 <span class="comment"> * representations about the suitability of this software for any</span>
<a name="l00027"></a>00027 <span class="comment"> * purpose.  It is provided &quot;as is&quot; without express or implied warranty.</span>
<a name="l00028"></a>00028 <span class="comment"> *</span>
<a name="l00029"></a>00029 <span class="comment"> *</span>
<a name="l00030"></a>00030 <span class="comment"> * Copyright (c) 1996</span>
<a name="l00031"></a>00031 <span class="comment"> * Silicon Graphics Computer Systems, Inc.</span>
<a name="l00032"></a>00032 <span class="comment"> *</span>
<a name="l00033"></a>00033 <span class="comment"> * Permission to use, copy, modify, distribute and sell this software</span>
<a name="l00034"></a>00034 <span class="comment"> * and its documentation for any purpose is hereby granted without fee,</span>
<a name="l00035"></a>00035 <span class="comment"> * provided that the above copyright notice appear in all copies and</span>
<a name="l00036"></a>00036 <span class="comment"> * that both that copyright notice and this permission notice appear</span>
<a name="l00037"></a>00037 <span class="comment"> * in supporting documentation.  Silicon Graphics makes no</span>
<a name="l00038"></a>00038 <span class="comment"> * representations about the suitability of this software for any</span>
<a name="l00039"></a>00039 <span class="comment"> * purpose.  It is provided &quot;as is&quot; without express or implied warranty.</span>
<a name="l00040"></a>00040 <span class="comment"> *</span>
<a name="l00041"></a>00041 <span class="comment"> */</span>
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 <span class="preprocessor">#ifndef BOOST_CONTAINERS_MAP_HPP</span>
<a name="l00044"></a>00044 <span class="preprocessor"></span><span class="preprocessor">#define BOOST_CONTAINERS_MAP_HPP</span>
<a name="l00045"></a>00045 <span class="preprocessor"></span>
<a name="l00046"></a>00046 <span class="preprocessor">#if (defined _MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200)</span>
<a name="l00047"></a>00047 <span class="preprocessor"></span><span class="preprocessor">#  pragma once</span>
<a name="l00048"></a>00048 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00049"></a>00049 <span class="preprocessor"></span>
<a name="l00050"></a>00050 <span class="preprocessor">#include &quot;detail/config_begin.hpp&quot;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_WORKAROUND_HPP</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span>
<a name="l00053"></a>00053 <span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_CONTAINER_FWD_HPP</span>
<a name="l00054"></a>00054 <span class="preprocessor"></span><span class="preprocessor">#include &lt;utility&gt;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &lt;functional&gt;</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include &lt;memory&gt;</span>
<a name="l00057"></a>00057 <span class="preprocessor">#include &lt;stdexcept&gt;</span>
<a name="l00058"></a>00058 <span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_TREE_HPP</span>
<a name="l00059"></a>00059 <span class="preprocessor"></span><span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_VALUE_INIT_HPP</span>
<a name="l00060"></a>00060 <span class="preprocessor"></span><span class="preprocessor">#include &lt;boost/type_traits/has_trivial_destructor.hpp&gt;</span>
<a name="l00061"></a>00061 <span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_MPL_HPP</span>
<a name="l00062"></a>00062 <span class="preprocessor"></span><span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_UTILITIES_HPP</span>
<a name="l00063"></a>00063 <span class="preprocessor"></span><span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_PAIR_HPP</span>
<a name="l00064"></a>00064 <span class="preprocessor"></span><span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_MOVE_HPP</span>
<a name="l00065"></a>00065 <span class="preprocessor"></span>
<a name="l00066"></a>00066 <span class="preprocessor">#ifdef BOOST_CONTAINER_DOXYGEN_INVOKED</span>
<a name="l00067"></a>00067 <span class="preprocessor"></span><span class="keyword">namespace </span>boost {
<a name="l00068"></a>00068 <span class="keyword">namespace </span>container {
<a name="l00069"></a>00069 <span class="preprocessor">#else</span>
<a name="l00070"></a>00070 <span class="preprocessor"></span><span class="keyword">namespace </span>boost {
<a name="l00071"></a>00071 <span class="keyword">namespace </span>container {
<a name="l00072"></a>00072 <span class="preprocessor">#endif</span>
<a name="l00073"></a>00073 <span class="preprocessor"></span>
<a name="l00075"></a>00075 <span class="comment">// Forward declarations of operators == and &lt;, needed for friend declarations.</span>
<a name="l00076"></a>00076 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00077"></a>00077 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> map&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l00078"></a>00078                        <span class="keyword">const</span> map&lt;Key,T,Pred,Alloc&gt;&amp; y);
<a name="l00079"></a>00079 
<a name="l00080"></a>00080 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00081"></a>00081 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&lt;(const map&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l00082"></a>00082                       <span class="keyword">const</span> map&lt;Key,T,Pred,Alloc&gt;&amp; y);
<a name="l00084"></a>00084 
<a name="l00097"></a>00097 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00098"></a><a class="code" href="classboost_1_1container_1_1map.html">00098</a> <span class="keyword">class </span><a class="code" href="classboost_1_1container_1_1map.html">map</a> 
<a name="l00099"></a>00099 {
<a name="l00101"></a>00101    <span class="keyword">private</span>:
<a name="l00102"></a>00102    BOOST_MOVE_MACRO_COPYABLE_AND_MOVABLE(<a class="code" href="classboost_1_1container_1_1map.html">map</a>)
<a name="l00103"></a>00103    <span class="keyword">typedef</span> <a class="code" href="classboost_1_1container_1_1containers__detail_1_1rbtree.html">containers_detail::rbtree</a>&lt;Key, 
<a name="l00104"></a>00104                            std::pair&lt;const Key, T&gt;, 
<a name="l00105"></a>00105                            <a class="code" href="structboost_1_1container_1_1containers__detail_1_1select1st.html">containers_detail::select1st&lt; std::pair&lt;const Key, T&gt;</a> &gt;, 
<a name="l00106"></a>00106                            Pred, 
<a name="l00107"></a>00107                            Alloc&gt; tree_t;
<a name="l00108"></a>00108    tree_t m_tree;  <span class="comment">// red-black tree representing map</span>
<a name="l00110"></a>00110 <span class="comment"></span>
<a name="l00111"></a>00111    <span class="keyword">public</span>:
<a name="l00112"></a>00112 
<a name="l00113"></a>00113    <span class="comment">// typedefs:</span>
<a name="l00114"></a>00114    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::key_type               key_type;
<a name="l00115"></a>00115    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::value_type             value_type;
<a name="l00116"></a>00116    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::pointer                pointer;
<a name="l00117"></a>00117    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::const_pointer          const_pointer;
<a name="l00118"></a>00118    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::reference              reference;
<a name="l00119"></a>00119    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::const_reference        const_reference;
<a name="l00120"></a>00120    <span class="keyword">typedef</span> T                                       mapped_type;
<a name="l00121"></a>00121    <span class="keyword">typedef</span> Pred                                    key_compare;
<a name="l00122"></a>00122    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::iterator               iterator;
<a name="l00123"></a>00123    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::const_iterator         const_iterator;
<a name="l00124"></a>00124    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::reverse_iterator       reverse_iterator;
<a name="l00125"></a>00125    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::const_reverse_iterator const_reverse_iterator;
<a name="l00126"></a>00126    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::size_type              size_type;
<a name="l00127"></a>00127    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::difference_type        difference_type;
<a name="l00128"></a>00128    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::allocator_type         allocator_type;
<a name="l00129"></a>00129    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::stored_allocator_type  stored_allocator_type;
<a name="l00130"></a>00130    <span class="keyword">typedef</span> std::pair&lt;key_type, mapped_type&gt;        nonconst_value_type;
<a name="l00131"></a>00131    <span class="keyword">typedef</span> <a class="code" href="structboost_1_1container_1_1containers__detail_1_1pair.html">containers_detail::pair</a>
<a name="l00132"></a>00132       &lt;key_type, mapped_type&gt;                      <a class="code" href="structboost_1_1container_1_1containers__detail_1_1pair.html">nonconst_impl_value_type</a>;
<a name="l00133"></a>00133 
<a name="l00135"></a>00135    <span class="keyword">class </span>value_compare_impl
<a name="l00136"></a>00136       :  <span class="keyword">public</span> Pred,
<a name="l00137"></a>00137          <span class="keyword">public</span> std::binary_function&lt;value_type, value_type, bool&gt; 
<a name="l00138"></a>00138    {
<a name="l00139"></a>00139       <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classboost_1_1container_1_1map.html">map</a>&lt;Key,T,Pred,Alloc&gt;;
<a name="l00140"></a>00140     <span class="keyword">protected</span> :
<a name="l00141"></a>00141       value_compare_impl(<span class="keyword">const</span> Pred &amp;c) : Pred(c) {}
<a name="l00142"></a>00142     <span class="keyword">public</span>:
<a name="l00143"></a>00143       <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> value_type&amp; x, <span class="keyword">const</span> value_type&amp; y)<span class="keyword"> const </span>{
<a name="l00144"></a>00144          <span class="keywordflow">return</span> Pred::operator()(x.first, y.first);
<a name="l00145"></a>00145       }
<a name="l00146"></a>00146    };
<a name="l00148"></a>00148    <span class="keyword">typedef</span> value_compare_impl             value_compare;
<a name="l00149"></a>00149 
<a name="l00154"></a><a class="code" href="classboost_1_1container_1_1map.html#a193b01458bbdc2c0785580de9c78f334">00154</a>    <span class="keyword">explicit</span> <a class="code" href="classboost_1_1container_1_1map.html">map</a>(<span class="keyword">const</span> Pred&amp; comp = Pred(),
<a name="l00155"></a>00155                 <span class="keyword">const</span> allocator_type&amp; a = allocator_type())
<a name="l00156"></a>00156       : m_tree(comp, a)
<a name="l00157"></a>00157    {}
<a name="l00158"></a>00158 
<a name="l00164"></a>00164    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
<a name="l00165"></a><a class="code" href="classboost_1_1container_1_1map.html#a664ca12c81ddc0b0e305361a91bc8160">00165</a>    <a class="code" href="classboost_1_1container_1_1map.html">map</a>(InputIterator first, InputIterator last, <span class="keyword">const</span> Pred&amp; comp = Pred(),
<a name="l00166"></a>00166          <span class="keyword">const</span> allocator_type&amp; a = allocator_type())
<a name="l00167"></a>00167       : m_tree(first, last, comp, a, true) 
<a name="l00168"></a>00168    {}
<a name="l00169"></a>00169 
<a name="l00178"></a>00178    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
<a name="l00179"></a><a class="code" href="classboost_1_1container_1_1map.html#ae17bcbe9a83ea6d4acaf9ebab4bb6a95">00179</a>    <a class="code" href="classboost_1_1container_1_1map.html">map</a>( ordered_unique_range_t, InputIterator first, InputIterator last
<a name="l00180"></a>00180       , <span class="keyword">const</span> Pred&amp; comp = Pred(), <span class="keyword">const</span> allocator_type&amp; a = allocator_type())
<a name="l00181"></a>00181       : m_tree(ordered_range, first, last, comp, a) 
<a name="l00182"></a>00182    {}
<a name="l00183"></a>00183 
<a name="l00187"></a><a class="code" href="classboost_1_1container_1_1map.html#a484ac5e9002bcc9fcd6945b102963f9e">00187</a>    <a class="code" href="classboost_1_1container_1_1map.html">map</a>(<span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1map.html">map&lt;Key,T,Pred,Alloc&gt;</a>&amp; x) 
<a name="l00188"></a>00188       : m_tree(x.m_tree)
<a name="l00189"></a>00189    {}
<a name="l00190"></a>00190 
<a name="l00196"></a><a class="code" href="classboost_1_1container_1_1map.html#a1a01a878d950242801e7019a026f39fc">00196</a>    <a class="code" href="classboost_1_1container_1_1map.html">map</a>(BOOST_MOVE_MACRO_RV_REF(<a class="code" href="classboost_1_1container_1_1map.html">map</a>) x) 
<a name="l00197"></a>00197       : m_tree(BOOST_CONTAINER_MOVE_NAMESPACE::move(x.m_tree))
<a name="l00198"></a>00198    {}
<a name="l00199"></a>00199 
<a name="l00203"></a><a class="code" href="classboost_1_1container_1_1map.html#a821c9220095b86abb6990cf1d0cbfd00">00203</a>    <a class="code" href="classboost_1_1container_1_1map.html">map</a>&amp; operator=(BOOST_MOVE_MACRO_COPY_ASSIGN_REF(<a class="code" href="classboost_1_1container_1_1map.html">map</a>) x)
<a name="l00204"></a>00204    {  m_tree = x.m_tree;   <span class="keywordflow">return</span> *<span class="keyword">this</span>;  }
<a name="l00205"></a>00205 
<a name="l00209"></a><a class="code" href="classboost_1_1container_1_1map.html#a05b7e8e68879f0f4d619800cd63f74ff">00209</a>    <a class="code" href="classboost_1_1container_1_1map.html">map</a>&amp; operator=(BOOST_MOVE_MACRO_RV_REF(<a class="code" href="classboost_1_1container_1_1map.html">map</a>) x)
<a name="l00210"></a>00210    {  m_tree = BOOST_CONTAINER_MOVE_NAMESPACE::move(x.m_tree);   <span class="keywordflow">return</span> *<span class="keyword">this</span>;  }
<a name="l00211"></a>00211 
<a name="l00216"></a><a class="code" href="classboost_1_1container_1_1map.html#a785edc47476474f53d5a693b60ca606c">00216</a>    key_compare key_comp()<span class="keyword"> const </span>
<a name="l00217"></a>00217 <span class="keyword">   </span>{ <span class="keywordflow">return</span> m_tree.key_comp(); }
<a name="l00218"></a>00218 
<a name="l00223"></a><a class="code" href="classboost_1_1container_1_1map.html#a8e92f21b0ae8a2465ce9662662ba5869">00223</a>    value_compare value_comp()<span class="keyword"> const </span>
<a name="l00224"></a>00224 <span class="keyword">   </span>{ <span class="keywordflow">return</span> value_compare(m_tree.key_comp()); }
<a name="l00225"></a>00225 
<a name="l00230"></a><a class="code" href="classboost_1_1container_1_1map.html#ac6279887c5557cb94efeeaf0ef4505c6">00230</a>    allocator_type get_allocator()<span class="keyword"> const </span>
<a name="l00231"></a>00231 <span class="keyword">   </span>{ <span class="keywordflow">return</span> m_tree.get_allocator(); }
<a name="l00232"></a>00232 
<a name="l00233"></a>00233    <span class="keyword">const</span> stored_allocator_type &amp;get_stored_allocator()<span class="keyword"> const </span>
<a name="l00234"></a>00234 <span class="keyword">   </span>{ <span class="keywordflow">return</span> m_tree.get_stored_allocator(); }
<a name="l00235"></a>00235 
<a name="l00236"></a>00236    stored_allocator_type &amp;get_stored_allocator()
<a name="l00237"></a>00237    { <span class="keywordflow">return</span> m_tree.get_stored_allocator(); }
<a name="l00238"></a>00238 
<a name="l00244"></a><a class="code" href="classboost_1_1container_1_1map.html#a4c8431ef9151b129e4767037f382ca0c">00244</a>    iterator begin() 
<a name="l00245"></a>00245    { <span class="keywordflow">return</span> m_tree.begin(); }
<a name="l00246"></a>00246 
<a name="l00252"></a><a class="code" href="classboost_1_1container_1_1map.html#a4e913f2e38f3aefdc1272b06849aee3c">00252</a>    const_iterator begin()<span class="keyword"> const </span>
<a name="l00253"></a>00253 <span class="keyword">   </span>{ <span class="keywordflow">return</span> m_tree.begin(); }
<a name="l00254"></a>00254 
<a name="l00260"></a><a class="code" href="classboost_1_1container_1_1map.html#a0604e42754681d7e6d01c23ac1304023">00260</a>    iterator end() 
<a name="l00261"></a>00261    { <span class="keywordflow">return</span> m_tree.end(); }
<a name="l00262"></a>00262 
<a name="l00268"></a><a class="code" href="classboost_1_1container_1_1map.html#aca4e2442df0df927bacaeaca9f49ccfe">00268</a>    const_iterator end()<span class="keyword"> const </span>
<a name="l00269"></a>00269 <span class="keyword">   </span>{ <span class="keywordflow">return</span> m_tree.end(); }
<a name="l00270"></a>00270 
<a name="l00277"></a><a class="code" href="classboost_1_1container_1_1map.html#a51ae74d218e3eb83e8c7c6fa0c13bf40">00277</a>    reverse_iterator rbegin() 
<a name="l00278"></a>00278    { <span class="keywordflow">return</span> m_tree.rbegin(); }
<a name="l00279"></a>00279 
<a name="l00286"></a><a class="code" href="classboost_1_1container_1_1map.html#a144c7bc08b080a4e297a37862bbd7f3a">00286</a>    const_reverse_iterator rbegin()<span class="keyword"> const </span>
<a name="l00287"></a>00287 <span class="keyword">   </span>{ <span class="keywordflow">return</span> m_tree.rbegin(); }
<a name="l00288"></a>00288 
<a name="l00295"></a><a class="code" href="classboost_1_1container_1_1map.html#a3e64276b02bdc734bac082568c6f15d6">00295</a>    reverse_iterator rend() 
<a name="l00296"></a>00296    { <span class="keywordflow">return</span> m_tree.rend(); }
<a name="l00297"></a>00297 
<a name="l00304"></a><a class="code" href="classboost_1_1container_1_1map.html#a465aaa78fdcbd155f6ae3432124983f2">00304</a>    const_reverse_iterator rend()<span class="keyword"> const </span>
<a name="l00305"></a>00305 <span class="keyword">   </span>{ <span class="keywordflow">return</span> m_tree.rend(); }
<a name="l00306"></a>00306 
<a name="l00312"></a><a class="code" href="classboost_1_1container_1_1map.html#aad4ead31fe51c8f930e2867bed9f6f77">00312</a>    <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>
<a name="l00313"></a>00313 <span class="keyword">   </span>{ <span class="keywordflow">return</span> m_tree.empty(); }
<a name="l00314"></a>00314 
<a name="l00320"></a><a class="code" href="classboost_1_1container_1_1map.html#ac1f57d1990c19bb609887e07f0e38b64">00320</a>    size_type size()<span class="keyword"> const </span>
<a name="l00321"></a>00321 <span class="keyword">   </span>{ <span class="keywordflow">return</span> m_tree.size(); }
<a name="l00322"></a>00322 
<a name="l00328"></a><a class="code" href="classboost_1_1container_1_1map.html#a8c13ce9da439183c311a9eb7de4e6c1e">00328</a>    size_type max_size()<span class="keyword"> const </span>
<a name="l00329"></a>00329 <span class="keyword">   </span>{ <span class="keywordflow">return</span> m_tree.max_size(); }
<a name="l00330"></a>00330 
<a name="l00337"></a><a class="code" href="classboost_1_1container_1_1map.html#a0b40f227e71977e8b79e7d6965259d96">00337</a>    T&amp; operator[](<span class="keyword">const</span> key_type&amp; k) 
<a name="l00338"></a>00338    {
<a name="l00339"></a>00339       <span class="comment">//we can optimize this</span>
<a name="l00340"></a>00340       iterator i = lower_bound(k);
<a name="l00341"></a>00341       <span class="comment">// i-&gt;first is greater than or equivalent to k.</span>
<a name="l00342"></a>00342       <span class="keywordflow">if</span> (i == end() || key_comp()(k, (*i).first)){
<a name="l00343"></a>00343          <a class="code" href="structboost_1_1container_1_1containers__detail_1_1value__init.html">containers_detail::value_init&lt;T&gt;</a> v;
<a name="l00344"></a>00344          value_type val(k, BOOST_CONTAINER_MOVE_NAMESPACE::move(v.m_t));
<a name="l00345"></a>00345          i = insert(i, BOOST_CONTAINER_MOVE_NAMESPACE::move(val));
<a name="l00346"></a>00346       }
<a name="l00347"></a>00347       <span class="keywordflow">return</span> (*i).second;
<a name="l00348"></a>00348    }
<a name="l00349"></a>00349 
<a name="l00356"></a><a class="code" href="classboost_1_1container_1_1map.html#a4c75eed056fd450ec8ea89502acf4d10">00356</a>    T&amp; operator[](BOOST_MOVE_MACRO_RV_REF(key_type) mk) 
<a name="l00357"></a>00357    {
<a name="l00358"></a>00358       key_type &amp;k = mk;
<a name="l00359"></a>00359       <span class="comment">//we can optimize this</span>
<a name="l00360"></a>00360       iterator i = lower_bound(k);
<a name="l00361"></a>00361       <span class="comment">// i-&gt;first is greater than or equivalent to k.</span>
<a name="l00362"></a>00362       <span class="keywordflow">if</span> (i == end() || key_comp()(k, (*i).first)){
<a name="l00363"></a>00363          value_type val(BOOST_CONTAINER_MOVE_NAMESPACE::move(k), BOOST_CONTAINER_MOVE_NAMESPACE::move(T()));
<a name="l00364"></a>00364          i = insert(i, BOOST_CONTAINER_MOVE_NAMESPACE::move(val));
<a name="l00365"></a>00365       }
<a name="l00366"></a>00366       <span class="keywordflow">return</span> (*i).second;
<a name="l00367"></a>00367    }
<a name="l00368"></a>00368 
<a name="l00372"></a><a class="code" href="classboost_1_1container_1_1map.html#a7449a34e2b21d44a0920d030eca41d6e">00372</a>    T&amp; at(<span class="keyword">const</span> key_type&amp; k)
<a name="l00373"></a>00373    {
<a name="l00374"></a>00374       iterator i = this-&gt;find(k);
<a name="l00375"></a>00375       <span class="keywordflow">if</span>(i == this-&gt;end()){
<a name="l00376"></a>00376          <span class="keywordflow">throw</span> std::out_of_range(<span class="stringliteral">&quot;key not found&quot;</span>);
<a name="l00377"></a>00377       }
<a name="l00378"></a>00378       <span class="keywordflow">return</span> i-&gt;second;
<a name="l00379"></a>00379    }
<a name="l00380"></a>00380 
<a name="l00384"></a><a class="code" href="classboost_1_1container_1_1map.html#aea38a5a837ac0a7bea302bb005fd901e">00384</a>    <span class="keyword">const</span> T&amp; at(<span class="keyword">const</span> key_type&amp; k)<span class="keyword"> const</span>
<a name="l00385"></a>00385 <span class="keyword">   </span>{
<a name="l00386"></a>00386       const_iterator i = this-&gt;find(k);
<a name="l00387"></a>00387       <span class="keywordflow">if</span>(i == this-&gt;end()){
<a name="l00388"></a>00388          <span class="keywordflow">throw</span> std::out_of_range(<span class="stringliteral">&quot;key not found&quot;</span>);
<a name="l00389"></a>00389       }
<a name="l00390"></a>00390       <span class="keywordflow">return</span> i-&gt;second;
<a name="l00391"></a>00391    }
<a name="l00392"></a>00392 
<a name="l00399"></a><a class="code" href="classboost_1_1container_1_1map.html#a081ebd8457e8a8eff9e95bd2734360d0">00399</a>    <span class="keywordtype">void</span> swap(<a class="code" href="classboost_1_1container_1_1map.html">map</a>&amp; x)
<a name="l00400"></a>00400    { m_tree.swap(x.m_tree); }
<a name="l00401"></a>00401 
<a name="l00410"></a><a class="code" href="classboost_1_1container_1_1map.html#a0da78b847cc24a706a58f34429841617">00410</a>    std::pair&lt;iterator,bool&gt; insert(<span class="keyword">const</span> value_type&amp; x) 
<a name="l00411"></a>00411    { <span class="keywordflow">return</span> m_tree.insert_unique(x); }
<a name="l00412"></a>00412 
<a name="l00421"></a><a class="code" href="classboost_1_1container_1_1map.html#a614b452d11c539022b2ba1a2b0a5912e">00421</a>    std::pair&lt;iterator,bool&gt; insert(<span class="keyword">const</span> nonconst_value_type&amp; x) 
<a name="l00422"></a>00422    { <span class="keywordflow">return</span> m_tree.insert_unique(x); }
<a name="l00423"></a>00423 
<a name="l00432"></a><a class="code" href="classboost_1_1container_1_1map.html#afe94d889ac3fdf3610ce9e0ab735f425">00432</a>    std::pair&lt;iterator,bool&gt; insert(BOOST_MOVE_MACRO_RV_REF(nonconst_value_type) x) 
<a name="l00433"></a>00433    { <span class="keywordflow">return</span> m_tree.insert_unique(BOOST_CONTAINER_MOVE_NAMESPACE::move(x)); }
<a name="l00434"></a>00434 
<a name="l00443"></a><a class="code" href="classboost_1_1container_1_1map.html#a4239994f61545d1e673f954596403887">00443</a>    std::pair&lt;iterator,bool&gt; insert(BOOST_MOVE_MACRO_RV_REF(<a class="code" href="structboost_1_1container_1_1containers__detail_1_1pair.html">nonconst_impl_value_type</a>) x) 
<a name="l00444"></a>00444    { <span class="keywordflow">return</span> m_tree.insert_unique(BOOST_CONTAINER_MOVE_NAMESPACE::move(x)); }
<a name="l00445"></a>00445 
<a name="l00454"></a><a class="code" href="classboost_1_1container_1_1map.html#afdabe0d884ac2fe22438f3089fa2b4ce">00454</a>    std::pair&lt;iterator,bool&gt; insert(BOOST_MOVE_MACRO_RV_REF(value_type) x) 
<a name="l00455"></a>00455    { <span class="keywordflow">return</span> m_tree.insert_unique(BOOST_CONTAINER_MOVE_NAMESPACE::move(x)); }
<a name="l00456"></a>00456 
<a name="l00466"></a><a class="code" href="classboost_1_1container_1_1map.html#a4fd9ecebda1ae03c693fba29ca625c92">00466</a>    iterator insert(iterator position, <span class="keyword">const</span> value_type&amp; x)
<a name="l00467"></a>00467    { <span class="keywordflow">return</span> m_tree.insert_unique(position, x); }
<a name="l00468"></a>00468 
<a name="l00478"></a><a class="code" href="classboost_1_1container_1_1map.html#aeb6259623b8521cca0c757c9f22dd0e9">00478</a>    iterator insert(iterator position, BOOST_MOVE_MACRO_RV_REF(nonconst_value_type) x)
<a name="l00479"></a>00479    { <span class="keywordflow">return</span> m_tree.insert_unique(position, BOOST_CONTAINER_MOVE_NAMESPACE::move(x)); }
<a name="l00480"></a>00480 
<a name="l00490"></a><a class="code" href="classboost_1_1container_1_1map.html#a522a5d174741c44198d6f3e9892855c3">00490</a>    iterator insert(iterator position, BOOST_MOVE_MACRO_RV_REF(<a class="code" href="structboost_1_1container_1_1containers__detail_1_1pair.html">nonconst_impl_value_type</a>) x)
<a name="l00491"></a>00491    { <span class="keywordflow">return</span> m_tree.insert_unique(position, BOOST_CONTAINER_MOVE_NAMESPACE::move(x)); }
<a name="l00492"></a>00492 
<a name="l00499"></a><a class="code" href="classboost_1_1container_1_1map.html#a90e1c947dbcc0e27e46745492b543d20">00499</a>    iterator insert(iterator position, <span class="keyword">const</span> nonconst_value_type&amp; x)
<a name="l00500"></a>00500    { <span class="keywordflow">return</span> m_tree.insert_unique(position, x); }
<a name="l00501"></a>00501 
<a name="l00508"></a><a class="code" href="classboost_1_1container_1_1map.html#aad8137d94d67dff63046e2cbf9699655">00508</a>    iterator insert(iterator position, BOOST_MOVE_MACRO_RV_REF(value_type) x)
<a name="l00509"></a>00509    { <span class="keywordflow">return</span> m_tree.insert_unique(position, BOOST_CONTAINER_MOVE_NAMESPACE::move(x)); }
<a name="l00510"></a>00510 
<a name="l00517"></a>00517    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
<a name="l00518"></a><a class="code" href="classboost_1_1container_1_1map.html#aac89a079f7d58c622cfaf06ce08189bb">00518</a>    <span class="keywordtype">void</span> insert(InputIterator first, InputIterator last) 
<a name="l00519"></a>00519    {  m_tree.insert_unique(first, last);  }
<a name="l00520"></a>00520 
<a name="l00521"></a>00521 <span class="preprocessor">   #if defined(BOOST_CONTAINERS_PERFECT_FORWARDING) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)</span>
<a name="l00522"></a>00522 <span class="preprocessor"></span>
<a name="l00533"></a>00533    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;
<a name="l00534"></a>00534    iterator emplace(Args&amp;&amp;... args)
<a name="l00535"></a>00535    {  <span class="keywordflow">return</span> m_tree.emplace_unique(BOOST_CONTAINER_MOVE_NAMESPACE::forward&lt;Args&gt;(args)...); }
<a name="l00536"></a>00536 
<a name="l00547"></a>00547    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;
<a name="l00548"></a>00548    iterator emplace_hint(const_iterator hint, Args&amp;&amp;... args)
<a name="l00549"></a>00549    {  <span class="keywordflow">return</span> m_tree.emplace_hint_unique(hint, BOOST_CONTAINER_MOVE_NAMESPACE::forward&lt;Args&gt;(args)...); }
<a name="l00550"></a>00550 
<a name="l00551"></a>00551 <span class="preprocessor">   #else //#ifdef BOOST_CONTAINERS_PERFECT_FORWARDING</span>
<a name="l00552"></a>00552 <span class="preprocessor"></span>
<a name="l00553"></a>00553    iterator emplace()
<a name="l00554"></a>00554    {  <span class="keywordflow">return</span> m_tree.emplace_unique(); }
<a name="l00555"></a>00555 
<a name="l00556"></a>00556    iterator emplace_hint(const_iterator hint)
<a name="l00557"></a>00557    {  <span class="keywordflow">return</span> m_tree.emplace_hint_unique(hint); }
<a name="l00558"></a>00558 
<a name="l00559"></a>00559 <span class="preprocessor">   #define BOOST_PP_LOCAL_MACRO(n)                                                                       \</span>
<a name="l00560"></a>00560 <span class="preprocessor">   template&lt;BOOST_PP_ENUM_PARAMS(n, class P)&gt;                                                            \</span>
<a name="l00561"></a>00561 <span class="preprocessor">   iterator emplace(BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_LIST, _))                               \</span>
<a name="l00562"></a>00562 <span class="preprocessor">   {  return m_tree.emplace_unique(BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_FORWARD, _)); }          \</span>
<a name="l00563"></a>00563 <span class="preprocessor">                                                                                                         \</span>
<a name="l00564"></a>00564 <span class="preprocessor">   template&lt;BOOST_PP_ENUM_PARAMS(n, class P)&gt;                                                            \</span>
<a name="l00565"></a>00565 <span class="preprocessor">   iterator emplace_hint(const_iterator hint, BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_LIST, _))     \</span>
<a name="l00566"></a>00566 <span class="preprocessor">   {  return m_tree.emplace_hint_unique(hint, BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_FORWARD, _));}\</span>
<a name="l00567"></a>00567 <span class="preprocessor"></span>
<a name="l00568"></a>00568 <span class="preprocessor">   #define BOOST_PP_LOCAL_LIMITS (1, BOOST_CONTAINERS_MAX_CONSTRUCTOR_PARAMETERS)</span>
<a name="l00569"></a>00569 <span class="preprocessor"></span><span class="preprocessor">   #include BOOST_PP_LOCAL_ITERATE()</span>
<a name="l00570"></a>00570 <span class="preprocessor"></span>
<a name="l00571"></a>00571 <span class="preprocessor">   #endif   //#ifdef BOOST_CONTAINERS_PERFECT_FORWARDING</span>
<a name="l00572"></a>00572 <span class="preprocessor"></span>
<a name="l00580"></a><a class="code" href="classboost_1_1container_1_1map.html#af6cbb6c9a2638b11da744013f72b3555">00580</a>    iterator erase(const_iterator position) 
<a name="l00581"></a>00581    { <span class="keywordflow">return</span> m_tree.erase(position); }
<a name="l00582"></a>00582 
<a name="l00588"></a><a class="code" href="classboost_1_1container_1_1map.html#a25211c9ed1a4f86102b7904935daa562">00588</a>    size_type erase(<span class="keyword">const</span> key_type&amp; x) 
<a name="l00589"></a>00589    { <span class="keywordflow">return</span> m_tree.erase(x); }
<a name="l00590"></a>00590 
<a name="l00596"></a><a class="code" href="classboost_1_1container_1_1map.html#ac516e29a77fc4fff600fc32a4fb80220">00596</a>    iterator erase(const_iterator first, const_iterator last)
<a name="l00597"></a>00597    { <span class="keywordflow">return</span> m_tree.erase(first, last); }
<a name="l00598"></a>00598 
<a name="l00604"></a><a class="code" href="classboost_1_1container_1_1map.html#ab9f0f8d9aa29d2f9a284fb9351860437">00604</a>    <span class="keywordtype">void</span> clear() 
<a name="l00605"></a>00605    { m_tree.clear(); }
<a name="l00606"></a>00606 
<a name="l00611"></a><a class="code" href="classboost_1_1container_1_1map.html#a02025a1ae3a1fd8951698f378af04bcd">00611</a>    iterator find(<span class="keyword">const</span> key_type&amp; x) 
<a name="l00612"></a>00612    { <span class="keywordflow">return</span> m_tree.find(x); }
<a name="l00613"></a>00613 
<a name="l00618"></a><a class="code" href="classboost_1_1container_1_1map.html#a9fe11d9e2af0376eef1ee1cb1ebea219">00618</a>    const_iterator find(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l00619"></a>00619 <span class="keyword">   </span>{ <span class="keywordflow">return</span> m_tree.find(x); }
<a name="l00620"></a>00620 
<a name="l00624"></a><a class="code" href="classboost_1_1container_1_1map.html#a34d822290a17a27ca9bfd7460d04deaa">00624</a>    size_type count(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l00625"></a>00625 <span class="keyword">   </span>{  <span class="keywordflow">return</span> m_tree.find(x) == m_tree.end() ? 0 : 1;  }
<a name="l00626"></a>00626 
<a name="l00631"></a><a class="code" href="classboost_1_1container_1_1map.html#a22ffa84d207fe34ab7886e697a2e2a1e">00631</a>    iterator lower_bound(<span class="keyword">const</span> key_type&amp; x) 
<a name="l00632"></a>00632    {  <span class="keywordflow">return</span> m_tree.lower_bound(x); }
<a name="l00633"></a>00633 
<a name="l00638"></a><a class="code" href="classboost_1_1container_1_1map.html#a5276abd36d7554b6d4a7b8733fc3d9d5">00638</a>    const_iterator lower_bound(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l00639"></a>00639 <span class="keyword">   </span>{  <span class="keywordflow">return</span> m_tree.lower_bound(x); }
<a name="l00640"></a>00640 
<a name="l00645"></a><a class="code" href="classboost_1_1container_1_1map.html#a01d2e9089d5a533e0e4ba3edacd92232">00645</a>    iterator upper_bound(<span class="keyword">const</span> key_type&amp; x) 
<a name="l00646"></a>00646    {  <span class="keywordflow">return</span> m_tree.upper_bound(x); }
<a name="l00647"></a>00647 
<a name="l00652"></a><a class="code" href="classboost_1_1container_1_1map.html#a2db0ad22e86ab844ca5880ff2fea0338">00652</a>    const_iterator upper_bound(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l00653"></a>00653 <span class="keyword">   </span>{  <span class="keywordflow">return</span> m_tree.upper_bound(x); }
<a name="l00654"></a>00654 
<a name="l00658"></a><a class="code" href="classboost_1_1container_1_1map.html#ae1e51371c2927d1a82443a06831d6007">00658</a>    std::pair&lt;iterator,iterator&gt; equal_range(<span class="keyword">const</span> key_type&amp; x) 
<a name="l00659"></a>00659    {  <span class="keywordflow">return</span> m_tree.equal_range(x); }
<a name="l00660"></a>00660 
<a name="l00664"></a><a class="code" href="classboost_1_1container_1_1map.html#ab79ca52b20440a540975fc9f0097fefe">00664</a>    std::pair&lt;const_iterator,const_iterator&gt; equal_range(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l00665"></a>00665 <span class="keyword">   </span>{  <span class="keywordflow">return</span> m_tree.equal_range(x); }
<a name="l00666"></a>00666 
<a name="l00668"></a>00668    <span class="keyword">template</span> &lt;<span class="keyword">class</span> K1, <span class="keyword">class</span> T1, <span class="keyword">class</span> C1, <span class="keyword">class</span> A1&gt;
<a name="l00669"></a>00669    <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator== (<span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1map.html">map&lt;K1, T1, C1, A1&gt;</a>&amp;,
<a name="l00670"></a>00670                            <span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1map.html">map&lt;K1, T1, C1, A1&gt;</a>&amp;);
<a name="l00671"></a>00671    <span class="keyword">template</span> &lt;<span class="keyword">class</span> K1, <span class="keyword">class</span> T1, <span class="keyword">class</span> C1, <span class="keyword">class</span> A1&gt;
<a name="l00672"></a>00672    <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator&lt; (const map&lt;K1, T1, C1, A1&gt;&amp;,
<a name="l00673"></a>00673                            <span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1map.html">map&lt;K1, T1, C1, A1&gt;</a>&amp;);
<a name="l00675"></a>00675 };
<a name="l00676"></a>00676 
<a name="l00677"></a>00677 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00678"></a>00678 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> map&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l00679"></a>00679                        <span class="keyword">const</span> map&lt;Key,T,Pred,Alloc&gt;&amp; y) 
<a name="l00680"></a>00680    {  <span class="keywordflow">return</span> x.m_tree == y.m_tree;  }
<a name="l00681"></a>00681 
<a name="l00682"></a>00682 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00683"></a>00683 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&lt;(const map&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l00684"></a>00684                       <span class="keyword">const</span> map&lt;Key,T,Pred,Alloc&gt;&amp; y) 
<a name="l00685"></a>00685    {  <span class="keywordflow">return</span> x.m_tree &lt; y.m_tree;   }
<a name="l00686"></a>00686 
<a name="l00687"></a>00687 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00688"></a>00688 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> map&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l00689"></a>00689                        <span class="keyword">const</span> map&lt;Key,T,Pred,Alloc&gt;&amp; y) 
<a name="l00690"></a>00690    {  <span class="keywordflow">return</span> !(x == y); }
<a name="l00691"></a>00691 
<a name="l00692"></a>00692 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00693"></a>00693 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&gt;(<span class="keyword">const</span> map&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l00694"></a>00694                       <span class="keyword">const</span> map&lt;Key,T,Pred,Alloc&gt;&amp; y) 
<a name="l00695"></a>00695    {  <span class="keywordflow">return</span> y &lt; x;  }
<a name="l00696"></a>00696 
<a name="l00697"></a>00697 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00698"></a>00698 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&lt;=(const map&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l00699"></a>00699                        <span class="keyword">const</span> map&lt;Key,T,Pred,Alloc&gt;&amp; y) 
<a name="l00700"></a>00700    {  <span class="keywordflow">return</span> !(y &lt; x);  }
<a name="l00701"></a>00701 
<a name="l00702"></a>00702 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00703"></a>00703 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&gt;=(<span class="keyword">const</span> map&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l00704"></a>00704                        <span class="keyword">const</span> map&lt;Key,T,Pred,Alloc&gt;&amp; y) 
<a name="l00705"></a>00705    {  <span class="keywordflow">return</span> !(x &lt; y);  }
<a name="l00706"></a>00706 
<a name="l00707"></a>00707 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00708"></a>00708 <span class="keyword">inline</span> <span class="keywordtype">void</span> swap(map&lt;Key,T,Pred,Alloc&gt;&amp; x, map&lt;Key,T,Pred,Alloc&gt;&amp; y) 
<a name="l00709"></a>00709    {  x.swap(y);  }
<a name="l00710"></a>00710 
<a name="l00712"></a>00712 
<a name="l00713"></a>00713 <span class="comment">// Forward declaration of operators &lt; and ==, needed for friend declaration.</span>
<a name="l00714"></a>00714 
<a name="l00715"></a>00715 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00716"></a>00716 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> multimap&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l00717"></a>00717                        <span class="keyword">const</span> multimap&lt;Key,T,Pred,Alloc&gt;&amp; y);
<a name="l00718"></a>00718 
<a name="l00719"></a>00719 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00720"></a>00720 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&lt;(const multimap&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l00721"></a>00721                       <span class="keyword">const</span> multimap&lt;Key,T,Pred,Alloc&gt;&amp; y);
<a name="l00722"></a>00722 
<a name="l00723"></a>00723 }  <span class="comment">//namespace container {</span>
<a name="l00724"></a>00724 <span class="comment">/*</span>
<a name="l00727"></a>00727 <span class="comment">template &lt;class K, class T, class C, class A&gt;</span>
<a name="l00728"></a>00728 <span class="comment">struct has_trivial_destructor_after_move&lt;boost::container::map&lt;K, T, C, A&gt; &gt;</span>
<a name="l00729"></a>00729 <span class="comment">{</span>
<a name="l00730"></a>00730 <span class="comment">   static const bool value = has_trivial_destructor&lt;A&gt;::value &amp;&amp; has_trivial_destructor&lt;C&gt;::value;</span>
<a name="l00731"></a>00731 <span class="comment">};</span>
<a name="l00732"></a>00732 <span class="comment">*/</span>
<a name="l00733"></a>00733 <span class="keyword">namespace </span>container {
<a name="l00734"></a>00734 
<a name="l00736"></a>00736 
<a name="l00750"></a>00750 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00751"></a><a class="code" href="classboost_1_1container_1_1multimap.html">00751</a> <span class="keyword">class </span><a class="code" href="classboost_1_1container_1_1multimap.html">multimap</a> 
<a name="l00752"></a>00752 {
<a name="l00754"></a>00754    <span class="keyword">private</span>:
<a name="l00755"></a>00755    BOOST_MOVE_MACRO_COPYABLE_AND_MOVABLE(<a class="code" href="classboost_1_1container_1_1multimap.html">multimap</a>)
<a name="l00756"></a>00756    <span class="keyword">typedef</span> <a class="code" href="classboost_1_1container_1_1containers__detail_1_1rbtree.html">containers_detail::rbtree</a>&lt;Key, 
<a name="l00757"></a>00757                            std::pair&lt;const Key, T&gt;, 
<a name="l00758"></a>00758                            <a class="code" href="structboost_1_1container_1_1containers__detail_1_1select1st.html">containers_detail::select1st&lt; std::pair&lt;const Key, T&gt;</a> &gt;, 
<a name="l00759"></a>00759                            Pred, 
<a name="l00760"></a>00760                            Alloc&gt; tree_t;
<a name="l00761"></a>00761    tree_t m_tree;  <span class="comment">// red-black tree representing map</span>
<a name="l00763"></a>00763 <span class="comment"></span>
<a name="l00764"></a>00764    <span class="keyword">public</span>:
<a name="l00765"></a>00765 
<a name="l00766"></a>00766    <span class="comment">// typedefs:</span>
<a name="l00767"></a>00767    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::key_type               key_type;
<a name="l00768"></a>00768    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::value_type             value_type;
<a name="l00769"></a>00769    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::pointer                pointer;
<a name="l00770"></a>00770    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::const_pointer          const_pointer;
<a name="l00771"></a>00771    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::reference              reference;
<a name="l00772"></a>00772    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::const_reference        const_reference;
<a name="l00773"></a>00773    <span class="keyword">typedef</span> T                                       mapped_type;
<a name="l00774"></a>00774    <span class="keyword">typedef</span> Pred                                    key_compare;
<a name="l00775"></a>00775    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::iterator               iterator;
<a name="l00776"></a>00776    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::const_iterator         const_iterator;
<a name="l00777"></a>00777    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::reverse_iterator       reverse_iterator;
<a name="l00778"></a>00778    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::const_reverse_iterator const_reverse_iterator;
<a name="l00779"></a>00779    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::size_type              size_type;
<a name="l00780"></a>00780    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::difference_type        difference_type;
<a name="l00781"></a>00781    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::allocator_type         allocator_type;
<a name="l00782"></a>00782    <span class="keyword">typedef</span> <span class="keyword">typename</span> tree_t::stored_allocator_type  stored_allocator_type;
<a name="l00783"></a>00783    <span class="keyword">typedef</span> std::pair&lt;key_type, mapped_type&gt;        nonconst_value_type;
<a name="l00784"></a>00784    <span class="keyword">typedef</span> <a class="code" href="structboost_1_1container_1_1containers__detail_1_1pair.html">containers_detail::pair</a>
<a name="l00785"></a>00785       &lt;key_type, mapped_type&gt;                      <a class="code" href="structboost_1_1container_1_1containers__detail_1_1pair.html">nonconst_impl_value_type</a>;
<a name="l00786"></a>00786 
<a name="l00788"></a>00788    <span class="keyword">class </span>value_compare_impl
<a name="l00789"></a>00789       :  <span class="keyword">public</span> Pred,
<a name="l00790"></a>00790          <span class="keyword">public</span> std::binary_function&lt;value_type, value_type, bool&gt; 
<a name="l00791"></a>00791    {
<a name="l00792"></a>00792       <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classboost_1_1container_1_1multimap.html">multimap</a>&lt;Key,T,Pred,Alloc&gt;;
<a name="l00793"></a>00793     <span class="keyword">protected</span> :
<a name="l00794"></a>00794       value_compare_impl(<span class="keyword">const</span> Pred &amp;c) : Pred(c) {}
<a name="l00795"></a>00795     <span class="keyword">public</span>:
<a name="l00796"></a>00796       <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> value_type&amp; x, <span class="keyword">const</span> value_type&amp; y)<span class="keyword"> const </span>{
<a name="l00797"></a>00797          <span class="keywordflow">return</span> Pred::operator()(x.first, y.first);
<a name="l00798"></a>00798       }
<a name="l00799"></a>00799    };
<a name="l00801"></a>00801    <span class="keyword">typedef</span> value_compare_impl                      value_compare;
<a name="l00802"></a>00802 
<a name="l00807"></a><a class="code" href="classboost_1_1container_1_1multimap.html#aa54c85b947048a6dbe00cdce6efcd78c">00807</a>    <span class="keyword">explicit</span> <a class="code" href="classboost_1_1container_1_1multimap.html">multimap</a>(<span class="keyword">const</span> Pred&amp; comp = Pred(),
<a name="l00808"></a>00808                      <span class="keyword">const</span> allocator_type&amp; a = allocator_type())
<a name="l00809"></a>00809       : m_tree(comp, a)
<a name="l00810"></a>00810    {}
<a name="l00811"></a>00811 
<a name="l00817"></a>00817    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
<a name="l00818"></a><a class="code" href="classboost_1_1container_1_1multimap.html#ad1a8c481644857d846b73e8e9d348955">00818</a>    <a class="code" href="classboost_1_1container_1_1multimap.html">multimap</a>(InputIterator first, InputIterator last,
<a name="l00819"></a>00819             <span class="keyword">const</span> Pred&amp; comp = Pred(),
<a name="l00820"></a>00820             <span class="keyword">const</span> allocator_type&amp; a = allocator_type())
<a name="l00821"></a>00821       : m_tree(first, last, comp, a, false) 
<a name="l00822"></a>00822    {}
<a name="l00823"></a>00823 
<a name="l00831"></a>00831    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
<a name="l00832"></a><a class="code" href="classboost_1_1container_1_1multimap.html#af8cf65ddbf08438ccc22a1b32477b4b6">00832</a>    <a class="code" href="classboost_1_1container_1_1multimap.html">multimap</a>(ordered_range_t ordered_range, InputIterator first, InputIterator last, <span class="keyword">const</span> Pred&amp; comp = Pred(),
<a name="l00833"></a>00833          <span class="keyword">const</span> allocator_type&amp; a = allocator_type())
<a name="l00834"></a>00834       : m_tree(ordered_range, first, last, comp, a) 
<a name="l00835"></a>00835    {}
<a name="l00836"></a>00836 
<a name="l00837"></a>00837 
<a name="l00841"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a314365b596c114e0e820604fd99a4154">00841</a>    <a class="code" href="classboost_1_1container_1_1multimap.html">multimap</a>(<span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1multimap.html">multimap&lt;Key,T,Pred,Alloc&gt;</a>&amp; x) 
<a name="l00842"></a>00842       : m_tree(x.m_tree)
<a name="l00843"></a>00843    {}
<a name="l00844"></a>00844 
<a name="l00850"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a49ed2b0568a814ca4c28f81b85880e28">00850</a>    <a class="code" href="classboost_1_1container_1_1multimap.html">multimap</a>(BOOST_MOVE_MACRO_RV_REF(<a class="code" href="classboost_1_1container_1_1multimap.html">multimap</a>) x) 
<a name="l00851"></a>00851       : m_tree(BOOST_CONTAINER_MOVE_NAMESPACE::move(x.m_tree))
<a name="l00852"></a>00852    {}
<a name="l00853"></a>00853 
<a name="l00857"></a><a class="code" href="classboost_1_1container_1_1multimap.html#ace0b77c1d76694fc493aeffc1b0d1fb1">00857</a>    <a class="code" href="classboost_1_1container_1_1multimap.html">multimap</a>&amp; operator=(BOOST_MOVE_MACRO_COPY_ASSIGN_REF(<a class="code" href="classboost_1_1container_1_1multimap.html">multimap</a>) x) 
<a name="l00858"></a>00858    {  m_tree = x.m_tree;   <span class="keywordflow">return</span> *<span class="keyword">this</span>;  }
<a name="l00859"></a>00859 
<a name="l00863"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a5662ed3284a2fc50782094e2c7ebc02b">00863</a>    <a class="code" href="classboost_1_1container_1_1multimap.html">multimap</a>&amp; operator=(BOOST_MOVE_MACRO_RV_REF(<a class="code" href="classboost_1_1container_1_1multimap.html">multimap</a>) x) 
<a name="l00864"></a>00864    {  m_tree = BOOST_CONTAINER_MOVE_NAMESPACE::move(x.m_tree);   <span class="keywordflow">return</span> *<span class="keyword">this</span>;  }
<a name="l00865"></a>00865 
<a name="l00870"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a9a5fc0b3c9d3b2ea9eedee1b2f94990c">00870</a>    key_compare key_comp()<span class="keyword"> const </span>
<a name="l00871"></a>00871 <span class="keyword">   </span>{ <span class="keywordflow">return</span> m_tree.key_comp(); }
<a name="l00872"></a>00872 
<a name="l00877"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a490564e1092a6a121fa9146d6f3d5ec4">00877</a>    value_compare value_comp()<span class="keyword"> const </span>
<a name="l00878"></a>00878 <span class="keyword">   </span>{ <span class="keywordflow">return</span> value_compare(m_tree.key_comp()); }
<a name="l00879"></a>00879 
<a name="l00884"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a2a270eafa4b31e1c4d1b6fa4d9f985c9">00884</a>    allocator_type get_allocator()<span class="keyword"> const </span>
<a name="l00885"></a>00885 <span class="keyword">   </span>{ <span class="keywordflow">return</span> m_tree.get_allocator(); }
<a name="l00886"></a>00886 
<a name="l00887"></a>00887    <span class="keyword">const</span> stored_allocator_type &amp;get_stored_allocator()<span class="keyword"> const </span>
<a name="l00888"></a>00888 <span class="keyword">   </span>{ <span class="keywordflow">return</span> m_tree.get_stored_allocator(); }
<a name="l00889"></a>00889 
<a name="l00890"></a>00890    stored_allocator_type &amp;get_stored_allocator()
<a name="l00891"></a>00891    { <span class="keywordflow">return</span> m_tree.get_stored_allocator(); }
<a name="l00892"></a>00892 
<a name="l00898"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a8fbdd666c426b5f34eb3fce87638ecf8">00898</a>    iterator begin() 
<a name="l00899"></a>00899    { <span class="keywordflow">return</span> m_tree.begin(); }
<a name="l00900"></a>00900 
<a name="l00906"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a5eb97f16640d0d96c15a9bdc78441be2">00906</a>    const_iterator begin()<span class="keyword"> const </span>
<a name="l00907"></a>00907 <span class="keyword">   </span>{ <span class="keywordflow">return</span> m_tree.begin(); }
<a name="l00908"></a>00908 
<a name="l00914"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a5f5b658b2f2487186b55c4c6a394eb9a">00914</a>    iterator end() 
<a name="l00915"></a>00915    { <span class="keywordflow">return</span> m_tree.end(); }
<a name="l00916"></a>00916 
<a name="l00922"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a4c267e6e74a176bb1ea11feb2894fb62">00922</a>    const_iterator end()<span class="keyword"> const </span>
<a name="l00923"></a>00923 <span class="keyword">   </span>{ <span class="keywordflow">return</span> m_tree.end(); }
<a name="l00924"></a>00924 
<a name="l00931"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a4cba7f7d71e4e335a8bd6dbd9cf62f77">00931</a>    reverse_iterator rbegin() 
<a name="l00932"></a>00932    { <span class="keywordflow">return</span> m_tree.rbegin(); }
<a name="l00933"></a>00933 
<a name="l00940"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a86b0ef9b50b4f5a4f924bbc3a63a7817">00940</a>    const_reverse_iterator rbegin()<span class="keyword"> const </span>
<a name="l00941"></a>00941 <span class="keyword">   </span>{ <span class="keywordflow">return</span> m_tree.rbegin(); }
<a name="l00942"></a>00942 
<a name="l00949"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a3fc9fbf1dbca73c2a48c0d3ec6d81bab">00949</a>    reverse_iterator rend() 
<a name="l00950"></a>00950    { <span class="keywordflow">return</span> m_tree.rend(); }
<a name="l00951"></a>00951 
<a name="l00958"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a7351296fc30c8de9d22bf6b0a0954683">00958</a>    const_reverse_iterator rend()<span class="keyword"> const </span>
<a name="l00959"></a>00959 <span class="keyword">   </span>{ <span class="keywordflow">return</span> m_tree.rend(); }
<a name="l00960"></a>00960 
<a name="l00966"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a02d6427d066edaaf11dfa8f9863eea24">00966</a>    <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>
<a name="l00967"></a>00967 <span class="keyword">   </span>{ <span class="keywordflow">return</span> m_tree.empty(); }
<a name="l00968"></a>00968 
<a name="l00974"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a8c211ee163c054d0f353371f2e231cee">00974</a>    size_type size()<span class="keyword"> const </span>
<a name="l00975"></a>00975 <span class="keyword">   </span>{ <span class="keywordflow">return</span> m_tree.size(); }
<a name="l00976"></a>00976 
<a name="l00982"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a6fa86bafc1a8428d8556cf1230e9f359">00982</a>    size_type max_size()<span class="keyword"> const </span>
<a name="l00983"></a>00983 <span class="keyword">   </span>{ <span class="keywordflow">return</span> m_tree.max_size(); }
<a name="l00984"></a>00984 
<a name="l00991"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a1489b99aa4a438aaecc2a69f5aa84ab9">00991</a>    <span class="keywordtype">void</span> swap(<a class="code" href="classboost_1_1container_1_1multimap.html">multimap</a>&amp; x)
<a name="l00992"></a>00992    { m_tree.swap(x.m_tree); }
<a name="l00993"></a>00993 
<a name="l00998"></a><a class="code" href="classboost_1_1container_1_1multimap.html#ada573fbf2fe1c811e2e261ed91d9030d">00998</a>    iterator insert(<span class="keyword">const</span> value_type&amp; x) 
<a name="l00999"></a>00999    { <span class="keywordflow">return</span> m_tree.insert_equal(x); }
<a name="l01000"></a>01000 
<a name="l01005"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a9acc7352b8ceffbeae2d6e6ffd0c6864">01005</a>    iterator insert(<span class="keyword">const</span> nonconst_value_type&amp; x) 
<a name="l01006"></a>01006    { <span class="keywordflow">return</span> m_tree.insert_equal(x); }
<a name="l01007"></a>01007 
<a name="l01012"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a5c674cfdcccb12631337cd0be571d505">01012</a>    iterator insert(BOOST_MOVE_MACRO_RV_REF(nonconst_value_type) x) 
<a name="l01013"></a>01013    { <span class="keywordflow">return</span> m_tree.insert_equal(BOOST_CONTAINER_MOVE_NAMESPACE::move(x)); }
<a name="l01014"></a>01014 
<a name="l01019"></a><a class="code" href="classboost_1_1container_1_1multimap.html#aaa00acef1eb6b836d42bf8f7591cafba">01019</a>    iterator insert(BOOST_MOVE_MACRO_RV_REF(<a class="code" href="structboost_1_1container_1_1containers__detail_1_1pair.html">nonconst_impl_value_type</a>) x) 
<a name="l01020"></a>01020    { <span class="keywordflow">return</span> m_tree.insert_equal(BOOST_CONTAINER_MOVE_NAMESPACE::move(x)); }
<a name="l01021"></a>01021 
<a name="l01030"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a02e2179fb17ade2ea5875b6aa585e894">01030</a>    iterator insert(iterator position, <span class="keyword">const</span> value_type&amp; x)
<a name="l01031"></a>01031    { <span class="keywordflow">return</span> m_tree.insert_equal(position, x); }
<a name="l01032"></a>01032 
<a name="l01041"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a2f963154c4ac6a1ba3ff8f5c2ea58a9a">01041</a>    iterator insert(iterator position, <span class="keyword">const</span> nonconst_value_type&amp; x)
<a name="l01042"></a>01042    { <span class="keywordflow">return</span> m_tree.insert_equal(position, x); }
<a name="l01043"></a>01043 
<a name="l01052"></a><a class="code" href="classboost_1_1container_1_1multimap.html#af45efeb132879cfe6dc62aa0397c6a54">01052</a>    iterator insert(iterator position, BOOST_MOVE_MACRO_RV_REF(nonconst_value_type) x)
<a name="l01053"></a>01053    { <span class="keywordflow">return</span> m_tree.insert_equal(position, BOOST_CONTAINER_MOVE_NAMESPACE::move(x)); }
<a name="l01054"></a>01054 
<a name="l01063"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a34a1462ef1933fdf525103daf8d24719">01063</a>    iterator insert(iterator position, BOOST_MOVE_MACRO_RV_REF(<a class="code" href="structboost_1_1container_1_1containers__detail_1_1pair.html">nonconst_impl_value_type</a>) x)
<a name="l01064"></a>01064    { <span class="keywordflow">return</span> m_tree.insert_equal(position, BOOST_CONTAINER_MOVE_NAMESPACE::move(x)); }
<a name="l01065"></a>01065 
<a name="l01071"></a>01071    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
<a name="l01072"></a><a class="code" href="classboost_1_1container_1_1multimap.html#ae135dd972e3a8ab16abc6f0da14a3349">01072</a>    <span class="keywordtype">void</span> insert(InputIterator first, InputIterator last) 
<a name="l01073"></a>01073    {  m_tree.insert_equal(first, last); }
<a name="l01074"></a>01074 
<a name="l01075"></a>01075 <span class="preprocessor">   #if defined(BOOST_CONTAINERS_PERFECT_FORWARDING) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)</span>
<a name="l01076"></a>01076 <span class="preprocessor"></span>
<a name="l01086"></a>01086    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;
<a name="l01087"></a>01087    iterator emplace(Args&amp;&amp;... args)
<a name="l01088"></a>01088    {  <span class="keywordflow">return</span> m_tree.emplace_equal(BOOST_CONTAINER_MOVE_NAMESPACE::forward&lt;Args&gt;(args)...); }
<a name="l01089"></a>01089 
<a name="l01099"></a>01099    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;
<a name="l01100"></a>01100    iterator emplace_hint(const_iterator hint, Args&amp;&amp;... args)
<a name="l01101"></a>01101    {  <span class="keywordflow">return</span> m_tree.emplace_hint_equal(hint, BOOST_CONTAINER_MOVE_NAMESPACE::forward&lt;Args&gt;(args)...); }
<a name="l01102"></a>01102 
<a name="l01103"></a>01103 <span class="preprocessor">   #else //#ifdef BOOST_CONTAINERS_PERFECT_FORWARDING</span>
<a name="l01104"></a>01104 <span class="preprocessor"></span>
<a name="l01105"></a>01105    iterator emplace()
<a name="l01106"></a>01106    {  <span class="keywordflow">return</span> m_tree.emplace_equal(); }
<a name="l01107"></a>01107 
<a name="l01108"></a>01108    iterator emplace_hint(const_iterator hint)
<a name="l01109"></a>01109    {  <span class="keywordflow">return</span> m_tree.emplace_hint_equal(hint); }
<a name="l01110"></a>01110 
<a name="l01111"></a>01111 <span class="preprocessor">   #define BOOST_PP_LOCAL_MACRO(n)                                                                       \</span>
<a name="l01112"></a>01112 <span class="preprocessor">   template&lt;BOOST_PP_ENUM_PARAMS(n, class P)&gt;                                                            \</span>
<a name="l01113"></a>01113 <span class="preprocessor">   iterator emplace(BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_LIST, _))                               \</span>
<a name="l01114"></a>01114 <span class="preprocessor">   {  return m_tree.emplace_equal(BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_FORWARD, _)); }           \</span>
<a name="l01115"></a>01115 <span class="preprocessor">                                                                                                         \</span>
<a name="l01116"></a>01116 <span class="preprocessor">   template&lt;BOOST_PP_ENUM_PARAMS(n, class P)&gt;                                                            \</span>
<a name="l01117"></a>01117 <span class="preprocessor">   iterator emplace_hint(const_iterator hint, BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_LIST, _))     \</span>
<a name="l01118"></a>01118 <span class="preprocessor">   {  return m_tree.emplace_hint_equal(hint, BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_FORWARD, _)); }\</span>
<a name="l01119"></a>01119 <span class="preprocessor"></span>
<a name="l01120"></a>01120 <span class="preprocessor">   #define BOOST_PP_LOCAL_LIMITS (1, BOOST_CONTAINERS_MAX_CONSTRUCTOR_PARAMETERS)</span>
<a name="l01121"></a>01121 <span class="preprocessor"></span><span class="preprocessor">   #include BOOST_PP_LOCAL_ITERATE()</span>
<a name="l01122"></a>01122 <span class="preprocessor"></span>
<a name="l01123"></a>01123 <span class="preprocessor">   #endif   //#ifdef BOOST_CONTAINERS_PERFECT_FORWARDING</span>
<a name="l01124"></a>01124 <span class="preprocessor"></span>
<a name="l01132"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a8b57ea058e5908040bcad768ca1ee0ef">01132</a>    iterator erase(const_iterator position) 
<a name="l01133"></a>01133    { <span class="keywordflow">return</span> m_tree.erase(position); }
<a name="l01134"></a>01134 
<a name="l01140"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a6017e31c2afc203e53023dcca5bcd8c9">01140</a>    size_type erase(<span class="keyword">const</span> key_type&amp; x) 
<a name="l01141"></a>01141    { <span class="keywordflow">return</span> m_tree.erase(x); }
<a name="l01142"></a>01142 
<a name="l01148"></a><a class="code" href="classboost_1_1container_1_1multimap.html#ae5e50737b2e0e88cc629dc262de407e8">01148</a>    iterator erase(const_iterator first, const_iterator last)
<a name="l01149"></a>01149    { <span class="keywordflow">return</span> m_tree.erase(first, last); }
<a name="l01150"></a>01150 
<a name="l01156"></a><a class="code" href="classboost_1_1container_1_1multimap.html#ababe481dd7f728c8c0e91498e33e54d5">01156</a>    <span class="keywordtype">void</span> clear() 
<a name="l01157"></a>01157    { m_tree.clear(); }
<a name="l01158"></a>01158 
<a name="l01163"></a><a class="code" href="classboost_1_1container_1_1multimap.html#af61b879f98dbb115bbeb1a5062949640">01163</a>    iterator find(<span class="keyword">const</span> key_type&amp; x) 
<a name="l01164"></a>01164    { <span class="keywordflow">return</span> m_tree.find(x); }
<a name="l01165"></a>01165 
<a name="l01170"></a><a class="code" href="classboost_1_1container_1_1multimap.html#abc498b35cf01e4d2821cd33e9ebe23e4">01170</a>    const_iterator find(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l01171"></a>01171 <span class="keyword">   </span>{ <span class="keywordflow">return</span> m_tree.find(x); }
<a name="l01172"></a>01172 
<a name="l01176"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a5fb50d641c8e4d06c7e496810166833f">01176</a>    size_type count(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l01177"></a>01177 <span class="keyword">   </span>{ <span class="keywordflow">return</span> m_tree.count(x); }
<a name="l01178"></a>01178 
<a name="l01183"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a5143e42b52781fae29af5323d2d76363">01183</a>    iterator lower_bound(<span class="keyword">const</span> key_type&amp; x) 
<a name="l01184"></a>01184    {<span class="keywordflow">return</span> m_tree.lower_bound(x); }
<a name="l01185"></a>01185 
<a name="l01190"></a><a class="code" href="classboost_1_1container_1_1multimap.html#af28a223484105e68fde6518055cef729">01190</a>    const_iterator lower_bound(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l01191"></a>01191 <span class="keyword">   </span>{  <span class="keywordflow">return</span> m_tree.lower_bound(x);  }
<a name="l01192"></a>01192 
<a name="l01197"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a02c92ff4830104b373678030740d8d21">01197</a>    iterator upper_bound(<span class="keyword">const</span> key_type&amp; x) 
<a name="l01198"></a>01198    {  <span class="keywordflow">return</span> m_tree.upper_bound(x); }
<a name="l01199"></a>01199 
<a name="l01203"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a441f044872354c7347bfcfa4d189111a">01203</a>    std::pair&lt;iterator,iterator&gt; equal_range(<span class="keyword">const</span> key_type&amp; x) 
<a name="l01204"></a>01204    {  <span class="keywordflow">return</span> m_tree.equal_range(x);   }
<a name="l01205"></a>01205 
<a name="l01210"></a><a class="code" href="classboost_1_1container_1_1multimap.html#abc4218dcda90a9180eca4328048e8c07">01210</a>    const_iterator upper_bound(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l01211"></a>01211 <span class="keyword">   </span>{  <span class="keywordflow">return</span> m_tree.upper_bound(x); }
<a name="l01212"></a>01212 
<a name="l01216"></a>01216    std::pair&lt;const_iterator,const_iterator&gt; 
<a name="l01217"></a><a class="code" href="classboost_1_1container_1_1multimap.html#a8cb7f44cd513e87e5c81b8f5eefbe6d4">01217</a>       equal_range(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l01218"></a>01218 <span class="keyword">   </span>{  <span class="keywordflow">return</span> m_tree.equal_range(x);   }
<a name="l01219"></a>01219 
<a name="l01221"></a>01221    <span class="keyword">template</span> &lt;<span class="keyword">class</span> K1, <span class="keyword">class</span> T1, <span class="keyword">class</span> C1, <span class="keyword">class</span> A1&gt;
<a name="l01222"></a>01222    <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator== (<span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1multimap.html">multimap&lt;K1, T1, C1, A1&gt;</a>&amp; x,
<a name="l01223"></a>01223                            <span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1multimap.html">multimap&lt;K1, T1, C1, A1&gt;</a>&amp; y);
<a name="l01224"></a>01224 
<a name="l01225"></a>01225    <span class="keyword">template</span> &lt;<span class="keyword">class</span> K1, <span class="keyword">class</span> T1, <span class="keyword">class</span> C1, <span class="keyword">class</span> A1&gt;
<a name="l01226"></a>01226    <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator&lt; (const multimap&lt;K1, T1, C1, A1&gt;&amp; x,
<a name="l01227"></a>01227                           <span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1multimap.html">multimap&lt;K1, T1, C1, A1&gt;</a>&amp; y);
<a name="l01229"></a>01229 };
<a name="l01230"></a>01230 
<a name="l01231"></a>01231 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l01232"></a>01232 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> multimap&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l01233"></a>01233                        <span class="keyword">const</span> multimap&lt;Key,T,Pred,Alloc&gt;&amp; y) 
<a name="l01234"></a>01234 {  <span class="keywordflow">return</span> x.m_tree == y.m_tree;  }
<a name="l01235"></a>01235 
<a name="l01236"></a>01236 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l01237"></a>01237 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&lt;(const multimap&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l01238"></a>01238                       <span class="keyword">const</span> multimap&lt;Key,T,Pred,Alloc&gt;&amp; y) 
<a name="l01239"></a>01239 {  <span class="keywordflow">return</span> x.m_tree &lt; y.m_tree;   }
<a name="l01240"></a>01240 
<a name="l01241"></a>01241 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l01242"></a>01242 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> multimap&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l01243"></a>01243                        <span class="keyword">const</span> multimap&lt;Key,T,Pred,Alloc&gt;&amp; y) 
<a name="l01244"></a>01244 {  <span class="keywordflow">return</span> !(x == y);  }
<a name="l01245"></a>01245 
<a name="l01246"></a>01246 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l01247"></a>01247 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&gt;(<span class="keyword">const</span> multimap&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l01248"></a>01248                       <span class="keyword">const</span> multimap&lt;Key,T,Pred,Alloc&gt;&amp; y) 
<a name="l01249"></a>01249 {  <span class="keywordflow">return</span> y &lt; x;  }
<a name="l01250"></a>01250 
<a name="l01251"></a>01251 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l01252"></a>01252 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&lt;=(const multimap&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l01253"></a>01253                        <span class="keyword">const</span> multimap&lt;Key,T,Pred,Alloc&gt;&amp; y) 
<a name="l01254"></a>01254 {  <span class="keywordflow">return</span> !(y &lt; x);  }
<a name="l01255"></a>01255 
<a name="l01256"></a>01256 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l01257"></a>01257 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&gt;=(<span class="keyword">const</span> multimap&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l01258"></a>01258                        <span class="keyword">const</span> multimap&lt;Key,T,Pred,Alloc&gt;&amp; y) 
<a name="l01259"></a>01259 {  <span class="keywordflow">return</span> !(x &lt; y);  }
<a name="l01260"></a>01260 
<a name="l01261"></a>01261 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l01262"></a>01262 <span class="keyword">inline</span> <span class="keywordtype">void</span> swap(multimap&lt;Key,T,Pred,Alloc&gt;&amp; x, multimap&lt;Key,T,Pred,Alloc&gt;&amp; y) 
<a name="l01263"></a>01263 {  x.swap(y);  }
<a name="l01264"></a>01264 
<a name="l01266"></a>01266 
<a name="l01267"></a>01267 }  <span class="comment">//namespace container {</span>
<a name="l01268"></a>01268 <span class="comment">/*</span>
<a name="l01271"></a>01271 <span class="comment">template &lt;class K, class T, class C, class A&gt;</span>
<a name="l01272"></a>01272 <span class="comment">struct has_trivial_destructor_after_move&lt;boost::container::multimap&lt;K, T, C, A&gt; &gt;</span>
<a name="l01273"></a>01273 <span class="comment">{</span>
<a name="l01274"></a>01274 <span class="comment">   static const bool value = has_trivial_destructor&lt;A&gt;::value &amp;&amp; has_trivial_destructor&lt;C&gt;::value;</span>
<a name="l01275"></a>01275 <span class="comment">};</span>
<a name="l01276"></a>01276 <span class="comment">*/</span>
<a name="l01277"></a>01277 <span class="keyword">namespace </span>container {
<a name="l01278"></a>01278 
<a name="l01280"></a>01280 
<a name="l01281"></a>01281 }}
<a name="l01282"></a>01282 
<a name="l01283"></a>01283 <span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_CONFIG_END_HPP</span>
<a name="l01284"></a>01284 <span class="preprocessor"></span>
<a name="l01285"></a>01285 <span class="preprocessor">#endif </span><span class="comment">/* BOOST_CONTAINERS_MAP_HPP */</span>
<a name="l01286"></a>01286 
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Apr 27 2011 00:50:05 for Nutcracker by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
