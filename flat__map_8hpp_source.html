<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nutcracker: flat_map.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>flat_map.hpp</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00002"></a>00002 <span class="comment">//</span>
<a name="l00003"></a>00003 <span class="comment">// (C) Copyright Ion Gaztanaga 2005-2009. Distributed under the Boost</span>
<a name="l00004"></a>00004 <span class="comment">// Software License, Version 1.0. (See accompanying file</span>
<a name="l00005"></a>00005 <span class="comment">// LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)</span>
<a name="l00006"></a>00006 <span class="comment">//</span>
<a name="l00007"></a>00007 <span class="comment">// See http://www.boost.org/libs/container for documentation.</span>
<a name="l00008"></a>00008 <span class="comment">//</span>
<a name="l00010"></a>00010 <span class="comment"></span>
<a name="l00011"></a>00011 <span class="preprocessor">#ifndef BOOST_CONTAINERS_FLAT_MAP_HPP</span>
<a name="l00012"></a>00012 <span class="preprocessor"></span><span class="preprocessor">#define BOOST_CONTAINERS_FLAT_MAP_HPP</span>
<a name="l00013"></a>00013 <span class="preprocessor"></span>
<a name="l00014"></a>00014 <span class="preprocessor">#if (defined _MSC_VER) &amp;&amp; (_MSC_VER &gt;= 1200)</span>
<a name="l00015"></a>00015 <span class="preprocessor"></span><span class="preprocessor">#  pragma once</span>
<a name="l00016"></a>00016 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l00017"></a>00017 <span class="preprocessor"></span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &quot;detail/config_begin.hpp&quot;</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_WORKAROUND_HPP</span>
<a name="l00020"></a>00020 <span class="preprocessor"></span>
<a name="l00021"></a>00021 <span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_CONTAINER_FWD_HPP</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span><span class="preprocessor">#include &lt;utility&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;functional&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;memory&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;stdexcept&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_FLAT_TREE_HPP</span>
<a name="l00027"></a>00027 <span class="preprocessor"></span><span class="preprocessor">#include &lt;boost/type_traits/has_trivial_destructor.hpp&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_MPL_HPP</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span><span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_MOVE_HPP</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span>
<a name="l00031"></a>00031 <span class="preprocessor">#ifdef BOOST_CONTAINER_DOXYGEN_INVOKED</span>
<a name="l00032"></a>00032 <span class="preprocessor"></span><span class="keyword">namespace </span>boost {
<a name="l00033"></a>00033 <span class="keyword">namespace </span>container {
<a name="l00034"></a>00034 <span class="preprocessor">#else</span>
<a name="l00035"></a>00035 <span class="preprocessor"></span><span class="keyword">namespace </span>boost {
<a name="l00036"></a>00036 <span class="keyword">namespace </span>container {
<a name="l00037"></a>00037 <span class="preprocessor">#endif</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span>
<a name="l00040"></a>00040 <span class="comment">// Forward declarations of operators == and &lt;, needed for friend declarations.</span>
<a name="l00041"></a>00041 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00042"></a>00042 <span class="keyword">class </span>flat_map;
<a name="l00043"></a>00043 
<a name="l00044"></a>00044 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00045"></a>00045 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> flat_map&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l00046"></a>00046                        <span class="keyword">const</span> flat_map&lt;Key,T,Pred,Alloc&gt;&amp; y);
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00049"></a>00049 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&lt;(const flat_map&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l00050"></a>00050                       <span class="keyword">const</span> flat_map&lt;Key,T,Pred,Alloc&gt;&amp; y);
<a name="l00052"></a>00052 
<a name="l00074"></a>00074 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00075"></a><a class="code" href="classboost_1_1container_1_1flat__map.html">00075</a> <span class="keyword">class </span><a class="code" href="classboost_1_1container_1_1flat__map.html">flat_map</a> 
<a name="l00076"></a>00076 {
<a name="l00078"></a>00078    <span class="keyword">private</span>:
<a name="l00079"></a>00079    BOOST_MOVE_MACRO_COPYABLE_AND_MOVABLE(<a class="code" href="classboost_1_1container_1_1flat__map.html">flat_map</a>)
<a name="l00080"></a>00080    <span class="comment">//This is the tree that we should store if pair was movable</span>
<a name="l00081"></a>00081    <span class="keyword">typedef</span> <a class="code" href="classboost_1_1container_1_1containers__detail_1_1flat__tree.html">containers_detail::flat_tree</a>&lt;Key, 
<a name="l00082"></a>00082                            std::pair&lt;Key, T&gt;, 
<a name="l00083"></a>00083                            <a class="code" href="structboost_1_1container_1_1containers__detail_1_1select1st.html">containers_detail::select1st&lt; std::pair&lt;Key, T&gt;</a> &gt;, 
<a name="l00084"></a>00084                            Pred, 
<a name="l00085"></a>00085                            Alloc&gt; tree_t;
<a name="l00086"></a>00086 
<a name="l00087"></a>00087    <span class="comment">//This is the real tree stored here. It&#39;s based on a movable pair</span>
<a name="l00088"></a>00088    <span class="keyword">typedef</span> <a class="code" href="classboost_1_1container_1_1containers__detail_1_1flat__tree.html">containers_detail::flat_tree</a>&lt;Key, 
<a name="l00089"></a>00089                            <a class="code" href="structboost_1_1container_1_1containers__detail_1_1pair.html">containers_detail::pair&lt;Key, T&gt;</a>, 
<a name="l00090"></a>00090                            <a class="code" href="structboost_1_1container_1_1containers__detail_1_1select1st.html">containers_detail::select1st&lt;containers_detail::pair&lt;Key, T&gt;</a> &gt;, 
<a name="l00091"></a>00091                            Pred, 
<a name="l00092"></a>00092                            <span class="keyword">typename</span> Alloc::template
<a name="l00093"></a>00093                               rebind&lt;containers_detail::pair&lt;Key, T&gt; &gt;::other&gt; impl_tree_t;
<a name="l00094"></a>00094    impl_tree_t m_flat_tree;  <span class="comment">// flat tree representing flat_map</span>
<a name="l00095"></a>00095 
<a name="l00096"></a>00096    <span class="keyword">typedef</span> <span class="keyword">typename</span> impl_tree_t::value_type              impl_value_type;
<a name="l00097"></a>00097    <span class="keyword">typedef</span> <span class="keyword">typename</span> impl_tree_t::pointer                 impl_pointer;
<a name="l00098"></a>00098    <span class="keyword">typedef</span> <span class="keyword">typename</span> impl_tree_t::const_pointer           impl_const_pointer;
<a name="l00099"></a>00099    <span class="keyword">typedef</span> <span class="keyword">typename</span> impl_tree_t::reference               impl_reference;
<a name="l00100"></a>00100    <span class="keyword">typedef</span> <span class="keyword">typename</span> impl_tree_t::const_reference         impl_const_reference;
<a name="l00101"></a>00101    <span class="keyword">typedef</span> <span class="keyword">typename</span> impl_tree_t::value_compare           impl_value_compare;
<a name="l00102"></a>00102    <span class="keyword">typedef</span> <span class="keyword">typename</span> impl_tree_t::iterator                impl_iterator;
<a name="l00103"></a>00103    <span class="keyword">typedef</span> <span class="keyword">typename</span> impl_tree_t::const_iterator          impl_const_iterator;
<a name="l00104"></a>00104    <span class="keyword">typedef</span> <span class="keyword">typename</span> impl_tree_t::reverse_iterator        impl_reverse_iterator;
<a name="l00105"></a>00105    <span class="keyword">typedef</span> <span class="keyword">typename</span> impl_tree_t::const_reverse_iterator  impl_const_reverse_iterator;
<a name="l00106"></a>00106    <span class="keyword">typedef</span> <span class="keyword">typename</span> impl_tree_t::allocator_type          impl_allocator_type;
<a name="l00107"></a>00107 
<a name="l00108"></a>00108    <span class="keyword">template</span>&lt;<span class="keyword">class</span> D, <span class="keyword">class</span> S&gt;
<a name="l00109"></a>00109    <span class="keyword">static</span> D &amp;force(<span class="keyword">const</span> S &amp;s)
<a name="l00110"></a>00110    {  <span class="keywordflow">return</span> *<span class="keyword">const_cast&lt;</span>D*<span class="keyword">&gt;</span>(<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>D*<span class="keyword">&gt;</span>(&amp;s)); }
<a name="l00111"></a>00111 
<a name="l00112"></a>00112    <span class="keyword">template</span>&lt;<span class="keyword">class</span> D, <span class="keyword">class</span> S&gt;
<a name="l00113"></a>00113    <span class="keyword">static</span> D force_copy(S s)
<a name="l00114"></a>00114    {
<a name="l00115"></a>00115       value_type *vp = <span class="keyword">reinterpret_cast&lt;</span>value_type *<span class="keyword">&gt;</span>(&amp;*s);
<a name="l00116"></a>00116       <span class="keywordflow">return</span> D(vp);
<a name="l00117"></a>00117    }
<a name="l00118"></a>00118 
<a name="l00120"></a>00120 
<a name="l00121"></a>00121    <span class="keyword">public</span>:
<a name="l00122"></a>00122 
<a name="l00123"></a>00123    <span class="comment">// typedefs:</span>
<a name="l00124"></a>00124    <span class="keyword">typedef</span> <span class="keyword">typename</span> impl_tree_t::key_type               key_type;
<a name="l00125"></a>00125    <span class="keyword">typedef</span> T                                            mapped_type;
<a name="l00126"></a>00126    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::pair&lt;key_type, mapped_type&gt;    value_type;
<a name="l00127"></a>00127    <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::pointer                      pointer;
<a name="l00128"></a>00128    <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::const_pointer                const_pointer;
<a name="l00129"></a>00129    <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::reference                    reference;
<a name="l00130"></a>00130    <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::const_reference              const_reference;
<a name="l00131"></a>00131    <span class="keyword">typedef</span> <a class="code" href="classboost_1_1container_1_1containers__detail_1_1flat__tree__value__compare.html">containers_detail::flat_tree_value_compare</a>
<a name="l00132"></a>00132       &lt; Pred
<a name="l00133"></a>00133       , <a class="code" href="structboost_1_1container_1_1containers__detail_1_1select1st.html">containers_detail::select1st&lt; std::pair&lt;Key, T&gt;</a> &gt;
<a name="l00134"></a>00134       , std::pair&lt;Key, T&gt; &gt;                             <a class="code" href="classboost_1_1container_1_1containers__detail_1_1flat__tree__value__compare.html">value_compare</a>;
<a name="l00135"></a>00135    <span class="keyword">typedef</span> Pred                                         key_compare;
<a name="l00136"></a>00136    <span class="keyword">typedef</span> <span class="keyword">typename</span> containers_detail::
<a name="l00137"></a>00137       get_flat_tree_iterators&lt;pointer&gt;::iterator        iterator;
<a name="l00138"></a>00138    <span class="keyword">typedef</span> <span class="keyword">typename</span> containers_detail::
<a name="l00139"></a>00139       get_flat_tree_iterators&lt;pointer&gt;::const_iterator  const_iterator;
<a name="l00140"></a>00140    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structboost_1_1container_1_1containers__detail_1_1get__flat__tree__iterators.html">containers_detail::</a>
<a name="l00141"></a>00141 <a class="code" href="structboost_1_1container_1_1containers__detail_1_1get__flat__tree__iterators.html">      get_flat_tree_iterators</a>
<a name="l00142"></a>00142          &lt;pointer&gt;::reverse_iterator                    reverse_iterator;
<a name="l00143"></a>00143    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structboost_1_1container_1_1containers__detail_1_1get__flat__tree__iterators.html">containers_detail::</a>
<a name="l00144"></a>00144 <a class="code" href="structboost_1_1container_1_1containers__detail_1_1get__flat__tree__iterators.html">      get_flat_tree_iterators</a>
<a name="l00145"></a>00145          &lt;pointer&gt;::const_reverse_iterator              const_reverse_iterator;
<a name="l00146"></a>00146    <span class="keyword">typedef</span> <span class="keyword">typename</span> impl_tree_t::size_type              size_type;
<a name="l00147"></a>00147    <span class="keyword">typedef</span> <span class="keyword">typename</span> impl_tree_t::difference_type        difference_type;
<a name="l00148"></a>00148    <span class="keyword">typedef</span> Alloc                                        allocator_type;
<a name="l00149"></a>00149    <span class="keyword">typedef</span> Alloc                                        stored_allocator_type;
<a name="l00150"></a>00150 
<a name="l00155"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a0946c052225aee98268d0dad0ecfabe8">00155</a>    <span class="keyword">explicit</span> <a class="code" href="classboost_1_1container_1_1flat__map.html">flat_map</a>(<span class="keyword">const</span> Pred&amp; comp = Pred(), <span class="keyword">const</span> allocator_type&amp; a = allocator_type()) 
<a name="l00156"></a>00156       : m_flat_tree(comp, force&lt;impl_allocator_type&gt;(a)) {}
<a name="l00157"></a>00157 
<a name="l00163"></a>00163    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
<a name="l00164"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a621ebdd6f0e06244786319d1df657435">00164</a>    <a class="code" href="classboost_1_1container_1_1flat__map.html">flat_map</a>(InputIterator first, InputIterator last, <span class="keyword">const</span> Pred&amp; comp = Pred(),
<a name="l00165"></a>00165          <span class="keyword">const</span> allocator_type&amp; a = allocator_type())
<a name="l00166"></a>00166       : m_flat_tree(comp, force&lt;impl_allocator_type&gt;(a)) 
<a name="l00167"></a>00167       { m_flat_tree.insert_unique(first, last); }
<a name="l00168"></a>00168 
<a name="l00177"></a>00177    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
<a name="l00178"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a382980d1aa2ed5aeae720ab7699bf815">00178</a>    <a class="code" href="classboost_1_1container_1_1flat__map.html">flat_map</a>( ordered_unique_range_t, InputIterator first, InputIterator last
<a name="l00179"></a>00179            , <span class="keyword">const</span> Pred&amp; comp = Pred(), <span class="keyword">const</span> allocator_type&amp; a = allocator_type())
<a name="l00180"></a>00180       : m_flat_tree(ordered_range, first, last, comp, a) 
<a name="l00181"></a>00181    {}
<a name="l00182"></a>00182 
<a name="l00186"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a7dc37fd16e3869bc624c8983de9e36ca">00186</a>    <a class="code" href="classboost_1_1container_1_1flat__map.html">flat_map</a>(<span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1flat__map.html">flat_map&lt;Key,T,Pred,Alloc&gt;</a>&amp; x) 
<a name="l00187"></a>00187       : m_flat_tree(x.m_flat_tree) {}
<a name="l00188"></a>00188 
<a name="l00195"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a14e0e420d6eb32ff266c5fdc5d981aa2">00195</a>    <a class="code" href="classboost_1_1container_1_1flat__map.html">flat_map</a>(BOOST_MOVE_MACRO_RV_REF(<a class="code" href="classboost_1_1container_1_1flat__map.html">flat_map</a>) x) 
<a name="l00196"></a>00196       : m_flat_tree(BOOST_CONTAINER_MOVE_NAMESPACE::move(x.m_flat_tree))
<a name="l00197"></a>00197    {}
<a name="l00198"></a>00198 
<a name="l00202"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#aadbbd4d6030679ab99df79f226b07b91">00202</a>    <a class="code" href="classboost_1_1container_1_1flat__map.html">flat_map&lt;Key,T,Pred,Alloc&gt;</a>&amp; operator=(BOOST_MOVE_MACRO_COPY_ASSIGN_REF(<a class="code" href="classboost_1_1container_1_1flat__map.html">flat_map</a>) x)
<a name="l00203"></a>00203    {  m_flat_tree = x.m_flat_tree;   <span class="keywordflow">return</span> *<span class="keyword">this</span>;  }
<a name="l00204"></a>00204 
<a name="l00211"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a3fbecda0c62b856243d32101a6647c88">00211</a>    <a class="code" href="classboost_1_1container_1_1flat__map.html">flat_map&lt;Key,T,Pred,Alloc&gt;</a>&amp; operator=(BOOST_MOVE_MACRO_RV_REF(<a class="code" href="classboost_1_1container_1_1flat__map.html">flat_map</a>) mx)
<a name="l00212"></a>00212    {  m_flat_tree = BOOST_CONTAINER_MOVE_NAMESPACE::move(mx.m_flat_tree);   <span class="keywordflow">return</span> *<span class="keyword">this</span>;  }
<a name="l00213"></a>00213 
<a name="l00218"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#af42d0b748072d5c47cf2c1a9841d347c">00218</a>    key_compare key_comp()<span class="keyword"> const </span>
<a name="l00219"></a>00219 <span class="keyword">      </span>{ <span class="keywordflow">return</span> force&lt;key_compare&gt;(m_flat_tree.key_comp()); }
<a name="l00220"></a>00220 
<a name="l00225"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#abf3bae3bd9525d27ac2e381b9afd9587">00225</a>    <a class="code" href="classboost_1_1container_1_1containers__detail_1_1flat__tree__value__compare.html">value_compare</a> value_comp()<span class="keyword"> const </span>
<a name="l00226"></a>00226 <span class="keyword">      </span>{ <span class="keywordflow">return</span> <a class="code" href="classboost_1_1container_1_1containers__detail_1_1flat__tree__value__compare.html">value_compare</a>(force&lt;key_compare&gt;(m_flat_tree.key_comp())); }
<a name="l00227"></a>00227 
<a name="l00232"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a11db1d15f038e982daefdcff7c4181b3">00232</a>    allocator_type get_allocator()<span class="keyword"> const </span>
<a name="l00233"></a>00233 <span class="keyword">      </span>{ <span class="keywordflow">return</span> force&lt;allocator_type&gt;(m_flat_tree.get_allocator()); }
<a name="l00234"></a>00234 
<a name="l00235"></a>00235    <span class="keyword">const</span> stored_allocator_type &amp;get_stored_allocator()<span class="keyword"> const </span>
<a name="l00236"></a>00236 <span class="keyword">      </span>{ <span class="keywordflow">return</span> force&lt;stored_allocator_type&gt;(m_flat_tree.get_stored_allocator()); }
<a name="l00237"></a>00237 
<a name="l00238"></a>00238    stored_allocator_type &amp;get_stored_allocator()
<a name="l00239"></a>00239       { <span class="keywordflow">return</span> force&lt;stored_allocator_type&gt;(m_flat_tree.get_stored_allocator()); }
<a name="l00240"></a>00240 
<a name="l00246"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#abd150356f5d830ddafa0511e471cf254">00246</a>    iterator begin() 
<a name="l00247"></a>00247       { <span class="keywordflow">return</span> force_copy&lt;iterator&gt;(m_flat_tree.begin()); }
<a name="l00248"></a>00248 
<a name="l00254"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a7653280daa345e22c1d37bc0784e1fb0">00254</a>    const_iterator begin()<span class="keyword"> const </span>
<a name="l00255"></a>00255 <span class="keyword">      </span>{ <span class="keywordflow">return</span> force&lt;const_iterator&gt;(m_flat_tree.begin()); }
<a name="l00256"></a>00256 
<a name="l00262"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a0c6d2ad349037a35c97c787f52662d40">00262</a>    const_iterator cbegin()<span class="keyword"> const </span>
<a name="l00263"></a>00263 <span class="keyword">      </span>{ <span class="keywordflow">return</span> force&lt;const_iterator&gt;(m_flat_tree.cbegin()); }
<a name="l00264"></a>00264 
<a name="l00270"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#adfd1340bc5a6e54b4940c4439a03f4cd">00270</a>    iterator end() 
<a name="l00271"></a>00271       { <span class="keywordflow">return</span> force_copy&lt;iterator&gt;(m_flat_tree.end()); }
<a name="l00272"></a>00272 
<a name="l00278"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#adfc6275d0ddc2040355bb77e91a7e211">00278</a>    const_iterator end()<span class="keyword"> const </span>
<a name="l00279"></a>00279 <span class="keyword">      </span>{ <span class="keywordflow">return</span> force&lt;const_iterator&gt;(m_flat_tree.end()); }
<a name="l00280"></a>00280 
<a name="l00286"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#ae2f360304e67f29cc1ae9279f2e18d08">00286</a>    const_iterator cend()<span class="keyword"> const </span>
<a name="l00287"></a>00287 <span class="keyword">      </span>{ <span class="keywordflow">return</span> force&lt;const_iterator&gt;(m_flat_tree.cend()); }
<a name="l00288"></a>00288 
<a name="l00295"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a1e020057d4492a6c2e32d67c15d67e83">00295</a>    reverse_iterator rbegin() 
<a name="l00296"></a>00296       { <span class="keywordflow">return</span> force&lt;reverse_iterator&gt;(m_flat_tree.rbegin()); }
<a name="l00297"></a>00297 
<a name="l00304"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a602ee058f634735e27195239db21ae77">00304</a>    const_reverse_iterator rbegin()<span class="keyword"> const </span>
<a name="l00305"></a>00305 <span class="keyword">      </span>{ <span class="keywordflow">return</span> force&lt;const_reverse_iterator&gt;(m_flat_tree.rbegin()); }
<a name="l00306"></a>00306 
<a name="l00313"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#ab488cb73afd87ffb0fc1d2fbef23e6dd">00313</a>    const_reverse_iterator crbegin()<span class="keyword"> const </span>
<a name="l00314"></a>00314 <span class="keyword">      </span>{ <span class="keywordflow">return</span> force&lt;const_reverse_iterator&gt;(m_flat_tree.crbegin()); }
<a name="l00315"></a>00315 
<a name="l00322"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a82ee0e7939437e7029b6e6ef333354a2">00322</a>    reverse_iterator rend() 
<a name="l00323"></a>00323       { <span class="keywordflow">return</span> force&lt;reverse_iterator&gt;(m_flat_tree.rend()); }
<a name="l00324"></a>00324 
<a name="l00331"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a5518960d2285ce6f3ffae0f88b676af7">00331</a>    const_reverse_iterator rend()<span class="keyword"> const </span>
<a name="l00332"></a>00332 <span class="keyword">      </span>{ <span class="keywordflow">return</span> force&lt;const_reverse_iterator&gt;(m_flat_tree.rend()); }
<a name="l00333"></a>00333 
<a name="l00340"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a661d74a4d63d7c2222812a782c757ae1">00340</a>    const_reverse_iterator crend()<span class="keyword"> const </span>
<a name="l00341"></a>00341 <span class="keyword">      </span>{ <span class="keywordflow">return</span> force&lt;const_reverse_iterator&gt;(m_flat_tree.crend()); }
<a name="l00342"></a>00342 
<a name="l00348"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a66b9929aa8692e9ab81adc23d9588b70">00348</a>    <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>
<a name="l00349"></a>00349 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.empty(); }
<a name="l00350"></a>00350 
<a name="l00356"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a87698f992a88a6ab99ffb2b45088565a">00356</a>    size_type size()<span class="keyword"> const </span>
<a name="l00357"></a>00357 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.size(); }
<a name="l00358"></a>00358 
<a name="l00364"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a295a67c5ee3c2cd3dfff9ff3f351e751">00364</a>    size_type max_size()<span class="keyword"> const </span>
<a name="l00365"></a>00365 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.max_size(); }
<a name="l00366"></a>00366 
<a name="l00373"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a1938b5f4cfad9d8cb57ef37b6ccb008e">00373</a>    T &amp;operator[](<span class="keyword">const</span> key_type&amp; k) 
<a name="l00374"></a>00374    {
<a name="l00375"></a>00375       iterator i = lower_bound(k);
<a name="l00376"></a>00376       <span class="comment">// i-&gt;first is greater than or equivalent to k.</span>
<a name="l00377"></a>00377       <span class="keywordflow">if</span> (i == end() || key_comp()(k, (*i).first))
<a name="l00378"></a>00378          i = insert(i, value_type(k, T()));
<a name="l00379"></a>00379       <span class="keywordflow">return</span> (*i).second;
<a name="l00380"></a>00380    }
<a name="l00381"></a>00381 
<a name="l00388"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a7269062415ec4c8ca6863ea1b72f7d2d">00388</a>    T &amp;operator[](BOOST_MOVE_MACRO_RV_REF(key_type) mk) 
<a name="l00389"></a>00389    {
<a name="l00390"></a>00390       key_type &amp;k = mk;
<a name="l00391"></a>00391       iterator i = lower_bound(k);
<a name="l00392"></a>00392       <span class="comment">// i-&gt;first is greater than or equivalent to k.</span>
<a name="l00393"></a>00393       <span class="keywordflow">if</span> (i == end() || key_comp()(k, (*i).first))
<a name="l00394"></a>00394          i = insert(i, value_type(BOOST_CONTAINER_MOVE_NAMESPACE::move(k), BOOST_CONTAINER_MOVE_NAMESPACE::move(T())));
<a name="l00395"></a>00395       <span class="keywordflow">return</span> (*i).second;
<a name="l00396"></a>00396    }
<a name="l00397"></a>00397 
<a name="l00401"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a98f6c877abdce529e514b9e38dd09b04">00401</a>    T&amp; at(<span class="keyword">const</span> key_type&amp; k)
<a name="l00402"></a>00402    {
<a name="l00403"></a>00403       iterator i = this-&gt;find(k);
<a name="l00404"></a>00404       <span class="keywordflow">if</span>(i == this-&gt;end()){
<a name="l00405"></a>00405          <span class="keywordflow">throw</span> std::out_of_range(<span class="stringliteral">&quot;key not found&quot;</span>);
<a name="l00406"></a>00406       }
<a name="l00407"></a>00407       <span class="keywordflow">return</span> i-&gt;second;
<a name="l00408"></a>00408    }
<a name="l00409"></a>00409 
<a name="l00413"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a81a041e60b996a72fa4c444ec83640d5">00413</a>    <span class="keyword">const</span> T&amp; at(<span class="keyword">const</span> key_type&amp; k)<span class="keyword"> const</span>
<a name="l00414"></a>00414 <span class="keyword">   </span>{
<a name="l00415"></a>00415       const_iterator i = this-&gt;find(k);
<a name="l00416"></a>00416       <span class="keywordflow">if</span>(i == this-&gt;end()){
<a name="l00417"></a>00417          <span class="keywordflow">throw</span> std::out_of_range(<span class="stringliteral">&quot;key not found&quot;</span>);
<a name="l00418"></a>00418       }
<a name="l00419"></a>00419       <span class="keywordflow">return</span> i-&gt;second;
<a name="l00420"></a>00420    }
<a name="l00421"></a>00421 
<a name="l00428"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#acd42aacef98569ff677e68c02db67345">00428</a>    <span class="keywordtype">void</span> swap(<a class="code" href="classboost_1_1container_1_1flat__map.html">flat_map</a>&amp; x)
<a name="l00429"></a>00429    { m_flat_tree.swap(x.m_flat_tree); }
<a name="l00430"></a>00430 
<a name="l00442"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#afc68170496f98dae12419b3ad82465f3">00442</a>    std::pair&lt;iterator,bool&gt; insert(<span class="keyword">const</span> value_type&amp; x) 
<a name="l00443"></a>00443       { <span class="keywordflow">return</span> force&lt;std::pair&lt;iterator,bool&gt; &gt;(
<a name="l00444"></a>00444          m_flat_tree.insert_unique(force&lt;impl_value_type&gt;(x))); }
<a name="l00445"></a>00445 
<a name="l00457"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#af26adb78cd99fb2add4810473882f33d">00457</a>    std::pair&lt;iterator,bool&gt; insert(BOOST_MOVE_MACRO_RV_REF(value_type) x) 
<a name="l00458"></a>00458    {  <span class="keywordflow">return</span> force&lt;std::pair&lt;iterator,bool&gt; &gt;(
<a name="l00459"></a>00459       m_flat_tree.insert_unique(BOOST_CONTAINER_MOVE_NAMESPACE::move(force&lt;impl_value_type&gt;(x)))); }
<a name="l00460"></a>00460 
<a name="l00472"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#aa31971846f22fb609e20f2d0744f3fbc">00472</a>    std::pair&lt;iterator,bool&gt; insert(BOOST_MOVE_MACRO_RV_REF(impl_value_type) x) 
<a name="l00473"></a>00473    {
<a name="l00474"></a>00474       <span class="keywordflow">return</span> force&lt;std::pair&lt;iterator,bool&gt; &gt;
<a name="l00475"></a>00475       (m_flat_tree.insert_unique(BOOST_CONTAINER_MOVE_NAMESPACE::move(x)));
<a name="l00476"></a>00476    }
<a name="l00477"></a>00477 
<a name="l00489"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#aef43344daaca31a9aeec40af23feb53f">00489</a>    iterator insert(const_iterator position, <span class="keyword">const</span> value_type&amp; x)
<a name="l00490"></a>00490       { <span class="keywordflow">return</span> force_copy&lt;iterator&gt;(
<a name="l00491"></a>00491          m_flat_tree.insert_unique(force&lt;impl_const_iterator&gt;(position), force&lt;impl_value_type&gt;(x))); }
<a name="l00492"></a>00492 
<a name="l00502"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#ad7309e9f4bf6ed904451ee9dd0be4468">00502</a>    iterator insert(const_iterator position, BOOST_MOVE_MACRO_RV_REF(value_type) x)
<a name="l00503"></a>00503       { <span class="keywordflow">return</span> force_copy&lt;iterator&gt;(
<a name="l00504"></a>00504          m_flat_tree.insert_unique(force&lt;impl_const_iterator&gt;(position), BOOST_CONTAINER_MOVE_NAMESPACE::move(force&lt;impl_value_type&gt;(x)))); }
<a name="l00505"></a>00505 
<a name="l00515"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#aff1149a7dae0d27ecd705040e28161be">00515</a>    iterator insert(const_iterator position, BOOST_MOVE_MACRO_RV_REF(impl_value_type) x)
<a name="l00516"></a>00516    {
<a name="l00517"></a>00517       <span class="keywordflow">return</span> force_copy&lt;iterator&gt;(
<a name="l00518"></a>00518          m_flat_tree.insert_unique(force&lt;impl_const_iterator&gt;(position), BOOST_CONTAINER_MOVE_NAMESPACE::move(x)));
<a name="l00519"></a>00519    }
<a name="l00520"></a>00520 
<a name="l00530"></a>00530    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
<a name="l00531"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a5a3af06a564920ad4f0e5025b42c1127">00531</a>    <span class="keywordtype">void</span> insert(InputIterator first, InputIterator last) 
<a name="l00532"></a>00532    {  m_flat_tree.insert_unique(first, last);  }
<a name="l00533"></a>00533 
<a name="l00534"></a>00534 <span class="preprocessor">   #if defined(BOOST_CONTAINERS_PERFECT_FORWARDING) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)</span>
<a name="l00535"></a>00535 <span class="preprocessor"></span>
<a name="l00548"></a>00548    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;
<a name="l00549"></a>00549    iterator emplace(Args&amp;&amp;... args)
<a name="l00550"></a>00550    {  <span class="keywordflow">return</span> force_copy&lt;iterator&gt;(m_flat_tree.emplace_unique(BOOST_CONTAINER_MOVE_NAMESPACE::forward&lt;Args&gt;(args)...)); }
<a name="l00551"></a>00551 
<a name="l00564"></a>00564    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;
<a name="l00565"></a>00565    iterator emplace_hint(const_iterator hint, Args&amp;&amp;... args)
<a name="l00566"></a>00566    {  <span class="keywordflow">return</span> force_copy&lt;iterator&gt;(m_flat_tree.emplace_hint_unique(force&lt;impl_const_iterator&gt;(hint), BOOST_CONTAINER_MOVE_NAMESPACE::forward&lt;Args&gt;(args)...)); }
<a name="l00567"></a>00567 
<a name="l00568"></a>00568 <span class="preprocessor">   #else //#ifdef BOOST_CONTAINERS_PERFECT_FORWARDING</span>
<a name="l00569"></a>00569 <span class="preprocessor"></span>
<a name="l00570"></a>00570    iterator emplace()
<a name="l00571"></a>00571    {  <span class="keywordflow">return</span> force_copy&lt;iterator&gt;(m_flat_tree.emplace_unique()); }
<a name="l00572"></a>00572 
<a name="l00573"></a>00573    iterator emplace_hint(const_iterator hint)
<a name="l00574"></a>00574    {  <span class="keywordflow">return</span> force_copy&lt;iterator&gt;(m_flat_tree.emplace_hint_unique(force&lt;impl_const_iterator&gt;(hint))); }
<a name="l00575"></a>00575 
<a name="l00576"></a>00576 <span class="preprocessor">   #define BOOST_PP_LOCAL_MACRO(n)                                                                    \</span>
<a name="l00577"></a>00577 <span class="preprocessor">   template&lt;BOOST_PP_ENUM_PARAMS(n, class P)&gt;                                                         \</span>
<a name="l00578"></a>00578 <span class="preprocessor">   iterator emplace(BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_LIST, _))                            \</span>
<a name="l00579"></a>00579 <span class="preprocessor">   {                                                                                                  \</span>
<a name="l00580"></a>00580 <span class="preprocessor">      return force_copy&lt;iterator&gt;(m_flat_tree.emplace_unique                                               \</span>
<a name="l00581"></a>00581 <span class="preprocessor">         (BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_FORWARD, _)));                                 \</span>
<a name="l00582"></a>00582 <span class="preprocessor">   }                                                                                                  \</span>
<a name="l00583"></a>00583 <span class="preprocessor">                                                                                                      \</span>
<a name="l00584"></a>00584 <span class="preprocessor">   template&lt;BOOST_PP_ENUM_PARAMS(n, class P)&gt;                                                         \</span>
<a name="l00585"></a>00585 <span class="preprocessor">   iterator emplace_hint(const_iterator hint, BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_LIST, _))  \</span>
<a name="l00586"></a>00586 <span class="preprocessor">   {                                                                                                  \</span>
<a name="l00587"></a>00587 <span class="preprocessor">      return force_copy&lt;iterator&gt;(m_flat_tree.emplace_hint_unique                                          \</span>
<a name="l00588"></a>00588 <span class="preprocessor">         (force&lt;impl_const_iterator&gt;(hint),                                                           \</span>
<a name="l00589"></a>00589 <span class="preprocessor">         BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_FORWARD, _)));                                  \</span>
<a name="l00590"></a>00590 <span class="preprocessor">   }                                                                                                  \</span>
<a name="l00591"></a>00591 <span class="preprocessor"></span>
<a name="l00592"></a>00592 <span class="preprocessor">   #define BOOST_PP_LOCAL_LIMITS (1, BOOST_CONTAINERS_MAX_CONSTRUCTOR_PARAMETERS)</span>
<a name="l00593"></a>00593 <span class="preprocessor"></span><span class="preprocessor">   #include BOOST_PP_LOCAL_ITERATE()</span>
<a name="l00594"></a>00594 <span class="preprocessor"></span>
<a name="l00595"></a>00595 <span class="preprocessor">   #endif   //#ifdef BOOST_CONTAINERS_PERFECT_FORWARDING</span>
<a name="l00596"></a>00596 <span class="preprocessor"></span>
<a name="l00607"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#aebb87551c7a54b9cb87672e303e7146f">00607</a>    iterator erase(const_iterator position) 
<a name="l00608"></a>00608       { <span class="keywordflow">return</span> force_copy&lt;iterator&gt;(m_flat_tree.erase(force&lt;impl_const_iterator&gt;(position))); }
<a name="l00609"></a>00609 
<a name="l00616"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#acea8fde956f2b3a66aef10a4cc43dbf1">00616</a>    size_type erase(<span class="keyword">const</span> key_type&amp; x) 
<a name="l00617"></a>00617       { <span class="keywordflow">return</span> m_flat_tree.erase(x); }
<a name="l00618"></a>00618 
<a name="l00627"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a996da694f70aacd63e873bda3a1b3576">00627</a>    iterator erase(const_iterator first, const_iterator last)
<a name="l00628"></a>00628       { <span class="keywordflow">return</span> force_copy&lt;iterator&gt;(m_flat_tree.erase(force&lt;impl_const_iterator&gt;(first), force&lt;impl_const_iterator&gt;(last))); }
<a name="l00629"></a>00629 
<a name="l00635"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#ad9e8d61203d12b87e501c26efde47cf0">00635</a>    <span class="keywordtype">void</span> clear() 
<a name="l00636"></a>00636       { m_flat_tree.clear(); }
<a name="l00637"></a>00637 
<a name="l00639"></a>00639    <span class="comment">//    with previous allocations. The size of the vector is unchanged</span>
<a name="l00644"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#afb34753223ee18e598ad95e227a44a97">00644</a> <span class="comment"></span>   <span class="keywordtype">void</span> shrink_to_fit()
<a name="l00645"></a>00645       { m_flat_tree.shrink_to_fit(); }
<a name="l00646"></a>00646 
<a name="l00651"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a5a0b4e85123871229eae99547161f5ad">00651</a>    iterator find(<span class="keyword">const</span> key_type&amp; x) 
<a name="l00652"></a>00652       { <span class="keywordflow">return</span> force_copy&lt;iterator&gt;(m_flat_tree.find(x)); }
<a name="l00653"></a>00653 
<a name="l00658"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a31cb317ef3e5080e271e1520cac7e1be">00658</a>    const_iterator find(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l00659"></a>00659 <span class="keyword">      </span>{ <span class="keywordflow">return</span> force&lt;const_iterator&gt;(m_flat_tree.find(x)); }
<a name="l00660"></a>00660 
<a name="l00664"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#add7ac6272d1855504b63dc4a2db4fd88">00664</a>    size_type count(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l00665"></a>00665 <span class="keyword">      </span>{  <span class="keywordflow">return</span> m_flat_tree.find(x) == m_flat_tree.end() ? 0 : 1;  }
<a name="l00666"></a>00666 
<a name="l00671"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a4dc8735a28fc1539d3b127aeaf292bcd">00671</a>    iterator lower_bound(<span class="keyword">const</span> key_type&amp; x) 
<a name="l00672"></a>00672       {  <span class="keywordflow">return</span> force_copy&lt;iterator&gt;(m_flat_tree.lower_bound(x)); }
<a name="l00673"></a>00673 
<a name="l00678"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a8ca2ec1d218a47e640ec9d180faaa3d0">00678</a>    const_iterator lower_bound(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l00679"></a>00679 <span class="keyword">      </span>{  <span class="keywordflow">return</span> force&lt;const_iterator&gt;(m_flat_tree.lower_bound(x)); }
<a name="l00680"></a>00680 
<a name="l00685"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a447049f7e216b648ae5abb14d2629510">00685</a>    iterator upper_bound(<span class="keyword">const</span> key_type&amp; x) 
<a name="l00686"></a>00686       {  <span class="keywordflow">return</span> force_copy&lt;iterator&gt;(m_flat_tree.upper_bound(x)); }
<a name="l00687"></a>00687 
<a name="l00692"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a4503b96dbec9e2cae50effc1684964e5">00692</a>    const_iterator upper_bound(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l00693"></a>00693 <span class="keyword">      </span>{  <span class="keywordflow">return</span> force&lt;const_iterator&gt;(m_flat_tree.upper_bound(x)); }
<a name="l00694"></a>00694 
<a name="l00698"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a449086d19ecff39935754d9965391757">00698</a>    std::pair&lt;iterator,iterator&gt; equal_range(<span class="keyword">const</span> key_type&amp; x) 
<a name="l00699"></a>00699       {  <span class="keywordflow">return</span> force&lt;std::pair&lt;iterator,iterator&gt; &gt;(m_flat_tree.equal_range(x)); }
<a name="l00700"></a>00700 
<a name="l00704"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#aae44e63b397d1ce693c1cc24014a2556">00704</a>    std::pair&lt;const_iterator,const_iterator&gt; equal_range(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l00705"></a>00705 <span class="keyword">      </span>{  <span class="keywordflow">return</span> force&lt;std::pair&lt;const_iterator,const_iterator&gt; &gt;(m_flat_tree.equal_range(x)); }
<a name="l00706"></a>00706 
<a name="l00713"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#adecdc1248b53d149962cb2d4827c4797">00713</a>    size_type capacity()<span class="keyword"> const           </span>
<a name="l00714"></a>00714 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.capacity(); }
<a name="l00715"></a>00715 
<a name="l00725"></a><a class="code" href="classboost_1_1container_1_1flat__map.html#a5b907e7c6f3b21b5461fc9652650b435">00725</a>    <span class="keywordtype">void</span> reserve(size_type count)       
<a name="l00726"></a>00726       { m_flat_tree.reserve(count);   }
<a name="l00727"></a>00727 
<a name="l00729"></a>00729    <span class="keyword">template</span> &lt;<span class="keyword">class</span> K1, <span class="keyword">class</span> T1, <span class="keyword">class</span> C1, <span class="keyword">class</span> A1&gt;
<a name="l00730"></a>00730    <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator== (<span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1flat__map.html">flat_map&lt;K1, T1, C1, A1&gt;</a>&amp;,
<a name="l00731"></a>00731                            <span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1flat__map.html">flat_map&lt;K1, T1, C1, A1&gt;</a>&amp;);
<a name="l00732"></a>00732    <span class="keyword">template</span> &lt;<span class="keyword">class</span> K1, <span class="keyword">class</span> T1, <span class="keyword">class</span> C1, <span class="keyword">class</span> A1&gt;
<a name="l00733"></a>00733    <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator&lt; (const flat_map&lt;K1, T1, C1, A1&gt;&amp;,
<a name="l00734"></a>00734                            <span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1flat__map.html">flat_map&lt;K1, T1, C1, A1&gt;</a>&amp;);
<a name="l00736"></a>00736 };
<a name="l00737"></a>00737 
<a name="l00738"></a>00738 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00739"></a>00739 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> flat_map&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l00740"></a>00740                        <span class="keyword">const</span> flat_map&lt;Key,T,Pred,Alloc&gt;&amp; y) 
<a name="l00741"></a>00741    {  <span class="keywordflow">return</span> x.m_flat_tree == y.m_flat_tree;  }
<a name="l00742"></a>00742 
<a name="l00743"></a>00743 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00744"></a>00744 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&lt;(const flat_map&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l00745"></a>00745                       <span class="keyword">const</span> flat_map&lt;Key,T,Pred,Alloc&gt;&amp; y) 
<a name="l00746"></a>00746    {  <span class="keywordflow">return</span> x.m_flat_tree &lt; y.m_flat_tree;   }
<a name="l00747"></a>00747 
<a name="l00748"></a>00748 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00749"></a>00749 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> flat_map&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l00750"></a>00750                        <span class="keyword">const</span> flat_map&lt;Key,T,Pred,Alloc&gt;&amp; y) 
<a name="l00751"></a>00751    {  <span class="keywordflow">return</span> !(x == y); }
<a name="l00752"></a>00752 
<a name="l00753"></a>00753 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00754"></a>00754 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&gt;(<span class="keyword">const</span> flat_map&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l00755"></a>00755                       <span class="keyword">const</span> flat_map&lt;Key,T,Pred,Alloc&gt;&amp; y) 
<a name="l00756"></a>00756    {  <span class="keywordflow">return</span> y &lt; x;  }
<a name="l00757"></a>00757 
<a name="l00758"></a>00758 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00759"></a>00759 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&lt;=(const flat_map&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l00760"></a>00760                        <span class="keyword">const</span> flat_map&lt;Key,T,Pred,Alloc&gt;&amp; y) 
<a name="l00761"></a>00761    {  <span class="keywordflow">return</span> !(y &lt; x);  }
<a name="l00762"></a>00762 
<a name="l00763"></a>00763 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00764"></a>00764 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&gt;=(<span class="keyword">const</span> flat_map&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l00765"></a>00765                        <span class="keyword">const</span> flat_map&lt;Key,T,Pred,Alloc&gt;&amp; y) 
<a name="l00766"></a>00766    {  <span class="keywordflow">return</span> !(x &lt; y);  }
<a name="l00767"></a>00767 
<a name="l00768"></a>00768 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00769"></a>00769 <span class="keyword">inline</span> <span class="keywordtype">void</span> swap(flat_map&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l00770"></a>00770                  flat_map&lt;Key,T,Pred,Alloc&gt;&amp; y) 
<a name="l00771"></a>00771    {  x.swap(y);  }
<a name="l00772"></a>00772 
<a name="l00774"></a>00774 
<a name="l00775"></a>00775 }  <span class="comment">//namespace container {</span>
<a name="l00776"></a>00776 <span class="comment">/*</span>
<a name="l00779"></a>00779 <span class="comment">template &lt;class K, class T, class C, class A&gt;</span>
<a name="l00780"></a>00780 <span class="comment">struct has_trivial_destructor_after_move&lt;boost::container::flat_map&lt;K, T, C, A&gt; &gt;</span>
<a name="l00781"></a>00781 <span class="comment">{</span>
<a name="l00782"></a>00782 <span class="comment">   static const bool value = has_trivial_destructor&lt;A&gt;::value &amp;&amp; has_trivial_destructor&lt;C&gt;::value;</span>
<a name="l00783"></a>00783 <span class="comment">};</span>
<a name="l00784"></a>00784 <span class="comment">*/</span>
<a name="l00785"></a>00785 <span class="keyword">namespace </span>container {
<a name="l00786"></a>00786 
<a name="l00787"></a>00787 <span class="comment">// Forward declaration of operators &lt; and ==, needed for friend declaration.</span>
<a name="l00788"></a>00788 <span class="keyword">template</span> &lt;<span class="keyword">class </span>Key, <span class="keyword">class </span>T, 
<a name="l00789"></a>00789           <span class="keyword">class </span>Pred,
<a name="l00790"></a>00790           <span class="keyword">class </span>Alloc&gt;
<a name="l00791"></a>00791 <span class="keyword">class </span>flat_multimap;
<a name="l00792"></a>00792 
<a name="l00793"></a>00793 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00794"></a>00794 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> flat_multimap&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l00795"></a>00795                        <span class="keyword">const</span> flat_multimap&lt;Key,T,Pred,Alloc&gt;&amp; y);
<a name="l00796"></a>00796 
<a name="l00797"></a>00797 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00798"></a>00798 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&lt;(const flat_multimap&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l00799"></a>00799                       <span class="keyword">const</span> flat_multimap&lt;Key,T,Pred,Alloc&gt;&amp; y);
<a name="l00801"></a>00801 
<a name="l00816"></a>00816 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l00817"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html">00817</a> <span class="keyword">class </span><a class="code" href="classboost_1_1container_1_1flat__multimap.html">flat_multimap</a> 
<a name="l00818"></a>00818 {
<a name="l00820"></a>00820    <span class="keyword">private</span>:
<a name="l00821"></a>00821    BOOST_MOVE_MACRO_COPYABLE_AND_MOVABLE(<a class="code" href="classboost_1_1container_1_1flat__multimap.html">flat_multimap</a>)
<a name="l00822"></a>00822    <span class="keyword">typedef</span> <a class="code" href="classboost_1_1container_1_1containers__detail_1_1flat__tree.html">containers_detail::flat_tree</a>&lt;Key, 
<a name="l00823"></a>00823                            std::pair&lt;Key, T&gt;, 
<a name="l00824"></a>00824                            <a class="code" href="structboost_1_1container_1_1containers__detail_1_1select1st.html">containers_detail::select1st&lt; std::pair&lt;Key, T&gt;</a> &gt;, 
<a name="l00825"></a>00825                            Pred, 
<a name="l00826"></a>00826                            Alloc&gt; tree_t;
<a name="l00827"></a>00827    <span class="comment">//This is the real tree stored here. It&#39;s based on a movable pair</span>
<a name="l00828"></a>00828    <span class="keyword">typedef</span> <a class="code" href="classboost_1_1container_1_1containers__detail_1_1flat__tree.html">containers_detail::flat_tree</a>&lt;Key, 
<a name="l00829"></a>00829                            <a class="code" href="structboost_1_1container_1_1containers__detail_1_1pair.html">containers_detail::pair&lt;Key, T&gt;</a>, 
<a name="l00830"></a>00830                            <a class="code" href="structboost_1_1container_1_1containers__detail_1_1select1st.html">containers_detail::select1st&lt;containers_detail::pair&lt;Key, T&gt;</a> &gt;, 
<a name="l00831"></a>00831                            Pred, 
<a name="l00832"></a>00832                            <span class="keyword">typename</span> Alloc::template
<a name="l00833"></a>00833                               rebind&lt;containers_detail::pair&lt;Key, T&gt; &gt;::other&gt; impl_tree_t;
<a name="l00834"></a>00834    impl_tree_t m_flat_tree;  <span class="comment">// flat tree representing flat_map</span>
<a name="l00835"></a>00835 
<a name="l00836"></a>00836    <span class="keyword">typedef</span> <span class="keyword">typename</span> impl_tree_t::value_type              impl_value_type;
<a name="l00837"></a>00837    <span class="keyword">typedef</span> <span class="keyword">typename</span> impl_tree_t::pointer                 impl_pointer;
<a name="l00838"></a>00838    <span class="keyword">typedef</span> <span class="keyword">typename</span> impl_tree_t::const_pointer           impl_const_pointer;
<a name="l00839"></a>00839    <span class="keyword">typedef</span> <span class="keyword">typename</span> impl_tree_t::reference               impl_reference;
<a name="l00840"></a>00840    <span class="keyword">typedef</span> <span class="keyword">typename</span> impl_tree_t::const_reference         impl_const_reference;
<a name="l00841"></a>00841    <span class="keyword">typedef</span> <span class="keyword">typename</span> impl_tree_t::value_compare           impl_value_compare;
<a name="l00842"></a>00842    <span class="keyword">typedef</span> <span class="keyword">typename</span> impl_tree_t::iterator                impl_iterator;
<a name="l00843"></a>00843    <span class="keyword">typedef</span> <span class="keyword">typename</span> impl_tree_t::const_iterator          impl_const_iterator;
<a name="l00844"></a>00844    <span class="keyword">typedef</span> <span class="keyword">typename</span> impl_tree_t::reverse_iterator        impl_reverse_iterator;
<a name="l00845"></a>00845    <span class="keyword">typedef</span> <span class="keyword">typename</span> impl_tree_t::const_reverse_iterator  impl_const_reverse_iterator;
<a name="l00846"></a>00846    <span class="keyword">typedef</span> <span class="keyword">typename</span> impl_tree_t::allocator_type          impl_allocator_type;
<a name="l00847"></a>00847 
<a name="l00848"></a>00848    <span class="keyword">template</span>&lt;<span class="keyword">class</span> D, <span class="keyword">class</span> S&gt;
<a name="l00849"></a>00849    <span class="keyword">static</span> D &amp;force(<span class="keyword">const</span> S &amp;s)
<a name="l00850"></a>00850    {  <span class="keywordflow">return</span> *<span class="keyword">const_cast&lt;</span>D*<span class="keyword">&gt;</span>((<span class="keyword">reinterpret_cast&lt;</span><span class="keyword">const </span>D*<span class="keyword">&gt;</span>(&amp;s))); }
<a name="l00851"></a>00851 
<a name="l00852"></a>00852    <span class="keyword">template</span>&lt;<span class="keyword">class</span> D, <span class="keyword">class</span> S&gt;
<a name="l00853"></a>00853    <span class="keyword">static</span> D force_copy(S s)
<a name="l00854"></a>00854    {
<a name="l00855"></a>00855       value_type *vp = <span class="keyword">reinterpret_cast&lt;</span>value_type *<span class="keyword">&gt;</span>(&amp;*s);
<a name="l00856"></a>00856       <span class="keywordflow">return</span> D(vp);
<a name="l00857"></a>00857    }
<a name="l00859"></a>00859 
<a name="l00860"></a>00860    <span class="keyword">public</span>:
<a name="l00861"></a>00861 
<a name="l00862"></a>00862    <span class="comment">// typedefs:</span>
<a name="l00863"></a>00863    <span class="keyword">typedef</span> <span class="keyword">typename</span> impl_tree_t::key_type               key_type;
<a name="l00864"></a>00864    <span class="keyword">typedef</span> T                                            mapped_type;
<a name="l00865"></a>00865    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::pair&lt;key_type, mapped_type&gt;    value_type;
<a name="l00866"></a>00866    <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::pointer                      pointer;
<a name="l00867"></a>00867    <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::const_pointer                const_pointer;
<a name="l00868"></a>00868    <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::reference                    reference;
<a name="l00869"></a>00869    <span class="keyword">typedef</span> <span class="keyword">typename</span> Alloc::const_reference              const_reference;
<a name="l00870"></a>00870    <span class="keyword">typedef</span> <a class="code" href="classboost_1_1container_1_1containers__detail_1_1flat__tree__value__compare.html">containers_detail::flat_tree_value_compare</a>
<a name="l00871"></a>00871       &lt; Pred
<a name="l00872"></a>00872       , <a class="code" href="structboost_1_1container_1_1containers__detail_1_1select1st.html">containers_detail::select1st&lt; std::pair&lt;Key, T&gt;</a> &gt;
<a name="l00873"></a>00873       , std::pair&lt;Key, T&gt; &gt;                             <a class="code" href="classboost_1_1container_1_1containers__detail_1_1flat__tree__value__compare.html">value_compare</a>;
<a name="l00874"></a>00874    <span class="keyword">typedef</span> Pred                                         key_compare;
<a name="l00875"></a>00875    <span class="keyword">typedef</span> <span class="keyword">typename</span> containers_detail::
<a name="l00876"></a>00876       get_flat_tree_iterators&lt;pointer&gt;::iterator        iterator;
<a name="l00877"></a>00877    <span class="keyword">typedef</span> <span class="keyword">typename</span> containers_detail::
<a name="l00878"></a>00878       get_flat_tree_iterators&lt;pointer&gt;::const_iterator  const_iterator;
<a name="l00879"></a>00879    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structboost_1_1container_1_1containers__detail_1_1get__flat__tree__iterators.html">containers_detail::</a>
<a name="l00880"></a>00880 <a class="code" href="structboost_1_1container_1_1containers__detail_1_1get__flat__tree__iterators.html">      get_flat_tree_iterators</a>
<a name="l00881"></a>00881          &lt;pointer&gt;::reverse_iterator                    reverse_iterator;
<a name="l00882"></a>00882    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structboost_1_1container_1_1containers__detail_1_1get__flat__tree__iterators.html">containers_detail::</a>
<a name="l00883"></a>00883 <a class="code" href="structboost_1_1container_1_1containers__detail_1_1get__flat__tree__iterators.html">      get_flat_tree_iterators</a>
<a name="l00884"></a>00884          &lt;pointer&gt;::const_reverse_iterator              const_reverse_iterator;
<a name="l00885"></a>00885    <span class="keyword">typedef</span> <span class="keyword">typename</span> impl_tree_t::size_type              size_type;
<a name="l00886"></a>00886    <span class="keyword">typedef</span> <span class="keyword">typename</span> impl_tree_t::difference_type        difference_type;
<a name="l00887"></a>00887    <span class="keyword">typedef</span> Alloc                                        allocator_type;
<a name="l00888"></a>00888    <span class="keyword">typedef</span> Alloc                                        stored_allocator_type;
<a name="l00889"></a>00889 
<a name="l00894"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a47104a8cf0a29565494464eda092f425">00894</a>    <span class="keyword">explicit</span> <a class="code" href="classboost_1_1container_1_1flat__multimap.html">flat_multimap</a>(<span class="keyword">const</span> Pred&amp; comp = Pred(),
<a name="l00895"></a>00895                           <span class="keyword">const</span> allocator_type&amp; a = allocator_type())
<a name="l00896"></a>00896       : m_flat_tree(comp, force&lt;impl_allocator_type&gt;(a)) { }
<a name="l00897"></a>00897 
<a name="l00903"></a>00903    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
<a name="l00904"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a219301db583b201dda057f4a544af398">00904</a>    <a class="code" href="classboost_1_1container_1_1flat__multimap.html">flat_multimap</a>(InputIterator first, InputIterator last,
<a name="l00905"></a>00905             <span class="keyword">const</span> Pred&amp; comp        = Pred(),
<a name="l00906"></a>00906             <span class="keyword">const</span> allocator_type&amp; a = allocator_type())
<a name="l00907"></a>00907       : m_flat_tree(comp, force&lt;impl_allocator_type&gt;(a)) 
<a name="l00908"></a>00908       { m_flat_tree.insert_equal(first, last); }
<a name="l00909"></a>00909 
<a name="l00917"></a>00917    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
<a name="l00918"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a6832318f668c66c425255093594688b5">00918</a>    <a class="code" href="classboost_1_1container_1_1flat__multimap.html">flat_multimap</a>(ordered_range_t, InputIterator first, InputIterator last,
<a name="l00919"></a>00919             <span class="keyword">const</span> Pred&amp; comp        = Pred(),
<a name="l00920"></a>00920             <span class="keyword">const</span> allocator_type&amp; a = allocator_type())
<a name="l00921"></a>00921       : m_flat_tree(ordered_range, first, last, comp, a) 
<a name="l00922"></a>00922    {}
<a name="l00923"></a>00923 
<a name="l00927"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#ad4ab735d0c27bb7a27019e1b29a76c8c">00927</a>    <a class="code" href="classboost_1_1container_1_1flat__multimap.html">flat_multimap</a>(<span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1flat__multimap.html">flat_multimap&lt;Key,T,Pred,Alloc&gt;</a>&amp; x) 
<a name="l00928"></a>00928       : m_flat_tree(x.m_flat_tree) { }
<a name="l00929"></a>00929 
<a name="l00935"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#afec5bbd945d342bedd2a97b31f1a0d9a">00935</a>    <a class="code" href="classboost_1_1container_1_1flat__multimap.html">flat_multimap</a>(BOOST_MOVE_MACRO_RV_REF(<a class="code" href="classboost_1_1container_1_1flat__multimap.html">flat_multimap</a>) x) 
<a name="l00936"></a>00936       : m_flat_tree(BOOST_CONTAINER_MOVE_NAMESPACE::move(x.m_flat_tree))
<a name="l00937"></a>00937    { }
<a name="l00938"></a>00938 
<a name="l00942"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a9c1f577b954ea095f34e5415b11c4c51">00942</a>    <a class="code" href="classboost_1_1container_1_1flat__multimap.html">flat_multimap&lt;Key,T,Pred,Alloc&gt;</a>&amp; operator=(BOOST_MOVE_MACRO_COPY_ASSIGN_REF(<a class="code" href="classboost_1_1container_1_1flat__multimap.html">flat_multimap</a>) x) 
<a name="l00943"></a>00943       {  m_flat_tree = x.m_flat_tree;   <span class="keywordflow">return</span> *<span class="keyword">this</span>;  }
<a name="l00944"></a>00944 
<a name="l00948"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a0e9ce7a79a5528911e3d25288adfaf93">00948</a>    <a class="code" href="classboost_1_1container_1_1flat__multimap.html">flat_multimap&lt;Key,T,Pred,Alloc&gt;</a>&amp; operator=(BOOST_MOVE_MACRO_RV_REF(<a class="code" href="classboost_1_1container_1_1flat__multimap.html">flat_multimap</a>) mx) 
<a name="l00949"></a>00949       {  m_flat_tree = BOOST_CONTAINER_MOVE_NAMESPACE::move(mx.m_flat_tree);   <span class="keywordflow">return</span> *<span class="keyword">this</span>;  }
<a name="l00950"></a>00950 
<a name="l00955"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a69b7ffa72d0be1f90a7c0538a842821c">00955</a>    key_compare key_comp()<span class="keyword"> const </span>
<a name="l00956"></a>00956 <span class="keyword">      </span>{ <span class="keywordflow">return</span> force&lt;key_compare&gt;(m_flat_tree.key_comp()); }
<a name="l00957"></a>00957 
<a name="l00962"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a45853d44a8f2e0a518126f0183c09830">00962</a>    <a class="code" href="classboost_1_1container_1_1containers__detail_1_1flat__tree__value__compare.html">value_compare</a> value_comp()<span class="keyword"> const </span>
<a name="l00963"></a>00963 <span class="keyword">      </span>{ <span class="keywordflow">return</span> <a class="code" href="classboost_1_1container_1_1containers__detail_1_1flat__tree__value__compare.html">value_compare</a>(force&lt;key_compare&gt;(m_flat_tree.key_comp())); }
<a name="l00964"></a>00964 
<a name="l00969"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#adeab4af6aac3c9c9af75e9f94a0e11da">00969</a>    allocator_type get_allocator()<span class="keyword"> const </span>
<a name="l00970"></a>00970 <span class="keyword">      </span>{ <span class="keywordflow">return</span> force&lt;allocator_type&gt;(m_flat_tree.get_allocator()); }
<a name="l00971"></a>00971 
<a name="l00972"></a>00972    <span class="keyword">const</span> stored_allocator_type &amp;get_stored_allocator()<span class="keyword"> const </span>
<a name="l00973"></a>00973 <span class="keyword">      </span>{ <span class="keywordflow">return</span> force&lt;stored_allocator_type&gt;(m_flat_tree.get_stored_allocator()); }
<a name="l00974"></a>00974 
<a name="l00975"></a>00975    stored_allocator_type &amp;get_stored_allocator()
<a name="l00976"></a>00976       { <span class="keywordflow">return</span> force&lt;stored_allocator_type&gt;(m_flat_tree.get_stored_allocator()); }
<a name="l00977"></a>00977 
<a name="l00983"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a043355acd444c4692daa5700186ff9e5">00983</a>    iterator begin() 
<a name="l00984"></a>00984       { <span class="keywordflow">return</span> force_copy&lt;iterator&gt;(m_flat_tree.begin()); }
<a name="l00985"></a>00985 
<a name="l00991"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a98eea22d5328b37133d6c764d839e416">00991</a>    const_iterator begin()<span class="keyword"> const </span>
<a name="l00992"></a>00992 <span class="keyword">      </span>{ <span class="keywordflow">return</span> force&lt;const_iterator&gt;(m_flat_tree.begin()); }
<a name="l00993"></a>00993 
<a name="l00999"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#aef24b7c89454a758dec80e1ae6500926">00999</a>    iterator end() 
<a name="l01000"></a>01000       { <span class="keywordflow">return</span> force_copy&lt;iterator&gt;(m_flat_tree.end()); }
<a name="l01001"></a>01001 
<a name="l01007"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a18daed6ae2a9334ee61ec45b5fa0bf99">01007</a>    const_iterator end()<span class="keyword"> const </span>
<a name="l01008"></a>01008 <span class="keyword">      </span>{ <span class="keywordflow">return</span> force&lt;const_iterator&gt;(m_flat_tree.end()); }
<a name="l01009"></a>01009 
<a name="l01016"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#afdf53f046ac0043fcea004f0827965f1">01016</a>    reverse_iterator rbegin() 
<a name="l01017"></a>01017       { <span class="keywordflow">return</span> force&lt;reverse_iterator&gt;(m_flat_tree.rbegin()); }
<a name="l01018"></a>01018 
<a name="l01025"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a1adefca950ed1c30c626d3cb819c2b3c">01025</a>    const_reverse_iterator rbegin()<span class="keyword"> const </span>
<a name="l01026"></a>01026 <span class="keyword">      </span>{ <span class="keywordflow">return</span> force&lt;const_reverse_iterator&gt;(m_flat_tree.rbegin()); }
<a name="l01027"></a>01027 
<a name="l01034"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a0db6fd45a0f1dd9fef4cecfdce539b29">01034</a>    reverse_iterator rend() 
<a name="l01035"></a>01035       { <span class="keywordflow">return</span> force&lt;reverse_iterator&gt;(m_flat_tree.rend()); }
<a name="l01036"></a>01036 
<a name="l01043"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a78b1b8b56a08603069d2eaf4e12a8cad">01043</a>    const_reverse_iterator rend()<span class="keyword"> const </span>
<a name="l01044"></a>01044 <span class="keyword">      </span>{ <span class="keywordflow">return</span> force&lt;const_reverse_iterator&gt;(m_flat_tree.rend()); }
<a name="l01045"></a>01045 
<a name="l01051"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a360f75b70a199faa856147285624e25e">01051</a>    <span class="keywordtype">bool</span> empty()<span class="keyword"> const </span>
<a name="l01052"></a>01052 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.empty(); }
<a name="l01053"></a>01053 
<a name="l01059"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a36cae860932777364507cc3f9f88bd66">01059</a>    size_type size()<span class="keyword"> const </span>
<a name="l01060"></a>01060 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.size(); }
<a name="l01061"></a>01061 
<a name="l01067"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#af2067dbd0b24b7f4fdb80046246c0e88">01067</a>    size_type max_size()<span class="keyword"> const </span>
<a name="l01068"></a>01068 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.max_size(); }
<a name="l01069"></a>01069 
<a name="l01076"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a9d5462b7508e2dd5dbce817a00f54e53">01076</a>    <span class="keywordtype">void</span> swap(<a class="code" href="classboost_1_1container_1_1flat__multimap.html">flat_multimap</a>&amp; x)
<a name="l01077"></a>01077    { m_flat_tree.swap(x.m_flat_tree); }
<a name="l01078"></a>01078 
<a name="l01086"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a716bf96f52cb8eda29ac1d8562a24ae2">01086</a>    iterator insert(<span class="keyword">const</span> value_type&amp; x) 
<a name="l01087"></a>01087       { <span class="keywordflow">return</span> force_copy&lt;iterator&gt;(m_flat_tree.insert_equal(force&lt;impl_value_type&gt;(x))); }
<a name="l01088"></a>01088 
<a name="l01096"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a517650eb674ee396a466f8fae1e091d1">01096</a>    iterator insert(BOOST_MOVE_MACRO_RV_REF(value_type) x) 
<a name="l01097"></a>01097    { <span class="keywordflow">return</span> force_copy&lt;iterator&gt;(m_flat_tree.insert_equal(BOOST_CONTAINER_MOVE_NAMESPACE::move(x))); }
<a name="l01098"></a>01098 
<a name="l01106"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a80fbece2ca7b118a228c8669aa1379e2">01106</a>    iterator insert(BOOST_MOVE_MACRO_RV_REF(impl_value_type) x) 
<a name="l01107"></a>01107       { <span class="keywordflow">return</span> force_copy&lt;iterator&gt;(m_flat_tree.insert_equal(BOOST_CONTAINER_MOVE_NAMESPACE::move(x))); }
<a name="l01108"></a>01108 
<a name="l01120"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a3c323a70fe6f7f432cc0720231b2b224">01120</a>    iterator insert(const_iterator position, <span class="keyword">const</span> value_type&amp; x) 
<a name="l01121"></a>01121       { <span class="keywordflow">return</span> force_copy&lt;iterator&gt;(m_flat_tree.insert_equal(force&lt;impl_const_iterator&gt;(position), force&lt;impl_value_type&gt;(x))); }
<a name="l01122"></a>01122 
<a name="l01134"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a2343e8e575f5e01aef3601fb3437bd19">01134</a>    iterator insert(const_iterator position, BOOST_MOVE_MACRO_RV_REF(value_type) x) 
<a name="l01135"></a>01135    {
<a name="l01136"></a>01136       <span class="keywordflow">return</span> force_copy&lt;iterator&gt;
<a name="l01137"></a>01137          (m_flat_tree.insert_equal(force&lt;impl_const_iterator&gt;(position)
<a name="l01138"></a>01138                                   , BOOST_CONTAINER_MOVE_NAMESPACE::move(x)));
<a name="l01139"></a>01139    }
<a name="l01140"></a>01140 
<a name="l01152"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#aaff505e1624c1a193ae785b4c5f939b8">01152</a>    iterator insert(const_iterator position, BOOST_MOVE_MACRO_RV_REF(impl_value_type) x) 
<a name="l01153"></a>01153    {
<a name="l01154"></a>01154       <span class="keywordflow">return</span> force_copy&lt;iterator&gt;(
<a name="l01155"></a>01155          m_flat_tree.insert_equal(force&lt;impl_const_iterator&gt;(position), BOOST_CONTAINER_MOVE_NAMESPACE::move(x)));
<a name="l01156"></a>01156    }
<a name="l01157"></a>01157 
<a name="l01166"></a>01166    <span class="keyword">template</span> &lt;<span class="keyword">class</span> InputIterator&gt;
<a name="l01167"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#ab7acab36614e500d66aee0e74df6a145">01167</a>    <span class="keywordtype">void</span> insert(InputIterator first, InputIterator last) 
<a name="l01168"></a>01168       {  m_flat_tree.insert_equal(first, last); }
<a name="l01169"></a>01169 
<a name="l01170"></a>01170 <span class="preprocessor">   #if defined(BOOST_CONTAINERS_PERFECT_FORWARDING) || defined(BOOST_CONTAINER_DOXYGEN_INVOKED)</span>
<a name="l01171"></a>01171 <span class="preprocessor"></span>
<a name="l01180"></a>01180    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;
<a name="l01181"></a>01181    iterator emplace(Args&amp;&amp;... args)
<a name="l01182"></a>01182    {  <span class="keywordflow">return</span> force_copy&lt;iterator&gt;(m_flat_tree.emplace_equal(BOOST_CONTAINER_MOVE_NAMESPACE::forward&lt;Args&gt;(args)...)); }
<a name="l01183"></a>01183 
<a name="l01196"></a>01196    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;
<a name="l01197"></a>01197    iterator emplace_hint(const_iterator hint, Args&amp;&amp;... args)
<a name="l01198"></a>01198    {
<a name="l01199"></a>01199       <span class="keywordflow">return</span> force_copy&lt;iterator&gt;(m_flat_tree.emplace_hint_equal
<a name="l01200"></a>01200          (force&lt;impl_const_iterator&gt;(hint), BOOST_CONTAINER_MOVE_NAMESPACE::forward&lt;Args&gt;(args)...));
<a name="l01201"></a>01201    }
<a name="l01202"></a>01202 
<a name="l01203"></a>01203 <span class="preprocessor">   #else //#ifdef BOOST_CONTAINERS_PERFECT_FORWARDING</span>
<a name="l01204"></a>01204 <span class="preprocessor"></span>
<a name="l01205"></a>01205    iterator emplace()
<a name="l01206"></a>01206    {  <span class="keywordflow">return</span> force_copy&lt;iterator&gt;(m_flat_tree.emplace_equal()); }
<a name="l01207"></a>01207 
<a name="l01208"></a>01208    iterator emplace_hint(const_iterator hint)
<a name="l01209"></a>01209    {  <span class="keywordflow">return</span> force_copy&lt;iterator&gt;(m_flat_tree.emplace_hint_equal(force&lt;impl_const_iterator&gt;(hint))); }
<a name="l01210"></a>01210 
<a name="l01211"></a>01211 <span class="preprocessor">   #define BOOST_PP_LOCAL_MACRO(n)                                                                    \</span>
<a name="l01212"></a>01212 <span class="preprocessor">   template&lt;BOOST_PP_ENUM_PARAMS(n, class P)&gt;                                                         \</span>
<a name="l01213"></a>01213 <span class="preprocessor">   iterator emplace(BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_LIST, _))                            \</span>
<a name="l01214"></a>01214 <span class="preprocessor">   {                                                                                                  \</span>
<a name="l01215"></a>01215 <span class="preprocessor">      return force_copy&lt;iterator&gt;(m_flat_tree.emplace_equal                                                \</span>
<a name="l01216"></a>01216 <span class="preprocessor">         (BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_FORWARD, _)));                                 \</span>
<a name="l01217"></a>01217 <span class="preprocessor">   }                                                                                                  \</span>
<a name="l01218"></a>01218 <span class="preprocessor">                                                                                                      \</span>
<a name="l01219"></a>01219 <span class="preprocessor">   template&lt;BOOST_PP_ENUM_PARAMS(n, class P)&gt;                                                         \</span>
<a name="l01220"></a>01220 <span class="preprocessor">   iterator emplace_hint(const_iterator hint, BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_LIST, _))  \</span>
<a name="l01221"></a>01221 <span class="preprocessor">   {                                                                                                  \</span>
<a name="l01222"></a>01222 <span class="preprocessor">      return force_copy&lt;iterator&gt;(m_flat_tree.emplace_hint_equal                                           \</span>
<a name="l01223"></a>01223 <span class="preprocessor">         (force&lt;impl_const_iterator&gt;(hint),                                                           \</span>
<a name="l01224"></a>01224 <span class="preprocessor">            BOOST_PP_ENUM(n, BOOST_CONTAINERS_PP_PARAM_FORWARD, _)));                               \</span>
<a name="l01225"></a>01225 <span class="preprocessor">   }                                                                                                  \</span>
<a name="l01226"></a>01226 <span class="preprocessor"></span>
<a name="l01227"></a>01227 <span class="preprocessor">   #define BOOST_PP_LOCAL_LIMITS (1, BOOST_CONTAINERS_MAX_CONSTRUCTOR_PARAMETERS)</span>
<a name="l01228"></a>01228 <span class="preprocessor"></span><span class="preprocessor">   #include BOOST_PP_LOCAL_ITERATE()</span>
<a name="l01229"></a>01229 <span class="preprocessor"></span>
<a name="l01230"></a>01230 <span class="preprocessor">   #endif   //#ifdef BOOST_CONTAINERS_PERFECT_FORWARDING</span>
<a name="l01231"></a>01231 <span class="preprocessor"></span>
<a name="l01242"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a99fdb066292a8fde97ae427d6fd0c92a">01242</a>    iterator erase(const_iterator position) 
<a name="l01243"></a>01243       { <span class="keywordflow">return</span> force_copy&lt;iterator&gt;(m_flat_tree.erase(force&lt;impl_const_iterator&gt;(position))); }
<a name="l01244"></a>01244 
<a name="l01251"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a20b7e8ed314f82d8188aab62df652e26">01251</a>    size_type erase(<span class="keyword">const</span> key_type&amp; x) 
<a name="l01252"></a>01252       { <span class="keywordflow">return</span> m_flat_tree.erase(x); }
<a name="l01253"></a>01253 
<a name="l01262"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#ab1c83091d5cfa325941695f2f7c13d5b">01262</a>    iterator erase(const_iterator first, const_iterator last)
<a name="l01263"></a>01263       { <span class="keywordflow">return</span> force_copy&lt;iterator&gt;(m_flat_tree.erase(force&lt;impl_const_iterator&gt;(first), force&lt;impl_const_iterator&gt;(last))); }
<a name="l01264"></a>01264 
<a name="l01270"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a0debf7a8b90d1fbb3625d30949301e2e">01270</a>    <span class="keywordtype">void</span> clear() 
<a name="l01271"></a>01271       { m_flat_tree.clear(); }
<a name="l01272"></a>01272 
<a name="l01274"></a>01274    <span class="comment">//    with previous allocations. The size of the vector is unchanged</span>
<a name="l01279"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#af59cdf60bfd2eb144e26b347816c2839">01279</a> <span class="comment"></span>   <span class="keywordtype">void</span> shrink_to_fit()
<a name="l01280"></a>01280       { m_flat_tree.shrink_to_fit(); }
<a name="l01281"></a>01281 
<a name="l01286"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a92674c33e1d0cdce470f9abf7e40a068">01286</a>    iterator find(<span class="keyword">const</span> key_type&amp; x)
<a name="l01287"></a>01287       { <span class="keywordflow">return</span> force_copy&lt;iterator&gt;(m_flat_tree.find(x)); }
<a name="l01288"></a>01288 
<a name="l01293"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a458a6d9308b56f9517502290ed7e40f4">01293</a>    const_iterator find(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l01294"></a>01294 <span class="keyword">      </span>{ <span class="keywordflow">return</span> force&lt;const_iterator&gt;(m_flat_tree.find(x)); }
<a name="l01295"></a>01295 
<a name="l01299"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a297ac800935a8476a8cfe420005d4b5b">01299</a>    size_type count(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l01300"></a>01300 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.count(x); }
<a name="l01301"></a>01301 
<a name="l01306"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a989b3d811452a5caa1b93fc22eee07a6">01306</a>    iterator lower_bound(<span class="keyword">const</span> key_type&amp; x) 
<a name="l01307"></a>01307       {<span class="keywordflow">return</span> force_copy&lt;iterator&gt;(m_flat_tree.lower_bound(x)); }
<a name="l01308"></a>01308 
<a name="l01313"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a4aa629e75c78eaacbd685d6b14c6ac91">01313</a>    const_iterator lower_bound(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l01314"></a>01314 <span class="keyword">      </span>{  <span class="keywordflow">return</span> force&lt;const_iterator&gt;(m_flat_tree.lower_bound(x));  }
<a name="l01315"></a>01315 
<a name="l01320"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a84f4aae5dea62a5a1ac4c43c767e3037">01320</a>    iterator upper_bound(<span class="keyword">const</span> key_type&amp; x) 
<a name="l01321"></a>01321       {<span class="keywordflow">return</span> force_copy&lt;iterator&gt;(m_flat_tree.upper_bound(x)); }
<a name="l01322"></a>01322 
<a name="l01327"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#ad3cc0829e33c0a8d3e5a86e64768b58c">01327</a>    const_iterator upper_bound(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l01328"></a>01328 <span class="keyword">      </span>{  <span class="keywordflow">return</span> force&lt;const_iterator&gt;(m_flat_tree.upper_bound(x)); }
<a name="l01329"></a>01329 
<a name="l01333"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a924a55ed7c2a850056cb22a4051a2256">01333</a>    std::pair&lt;iterator,iterator&gt; equal_range(<span class="keyword">const</span> key_type&amp; x) 
<a name="l01334"></a>01334       {  <span class="keywordflow">return</span> force_copy&lt;std::pair&lt;iterator,iterator&gt; &gt;(m_flat_tree.equal_range(x));   }
<a name="l01335"></a>01335 
<a name="l01339"></a>01339    std::pair&lt;const_iterator,const_iterator&gt; 
<a name="l01340"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a6f1120e0ce6b331359a5518ace672747">01340</a>       equal_range(<span class="keyword">const</span> key_type&amp; x)<span class="keyword"> const </span>
<a name="l01341"></a>01341 <span class="keyword">      </span>{  <span class="keywordflow">return</span> force_copy&lt;std::pair&lt;const_iterator,const_iterator&gt; &gt;(m_flat_tree.equal_range(x));   }
<a name="l01342"></a>01342 
<a name="l01349"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#adfa4ec6b767b78ba03c503e75d07547e">01349</a>    size_type capacity()<span class="keyword"> const           </span>
<a name="l01350"></a>01350 <span class="keyword">      </span>{ <span class="keywordflow">return</span> m_flat_tree.capacity(); }
<a name="l01351"></a>01351 
<a name="l01361"></a><a class="code" href="classboost_1_1container_1_1flat__multimap.html#a60c54886488566305d417b22cc90b25e">01361</a>    <span class="keywordtype">void</span> reserve(size_type count)       
<a name="l01362"></a>01362       { m_flat_tree.reserve(count);   }
<a name="l01363"></a>01363 
<a name="l01365"></a>01365    <span class="keyword">template</span> &lt;<span class="keyword">class</span> K1, <span class="keyword">class</span> T1, <span class="keyword">class</span> C1, <span class="keyword">class</span> A1&gt;
<a name="l01366"></a>01366    <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator== (<span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1flat__multimap.html">flat_multimap&lt;K1, T1, C1, A1&gt;</a>&amp; x,
<a name="l01367"></a>01367                            <span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1flat__multimap.html">flat_multimap&lt;K1, T1, C1, A1&gt;</a>&amp; y);
<a name="l01368"></a>01368 
<a name="l01369"></a>01369    <span class="keyword">template</span> &lt;<span class="keyword">class</span> K1, <span class="keyword">class</span> T1, <span class="keyword">class</span> C1, <span class="keyword">class</span> A1&gt;
<a name="l01370"></a>01370    <span class="keyword">friend</span> <span class="keywordtype">bool</span> operator&lt; (const flat_multimap&lt;K1, T1, C1, A1&gt;&amp; x,
<a name="l01371"></a>01371                           <span class="keyword">const</span> <a class="code" href="classboost_1_1container_1_1flat__multimap.html">flat_multimap&lt;K1, T1, C1, A1&gt;</a>&amp; y);
<a name="l01373"></a>01373 };
<a name="l01374"></a>01374 
<a name="l01375"></a>01375 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l01376"></a>01376 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator==(<span class="keyword">const</span> flat_multimap&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l01377"></a>01377                        <span class="keyword">const</span> flat_multimap&lt;Key,T,Pred,Alloc&gt;&amp; y) 
<a name="l01378"></a>01378    {  <span class="keywordflow">return</span> x.m_flat_tree == y.m_flat_tree;  }
<a name="l01379"></a>01379 
<a name="l01380"></a>01380 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l01381"></a>01381 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&lt;(const flat_multimap&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l01382"></a>01382                       <span class="keyword">const</span> flat_multimap&lt;Key,T,Pred,Alloc&gt;&amp; y) 
<a name="l01383"></a>01383    {  <span class="keywordflow">return</span> x.m_flat_tree &lt; y.m_flat_tree;   }
<a name="l01384"></a>01384 
<a name="l01385"></a>01385 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l01386"></a>01386 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator!=(<span class="keyword">const</span> flat_multimap&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l01387"></a>01387                        <span class="keyword">const</span> flat_multimap&lt;Key,T,Pred,Alloc&gt;&amp; y) 
<a name="l01388"></a>01388    {  <span class="keywordflow">return</span> !(x == y);  }
<a name="l01389"></a>01389 
<a name="l01390"></a>01390 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l01391"></a>01391 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&gt;(<span class="keyword">const</span> flat_multimap&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l01392"></a>01392                       <span class="keyword">const</span> flat_multimap&lt;Key,T,Pred,Alloc&gt;&amp; y) 
<a name="l01393"></a>01393    {  <span class="keywordflow">return</span> y &lt; x;  }
<a name="l01394"></a>01394 
<a name="l01395"></a>01395 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l01396"></a>01396 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&lt;=(const flat_multimap&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l01397"></a>01397                        <span class="keyword">const</span> flat_multimap&lt;Key,T,Pred,Alloc&gt;&amp; y) 
<a name="l01398"></a>01398    {  <span class="keywordflow">return</span> !(y &lt; x);  }
<a name="l01399"></a>01399 
<a name="l01400"></a>01400 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l01401"></a>01401 <span class="keyword">inline</span> <span class="keywordtype">bool</span> operator&gt;=(<span class="keyword">const</span> flat_multimap&lt;Key,T,Pred,Alloc&gt;&amp; x, 
<a name="l01402"></a>01402                        <span class="keyword">const</span> flat_multimap&lt;Key,T,Pred,Alloc&gt;&amp; y) 
<a name="l01403"></a>01403    {  <span class="keywordflow">return</span> !(x &lt; y);  }
<a name="l01404"></a>01404 
<a name="l01405"></a>01405 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Key, <span class="keyword">class</span> T, <span class="keyword">class</span> Pred, <span class="keyword">class</span> Alloc&gt;
<a name="l01406"></a>01406 <span class="keyword">inline</span> <span class="keywordtype">void</span> swap(flat_multimap&lt;Key,T,Pred,Alloc&gt;&amp; x, flat_multimap&lt;Key,T,Pred,Alloc&gt;&amp; y) 
<a name="l01407"></a>01407    {  x.swap(y);  }
<a name="l01408"></a>01408 
<a name="l01409"></a>01409 }}
<a name="l01410"></a>01410 
<a name="l01412"></a>01412 
<a name="l01413"></a>01413 <span class="keyword">namespace </span>boost {
<a name="l01414"></a>01414 <span class="comment">/*</span>
<a name="l01417"></a>01417 <span class="comment">template &lt;class K, class T, class C, class A&gt;</span>
<a name="l01418"></a>01418 <span class="comment">struct has_trivial_destructor_after_move&lt; boost::container::flat_multimap&lt;K, T, C, A&gt; &gt;</span>
<a name="l01419"></a>01419 <span class="comment">{</span>
<a name="l01420"></a>01420 <span class="comment">   static const bool value = has_trivial_destructor&lt;A&gt;::value &amp;&amp; has_trivial_destructor&lt;C&gt;::value;</span>
<a name="l01421"></a>01421 <span class="comment">};</span>
<a name="l01422"></a>01422 <span class="comment">*/</span>
<a name="l01423"></a>01423 }  <span class="comment">//namespace boost { </span>
<a name="l01424"></a>01424 
<a name="l01426"></a>01426 
<a name="l01427"></a>01427 <span class="preprocessor">#include INCLUDE_BOOST_CONTAINER_DETAIL_CONFIG_END_HPP</span>
<a name="l01428"></a>01428 <span class="preprocessor"></span>
<a name="l01429"></a>01429 <span class="preprocessor">#endif </span><span class="comment">/* BOOST_CONTAINERS_FLAT_MAP_HPP */</span>
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Apr 27 2011 00:50:03 for Nutcracker by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
