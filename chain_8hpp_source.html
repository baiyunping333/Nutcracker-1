<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nutcracker: chain.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script src="http://www.mathjax.org/mathjax/MathJax.js">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Nutcracker</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>chain.hpp</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//@+leo-ver=5-thin</span>
<a name="l00002"></a>00002 <span class="comment">//@+node:gcross.20110130170743.1665: * @file chain.hpp</span>
<a name="l00003"></a>00003 <span class="comment">//@@language cplusplus</span>
<a name="l00004"></a>00004 
<a name="l00005"></a>00005 <span class="comment">//@+&lt;&lt; License &gt;&gt;</span>
<a name="l00006"></a>00006 <span class="comment">//@+node:gcross.20110220182654.2008: ** &lt;&lt; License &gt;&gt;</span>
<a name="l00007"></a>00007 <span class="comment">//@+at</span>
<a name="l00008"></a>00008 <span class="comment">// Copyright (c) 2011, Gregory Crosswhite</span>
<a name="l00009"></a>00009 <span class="comment">// All rights reserved.</span>
<a name="l00010"></a>00010 <span class="comment">// </span>
<a name="l00011"></a>00011 <span class="comment">// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00012"></a>00012 <span class="comment">// </span>
<a name="l00013"></a>00013 <span class="comment">//     * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00014"></a>00014 <span class="comment">//     * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00015"></a>00015 <span class="comment">// </span>
<a name="l00016"></a>00016 <span class="comment">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00017"></a>00017 <span class="comment">//@@c</span>
<a name="l00018"></a>00018 <span class="comment">//@-&lt;&lt; License &gt;&gt;</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="preprocessor">#ifndef NUTCRACKER_CHAIN_HPP</span>
<a name="l00021"></a>00021 <span class="preprocessor"></span><span class="preprocessor">#define NUTCRACKER_CHAIN_HPP</span>
<a name="l00022"></a>00022 <span class="preprocessor"></span>
<a name="l00023"></a>00023 <span class="comment">//@+&lt;&lt; Includes &gt;&gt;</span>
<a name="l00024"></a>00024 <span class="comment">//@+node:gcross.20110130170743.1666: ** &lt;&lt; Includes &gt;&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;boost/container/vector.hpp&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;boost/iterator/iterator_facade.hpp&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;boost/lambda/lambda.hpp&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;boost/move/move.hpp&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;boost/signal.hpp&gt;</span>
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="boundaries_8hpp.html" title="Functions related to boundaries.">boundaries.hpp</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="core_8hpp.html" title="Core numeric kernels.">core.hpp</a>&quot;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &quot;operators.hpp&quot;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &quot;<a class="code" href="optimizer_8hpp.html" title="Classes and functions relating to the optimizer.">optimizer.hpp</a>&quot;</span>
<a name="l00035"></a>00035 <span class="preprocessor">#include &quot;projectors.hpp&quot;</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;states.hpp&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;tensors.hpp&quot;</span>
<a name="l00038"></a>00038 <span class="comment">//@-&lt;&lt; Includes &gt;&gt;</span>
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="keyword">namespace </span>Nutcracker {
<a name="l00041"></a>00041 
<a name="l00042"></a>00042 <span class="comment">//@+&lt;&lt; Usings &gt;&gt;</span>
<a name="l00043"></a>00043 <span class="comment">//@+node:gcross.20110130170743.1667: ** &lt;&lt; Usings &gt;&gt;</span>
<a name="l00044"></a>00044 <span class="keyword">using</span> boost::function;
<a name="l00045"></a>00045 <span class="keyword">using</span> boost::irange;
<a name="l00046"></a>00046 <span class="keyword">using</span> boost::iterator_facade;
<a name="l00047"></a>00047 <span class="keyword">using</span> boost::none;
<a name="l00048"></a>00048 <span class="keyword">using</span> boost::random_access_traversal_tag;
<a name="l00049"></a>00049 <span class="keyword">using</span> boost::signal;
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="keyword">namespace </span>lambda = boost::lambda;
<a name="l00052"></a>00052 <span class="comment">//@-&lt;&lt; Usings &gt;&gt;</span>
<a name="l00053"></a>00053 
<a name="l00054"></a>00054 <span class="comment">//@+others</span>
<a name="l00055"></a>00055 <span class="comment">//@+node:gcross.20110130193548.1684: ** Exceptions</span>
<a name="l00056"></a>00056 <span class="comment">//@+node:gcross.20110202200838.1712: *3* InitialChainEnergyNotRealError</span>
<a name="l00057"></a>00057 <span class="keyword">struct </span>InitialChainEnergyNotRealError : <span class="keyword">public</span> Exception {
<a name="l00058"></a>00058     complex&lt;double&gt; <span class="keyword">const</span> energy;
<a name="l00059"></a>00059     InitialChainEnergyNotRealError(complex&lt;double&gt; <span class="keyword">const</span> energy)
<a name="l00060"></a>00060       : <a class="code" href="structNutcracker_1_1Exception.html#aa48c661e5e346938f3fe2d71eb9e9726" title="The message to be stored in this exception.">Exception</a>((
<a name="l00061"></a><a class="code" href="structNutcracker_1_1InitialChainEnergyNotRealError.html">00061</a>             format(<span class="stringliteral">&quot;The initial chain energy is not real (energy = %|.15|).&quot;</span>)
<a name="l00062"></a>00062                 % energy
<a name="l00063"></a>00063         ).str())
<a name="l00064"></a>00064       , energy(energy)
<a name="l00065"></a>00065     {}
<a name="l00066"></a>00066 };
<a name="l00067"></a>00067 <span class="comment">//@+node:gcross.20110202175920.1701: ** Classes</span>
<a name="l00068"></a>00068 <span class="comment">//@+node:gcross.20110202175920.1703: *3* Neighbor</span>
<a name="l00069"></a>00069 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> s<span class="keywordtype">id</span>e&gt; <span class="keyword">struct </span>Neighbor {
<a name="l00070"></a>00070 <span class="keyword">private</span>:
<a name="l00071"></a>00071     BOOST_MOVABLE_BUT_NOT_COPYABLE(Neighbor)
<a name="l00072"></a>00072 public:
<a name="l00073"></a><a class="code" href="structNutcracker_1_1Neighbor.html">00073</a>     <a class="code" href="classNutcracker_1_1ExpectationBoundary.html">ExpectationBoundary</a>&lt;side&gt; expectation_boundary;
<a name="l00074"></a>00074     <a class="code" href="classNutcracker_1_1StateSite.html">StateSite</a>&lt;side&gt; state_site;
<a name="l00075"></a>00075     vector&lt;<a class="code" href="classNutcracker_1_1OverlapBoundary.html">OverlapBoundary</a>&lt;side&gt; &gt; overlap_boundaries;
<a name="l00076"></a>00076 
<a name="l00077"></a>00077     <a class="code" href="structNutcracker_1_1Neighbor.html">Neighbor</a>(BOOST_RV_REF(<a class="code" href="structNutcracker_1_1Neighbor.html">Neighbor</a>) other)
<a name="l00078"></a>00078       : expectation_boundary(boost::move(other.expectation_boundary))
<a name="l00079"></a>00079       , state_site(boost::move(other.state_site))
<a name="l00080"></a>00080       , overlap_boundaries(boost::move(other.overlap_boundaries))
<a name="l00081"></a>00081     { }
<a name="l00082"></a>00082 
<a name="l00083"></a>00083     <a class="code" href="structNutcracker_1_1Neighbor.html">Neighbor</a>(
<a name="l00084"></a>00084           BOOST_RV_REF(<a class="code" href="classNutcracker_1_1ExpectationBoundary.html">ExpectationBoundary&lt;side&gt;</a>) expectation_boundary
<a name="l00085"></a>00085         , BOOST_RV_REF(<a class="code" href="classNutcracker_1_1StateSite.html">StateSite&lt;side&gt;</a>) state_site
<a name="l00086"></a>00086         , BOOST_RV_REF(vector&lt;<a class="code" href="classNutcracker_1_1OverlapBoundary.html">OverlapBoundary&lt;side&gt;</a> &gt;) overlap_boundaries
<a name="l00087"></a>00087     ) : expectation_boundary(expectation_boundary)
<a name="l00088"></a>00088       , state_site(state_site)
<a name="l00089"></a>00089       , overlap_boundaries(overlap_boundaries)
<a name="l00090"></a>00090     { }
<a name="l00091"></a>00091 
<a name="l00092"></a>00092     <span class="keywordtype">void</span> operator=(BOOST_RV_REF(Neighbor) other) {
<a name="l00093"></a>00093         expectation_boundary = boost::move(other.expectation_boundary);
<a name="l00094"></a>00094         state_site = boost::move(other.state_site);
<a name="l00095"></a>00095         overlap_boundaries = boost::move(other.overlap_boundaries);
<a name="l00096"></a>00096     }
<a name="l00097"></a>00097 };
<a name="l00098"></a>00098 <span class="comment">//@+node:gcross.20110202175920.1704: *3* Chain</span>
<a name="l00099"></a>00099 <span class="keyword">class </span>Chain {
<a name="l00100"></a>00100 <span class="keyword">public</span>:
<a name="l00101"></a>00101     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> number_of_sites;
<a name="l00102"></a>00102 <span class="keyword">protected</span>:
<a name="l00103"></a><a class="code" href="classNutcracker_1_1Chain.html">00103</a>     Operator <span class="keyword">const</span> operator_sites;
<a name="l00104"></a>00104     <a class="code" href="classNutcracker_1_1OptimizerMode.html">OptimizerMode</a> <span class="keyword">const</span> optimizer_mode;
<a name="l00105"></a>00105     vector&lt;Projector&gt; projectors;
<a name="l00106"></a>00106     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> current_site_number;
<a name="l00107"></a>00107     <a class="code" href="classNutcracker_1_1ExpectationBoundary.html">ExpectationBoundary&lt;Left&gt;</a> left_expectation_boundary;
<a name="l00108"></a>00108     vector&lt;OverlapBoundary&lt;Left&gt; &gt; left_overlap_boundaries;
<a name="l00109"></a>00109     <a class="code" href="classNutcracker_1_1ExpectationBoundary.html">ExpectationBoundary&lt;Right&gt;</a> right_expectation_boundary;
<a name="l00110"></a>00110     vector&lt;OverlapBoundary&lt;Right&gt; &gt; right_overlap_boundaries;
<a name="l00111"></a>00111     <a class="code" href="classNutcracker_1_1StateSite.html">StateSite&lt;Middle&gt;</a> state_site;
<a name="l00112"></a>00112     vector&lt;Neighbor&lt;Left&gt; &gt; left_neighbors;
<a name="l00113"></a>00113     vector&lt;Neighbor&lt;Right&gt; &gt; right_neighbors;
<a name="l00114"></a>00114     <a class="code" href="classNutcracker_1_1ProjectorMatrix.html">ProjectorMatrix</a> projector_matrix;
<a name="l00115"></a>00115     <span class="keywordtype">double</span> energy;
<a name="l00116"></a>00116     vector&lt;unsigned int&gt; physical_dimensions;
<a name="l00117"></a>00117 <span class="keyword">public</span>:
<a name="l00118"></a>00118     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> maximum_number_of_levels;
<a name="l00119"></a>00119     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> maximum_bandwidth_dimension;
<a name="l00120"></a>00120 <span class="keyword">protected</span>:
<a name="l00121"></a>00121     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bandwidth_dimension;
<a name="l00122"></a>00122 
<a name="l00123"></a>00123     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> s<span class="keywordtype">id</span>e&gt; <a class="code" href="classNutcracker_1_1ExpectationBoundary.html">ExpectationBoundary&lt;side&gt;</a>&amp; expectationBoundary() {
<a name="l00124"></a>00124         <span class="keywordflow">throw</span> <a class="code" href="structNutcracker_1_1BadLabelException.html" title="Exception thrown when an generic symbol is accessed with an invalid type tag.">BadLabelException</a>(<span class="stringliteral">&quot;Chain::expectationBoundary()&quot;</span>,<span class="keyword">typeid</span>(side));
<a name="l00125"></a>00125     }
<a name="l00126"></a>00126     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> s<span class="keywordtype">id</span>e&gt; vector&lt;OverlapBoundary&lt;side&gt; &gt;&amp; overlapBoundaries() {
<a name="l00127"></a>00127         <span class="keywordflow">throw</span> <a class="code" href="structNutcracker_1_1BadLabelException.html" title="Exception thrown when an generic symbol is accessed with an invalid type tag.">BadLabelException</a>(<span class="stringliteral">&quot;Chain::overlapBoundaries()&quot;</span>,<span class="keyword">typeid</span>(side));
<a name="l00128"></a>00128     }
<a name="l00129"></a>00129     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> s<span class="keywordtype">id</span>e&gt; vector&lt;Neighbor&lt;side&gt; &gt;&amp; neighbors() {
<a name="l00130"></a>00130         <span class="keywordflow">throw</span> BadLabelException(<span class="stringliteral">&quot;Chain::neighbors()&quot;</span>,<span class="keyword">typeid</span>(side));
<a name="l00131"></a>00131     }
<a name="l00132"></a>00132     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> s<span class="keywordtype">id</span>e&gt; <span class="keywordtype">void</span> moveSiteNumber() {
<a name="l00133"></a>00133         <span class="keywordflow">throw</span> BadLabelException(<span class="stringliteral">&quot;Chain::moveSiteNumber()&quot;</span>,<span class="keyword">typeid</span>(side));
<a name="l00134"></a>00134     }
<a name="l00135"></a>00135 
<a name="l00136"></a>00136     <span class="keywordtype">void</span> resetBoundaries();
<a name="l00137"></a>00137     <span class="keywordtype">void</span> resetProjectorMatrix();
<a name="l00138"></a>00138 
<a name="l00139"></a>00139 <span class="keyword">public</span>:
<a name="l00140"></a>00140     <span class="keyword">struct </span>Options {
<a name="l00141"></a>00141         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> maximum_number_of_iterations;
<a name="l00142"></a>00142         <span class="keywordtype">double</span> sanity_check_threshold;
<a name="l00143"></a>00143         <span class="keywordtype">double</span> site_convergence_threshold;
<a name="l00144"></a><a class="code" href="structNutcracker_1_1Chain_1_1Options.html">00144</a>         <span class="keywordtype">double</span> sweep_convergence_threshold;
<a name="l00145"></a>00145         <span class="keywordtype">double</span> chain_convergence_threshold;
<a name="l00146"></a>00146         function&lt;unsigned int (unsigned int)&gt; computeNewBandwidthDimension;
<a name="l00147"></a>00147     } options;
<a name="l00148"></a>00148     <span class="keyword">static</span> <a class="code" href="structNutcracker_1_1Chain_1_1Options.html">Options</a> <span class="keyword">const</span> defaults;
<a name="l00149"></a>00149 
<a name="l00150"></a>00150     signal&lt;void (unsigned int)&gt; signalOptimizeSiteSuccess;
<a name="l00151"></a>00151     signal&lt;void (OptimizerFailure&amp;)&gt; signalOptimizeSiteFailure;
<a name="l00152"></a>00152     signal&lt;void ()&gt; signalSweepPerformed;
<a name="l00153"></a>00153     signal&lt;void ()&gt; signalSweepsConverged;
<a name="l00154"></a>00154     signal&lt;void ()&gt; signalChainOptimized;
<a name="l00155"></a>00155     signal&lt;void ()&gt; signalChainReset;
<a name="l00156"></a>00156 
<a name="l00157"></a>00157     <a class="code" href="classNutcracker_1_1Chain.html">Chain</a>(
<a name="l00158"></a>00158       Operator <span class="keyword">const</span>&amp; operator_sites
<a name="l00159"></a>00159     , <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> initial_bandwidth = 1
<a name="l00160"></a>00160     , <a class="code" href="structNutcracker_1_1Chain_1_1Options.html">Options</a> <span class="keyword">const</span>&amp; options = defaults
<a name="l00161"></a>00161     , <a class="code" href="classNutcracker_1_1OptimizerMode.html">OptimizerMode</a> <span class="keyword">const</span>&amp; optimizer_mode = OptimizerMode::least_value
<a name="l00162"></a>00162     );
<a name="l00163"></a>00163     <span class="keywordtype">void</span> reset(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> initial_bandwidth = 1);
<a name="l00164"></a>00164 
<a name="l00165"></a>00165     <span class="keywordtype">double</span> getEnergy()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> energy; }
<a name="l00166"></a>00166     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bandwidthDimension()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> bandwidth_dimension; }
<a name="l00167"></a>00167 
<a name="l00168"></a>00168     complex&lt;double&gt; computeExpectationValueAtCurrentSite() <span class="keyword">const</span>;
<a name="l00169"></a>00169     <span class="keywordtype">double</span> computeProjectorOverlapAtCurrentSite() <span class="keyword">const</span>;
<a name="l00170"></a>00170     <span class="keywordtype">double</span> computeStateNorm() <span class="keyword">const</span>;
<a name="l00171"></a>00171 
<a name="l00172"></a>00172     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> s<span class="keywordtype">id</span>e&gt; <span class="keywordtype">void</span> absorb(BOOST_RV_REF(StateSite&lt;side&gt;) state_site, <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> operator_number);
<a name="l00173"></a>00173     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> s<span class="keywordtype">id</span>e&gt; <span class="keywordtype">void</span> move();
<a name="l00174"></a>00174     <span class="keywordtype">void</span> moveTo(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> new_site_number);
<a name="l00175"></a>00175     <span class="keywordtype">void</span> increaseBandwidthDimension(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> new_bandwidth_dimension);
<a name="l00176"></a>00176     <span class="keywordtype">void</span> convertStateToProjectorAndReset(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> new_bandwidth_dimension=1);
<a name="l00177"></a>00177 
<a name="l00178"></a>00178     <span class="keywordtype">void</span> optimizeSite();
<a name="l00179"></a>00179     <span class="keywordtype">void</span> performOptimizationSweep();
<a name="l00180"></a>00180     <span class="keywordtype">void</span> sweepUntilConverged();
<a name="l00181"></a>00181     <span class="keywordtype">void</span> optimizeChain();
<a name="l00182"></a>00182     <span class="keywordtype">void</span> solveForMultipleLevels(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_of_levels);
<a name="l00183"></a>00183 
<a name="l00184"></a>00184     State makeCopyOfState() <span class="keyword">const</span>;
<a name="l00185"></a>00185 
<a name="l00186"></a>00186     <span class="keyword">friend</span> <span class="keyword">class </span>const_iterator;
<a name="l00187"></a>00187     <span class="keyword">class </span>const_iterator :
<a name="l00188"></a>00188         <span class="keyword">public</span> iterator_facade&lt;
<a name="l00189"></a>00189              const_iterator
<a name="l00190"></a>00190             ,StateSiteAny const
<a name="l00191"></a><a class="code" href="classNutcracker_1_1Chain_1_1const__iterator.html">00191</a>             ,random_access_traversal_tag
<a name="l00192"></a>00192         &gt;
<a name="l00193"></a>00193     {
<a name="l00194"></a>00194         <a class="code" href="classNutcracker_1_1Chain.html">Chain</a> <span class="keyword">const</span>* chain;
<a name="l00195"></a>00195         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index;
<a name="l00196"></a>00196     <span class="keyword">public</span>:
<a name="l00197"></a>00197         <a class="code" href="classNutcracker_1_1Chain_1_1const__iterator.html">const_iterator</a>(
<a name="l00198"></a>00198               <a class="code" href="classNutcracker_1_1Chain.html">Chain</a> <span class="keyword">const</span>* chain
<a name="l00199"></a>00199             , <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> index
<a name="l00200"></a>00200         ) : chain(chain)
<a name="l00201"></a>00201           , index(index)
<a name="l00202"></a>00202         {}
<a name="l00203"></a>00203 
<a name="l00204"></a>00204         <a class="code" href="classNutcracker_1_1StateSiteAny.html">StateSiteAny</a> <span class="keyword">const</span>&amp; dereference()<span class="keyword"> const </span>{
<a name="l00205"></a>00205             <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = index;
<a name="l00206"></a>00206             <span class="keywordflow">if</span>(i &lt; chain-&gt;left_neighbors.size()) {
<a name="l00207"></a>00207                 <span class="keywordflow">return</span> chain-&gt;left_neighbors[i].state_site;
<a name="l00208"></a>00208             }
<a name="l00209"></a>00209             i -= chain-&gt;left_neighbors.size();
<a name="l00210"></a>00210             <span class="keywordflow">if</span>(i == 0) {
<a name="l00211"></a>00211                 <span class="keywordflow">return</span> chain-&gt;state_site;
<a name="l00212"></a>00212             }
<a name="l00213"></a>00213             i = chain-&gt;right_neighbors.size()-i;
<a name="l00214"></a>00214             assert(i &lt; chain-&gt;right_neighbors.size());
<a name="l00215"></a>00215             <span class="keywordflow">return</span> chain-&gt;right_neighbors[i].state_site;
<a name="l00216"></a>00216         }
<a name="l00217"></a>00217 
<a name="l00218"></a>00218         <span class="keywordtype">bool</span> equal(<a class="code" href="classNutcracker_1_1Chain_1_1const__iterator.html">const_iterator</a> <span class="keyword">const</span>&amp; other)<span class="keyword"> const </span>{
<a name="l00219"></a>00219             <span class="keywordflow">return</span> (chain == other.chain) &amp;&amp; (index == other.index);
<a name="l00220"></a>00220         }
<a name="l00221"></a>00221 
<a name="l00222"></a>00222         <span class="keywordtype">void</span> increment() { ++index; }
<a name="l00223"></a>00223         <span class="keywordtype">void</span> decrement() { --index; }
<a name="l00224"></a>00224 
<a name="l00225"></a>00225         <span class="keywordtype">void</span> advance(<span class="keywordtype">size_t</span> n) { index += n; }
<a name="l00226"></a>00226 
<a name="l00227"></a>00227         <span class="keywordtype">size_t</span> distance_to(<a class="code" href="classNutcracker_1_1Chain_1_1const__iterator.html">const_iterator</a> <span class="keyword">const</span>&amp; other)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> other.index - index; }
<a name="l00228"></a>00228     };
<a name="l00229"></a>00229 
<a name="l00230"></a>00230     <a class="code" href="classNutcracker_1_1Chain_1_1const__iterator.html">const_iterator</a> begin()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classNutcracker_1_1Chain_1_1const__iterator.html">const_iterator</a>(<span class="keyword">this</span>,0); }
<a name="l00231"></a>00231     const_iterator end()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> const_iterator(<span class="keyword">this</span>,number_of_sites); }
<a name="l00232"></a>00232 
<a name="l00233"></a>00233     <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Outputter&gt; <span class="keywordtype">void</span> writeStateTo(Outputter&amp; out) <span class="keyword">const</span>;
<a name="l00234"></a>00234 };
<a name="l00235"></a>00235 
<a name="l00236"></a>00236 <span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span> ExpectationBoundary&lt;Left&gt;&amp; Chain::expectationBoundary&lt;Left&gt;() { <span class="keywordflow">return</span> left_expectation_boundary; }
<a name="l00237"></a>00237 <span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span> ExpectationBoundary&lt;Right&gt;&amp; Chain::expectationBoundary&lt;Right&gt;() { <span class="keywordflow">return</span> right_expectation_boundary; }
<a name="l00238"></a>00238 
<a name="l00239"></a>00239 <span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span> vector&lt;OverlapBoundary&lt;Left&gt; &gt;&amp; Chain::overlapBoundaries&lt;Left&gt;() { <span class="keywordflow">return</span> left_overlap_boundaries; }
<a name="l00240"></a>00240 <span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span> vector&lt;OverlapBoundary&lt;Right&gt; &gt;&amp; Chain::overlapBoundaries&lt;Right&gt;() { <span class="keywordflow">return</span> right_overlap_boundaries; }
<a name="l00241"></a>00241 
<a name="l00242"></a>00242 <span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span> vector&lt;Neighbor&lt;Left&gt; &gt;&amp; Chain::neighbors&lt;Left&gt;() { <span class="keywordflow">return</span> left_neighbors; }
<a name="l00243"></a>00243 <span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span> vector&lt;Neighbor&lt;Right&gt; &gt;&amp; Chain::neighbors&lt;Right&gt;() { <span class="keywordflow">return</span> right_neighbors; }
<a name="l00244"></a>00244 
<a name="l00245"></a>00245 <span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> Chain::moveSiteNumber&lt;Left&gt;() { assert(current_site_number &gt; 0); --current_site_number; }
<a name="l00246"></a>00246 <span class="keyword">template</span>&lt;&gt; <span class="keyword">inline</span> <span class="keywordtype">void</span> Chain::moveSiteNumber&lt;Right&gt;() { assert(current_site_number &lt; number_of_sites-1); ++current_site_number; }
<a name="l00247"></a>00247 
<a name="l00248"></a>00248 <span class="comment">//@+others</span>
<a name="l00249"></a>00249 <span class="comment">//@+node:gcross.20110207120702.1786: *4* absorb</span>
<a name="l00250"></a>00250 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> s<span class="keywordtype">id</span>e&gt; <span class="keywordtype">void</span> Chain::absorb(
<a name="l00251"></a>00251       BOOST_RV_REF(StateSite&lt;side&gt;) state_site
<a name="l00252"></a>00252     , <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> site_number
<a name="l00253"></a>00253 ) {
<a name="l00254"></a>00254     ExpectationBoundary&lt;side&gt;&amp; expectation_boundary = expectationBoundary&lt;side&gt;();
<a name="l00255"></a>00255     ExpectationBoundary&lt;side&gt; new_expectation_boundary(
<a name="l00256"></a>00256         contract&lt;side&gt;::SOS(
<a name="l00257"></a>00257              expectation_boundary
<a name="l00258"></a>00258             ,state_site
<a name="l00259"></a>00259             ,*operator_sites[site_number]
<a name="l00260"></a>00260         )
<a name="l00261"></a>00261     );
<a name="l00262"></a>00262 
<a name="l00263"></a>00263     vector&lt;OverlapBoundary&lt;side&gt; &gt;&amp; overlap_boundaries = overlapBoundaries&lt;side&gt;();
<a name="l00264"></a>00264     vector&lt;OverlapBoundary&lt;side&gt; &gt; new_overlap_boundaries;
<a name="l00265"></a>00265     new_overlap_boundaries.reserve(projectors.size());
<a name="l00266"></a>00266     BOOST_FOREACH(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> i, irange(0u,(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)projectors.size())) {
<a name="l00267"></a>00267         new_overlap_boundaries.push_back(
<a name="l00268"></a>00268             contract&lt;side&gt;::SS(
<a name="l00269"></a>00269                  overlap_boundaries[i]
<a name="l00270"></a>00270                 ,projectors[i][site_number].get&lt;side&gt;()
<a name="l00271"></a>00271                 ,state_site
<a name="l00272"></a>00272             )
<a name="l00273"></a>00273         );
<a name="l00274"></a>00274     }
<a name="l00275"></a>00275 
<a name="l00276"></a>00276     neighbors&lt;side&gt;().emplace_back(
<a name="l00277"></a>00277          boost::move(expectation_boundary)
<a name="l00278"></a>00278         ,boost::move(state_site)
<a name="l00279"></a>00279         ,boost::move(overlap_boundaries)
<a name="l00280"></a>00280     );
<a name="l00281"></a>00281 
<a name="l00282"></a>00282     expectationBoundary&lt;side&gt;() = boost::move(new_expectation_boundary);
<a name="l00283"></a>00283     overlapBoundaries&lt;side&gt;() = boost::move(new_overlap_boundaries);
<a name="l00284"></a>00284 }
<a name="l00285"></a>00285 <span class="comment">//@+node:gcross.20110202175920.1705: *4* move</span>
<a name="l00286"></a>00286 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> s<span class="keywordtype">id</span>e&gt; <span class="keywordtype">void</span> Chain::move() {
<a name="l00287"></a>00287     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> operator_number = current_site_number;
<a name="l00288"></a>00288 
<a name="l00289"></a>00289     moveSiteNumber&lt;side&gt;();
<a name="l00290"></a>00290 
<a name="l00291"></a>00291     <span class="keyword">typedef</span> <span class="keyword">typename</span> Other&lt;side&gt;::value other_side;
<a name="l00292"></a>00292 
<a name="l00293"></a>00293     vector&lt;Neighbor&lt;side&gt; &gt;&amp; side_neighbors = neighbors&lt;side&gt;();
<a name="l00294"></a>00294 
<a name="l00295"></a>00295     Neighbor&lt;side&gt;&amp; neighbor = side_neighbors.back();
<a name="l00296"></a>00296 
<a name="l00297"></a>00297     MoveSiteCursorResult&lt;side&gt; cursor(moveSiteCursor&lt;side&gt;::from(
<a name="l00298"></a>00298          state_site
<a name="l00299"></a>00299         ,neighbor.state_site
<a name="l00300"></a>00300     ));
<a name="l00301"></a>00301 
<a name="l00302"></a>00302     absorb&lt;other_side&gt;(boost::move(cursor.other_side_state_site),operator_number);
<a name="l00303"></a>00303 
<a name="l00304"></a>00304     expectationBoundary&lt;side&gt;() = boost::move(neighbor.expectation_boundary);
<a name="l00305"></a>00305     overlapBoundaries&lt;side&gt;() = boost::move(neighbor.overlap_boundaries);
<a name="l00306"></a>00306 
<a name="l00307"></a>00307     state_site = boost::move(cursor.middle_state_site);
<a name="l00308"></a>00308 
<a name="l00309"></a>00309     side_neighbors.pop_back();
<a name="l00310"></a>00310 
<a name="l00311"></a>00311     resetProjectorMatrix();
<a name="l00312"></a>00312 }
<a name="l00313"></a>00313 <span class="comment">//@+node:gcross.20110511190907.3683: *4* writeStateTo</span>
<a name="l00314"></a>00314 <span class="keyword">template</span>&lt;<span class="keyword">typename</span> Outputter&gt; <span class="keywordtype">void</span> Chain::writeStateTo(Outputter&amp; out)<span class="keyword"> const </span>{
<a name="l00315"></a>00315     assert(current_site_number == 0);
<a name="l00316"></a>00316     out &lt;&lt; state_site;
<a name="l00317"></a>00317     BOOST_FOREACH(Neighbor&lt;Right&gt; <span class="keyword">const</span>&amp; neighbor, right_neighbors | reversed) {
<a name="l00318"></a>00318         out &lt;&lt; neighbor.state_site;
<a name="l00319"></a>00319     }
<a name="l00320"></a>00320 }
<a name="l00321"></a>00321 <span class="comment">//@-others</span>
<a name="l00322"></a>00322 <span class="comment">//@-others</span>
<a name="l00323"></a>00323 
<a name="l00324"></a>00324 }
<a name="l00325"></a>00325 
<a name="l00326"></a>00326 <span class="preprocessor">#endif</span>
<a name="l00327"></a>00327 <span class="preprocessor"></span><span class="comment">//@-leo</span>
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Tue May 31 2011 16:30:04 for Nutcracker by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
