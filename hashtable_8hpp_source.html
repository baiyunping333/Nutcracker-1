<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nutcracker: hashtable.hpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>hashtable.hpp</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 
<a name="l00002"></a>00002 <span class="comment">//</span>
<a name="l00003"></a>00003 <span class="comment">// (C) Copyright Ion Gaztanaga  2006-2009</span>
<a name="l00004"></a>00004 <span class="comment">//</span>
<a name="l00005"></a>00005 <span class="comment">// Distributed under the Boost Software License, Version 1.0.</span>
<a name="l00006"></a>00006 <span class="comment">//    (See accompanying file LICENSE_1_0.txt or copy at</span>
<a name="l00007"></a>00007 <span class="comment">//          http://www.boost.org/LICENSE_1_0.txt)</span>
<a name="l00008"></a>00008 <span class="comment">//</span>
<a name="l00009"></a>00009 <span class="comment">// See http://www.boost.org/libs/intrusive for documentation.</span>
<a name="l00010"></a>00010 <span class="comment">//</span>
<a name="l00012"></a>00012 <span class="comment"></span><span class="preprocessor">#ifndef BOOST_INTRUSIVE_HASHTABLE_HPP</span>
<a name="l00013"></a>00013 <span class="preprocessor"></span><span class="preprocessor">#define BOOST_INTRUSIVE_HASHTABLE_HPP</span>
<a name="l00014"></a>00014 <span class="preprocessor"></span>
<a name="l00015"></a>00015 <span class="preprocessor">#include &lt;boost/intrusive/detail/config_begin.hpp&gt;</span>
<a name="l00016"></a>00016 <span class="comment">//std C++</span>
<a name="l00017"></a>00017 <span class="preprocessor">#include &lt;functional&gt;</span>   <span class="comment">//std::equal_to</span>
<a name="l00018"></a>00018 <span class="preprocessor">#include &lt;utility&gt;</span>      <span class="comment">//std::pair</span>
<a name="l00019"></a>00019 <span class="preprocessor">#include &lt;algorithm&gt;</span>    <span class="comment">//std::swap, std::lower_bound, std::upper_bound</span>
<a name="l00020"></a>00020 <span class="preprocessor">#include &lt;cstddef&gt;</span>      <span class="comment">//std::size_t</span>
<a name="l00021"></a>00021 <span class="preprocessor">#include &lt;iterator&gt;</span>     <span class="comment">//std::iterator_traits</span>
<a name="l00022"></a>00022 <span class="comment">//boost</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;boost/intrusive/detail/assert.hpp&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;boost/static_assert.hpp&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;boost/functional/hash.hpp&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;boost/pointer_cast.hpp&gt;</span>
<a name="l00027"></a>00027 <span class="comment">//General intrusive utilities</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;boost/intrusive/intrusive_fwd.hpp&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;boost/intrusive/detail/pointer_to_other.hpp&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;boost/intrusive/detail/hashtable_node.hpp&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;boost/intrusive/detail/transform_iterator.hpp&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;boost/intrusive/link_mode.hpp&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;boost/intrusive/detail/ebo_functor_holder.hpp&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;boost/intrusive/detail/clear_on_destructor_base.hpp&gt;</span>
<a name="l00035"></a>00035 <span class="comment">//Implementation utilities</span>
<a name="l00036"></a>00036 <span class="preprocessor">#include &lt;boost/intrusive/trivial_value_traits.hpp&gt;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &lt;boost/intrusive/unordered_set_hook.hpp&gt;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;boost/intrusive/slist.hpp&gt;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &lt;boost/intrusive/detail/mpl.hpp&gt;</span>
<a name="l00040"></a>00040 
<a name="l00041"></a>00041 <span class="keyword">namespace </span>boost {
<a name="l00042"></a>00042 <span class="keyword">namespace </span>intrusive {
<a name="l00043"></a>00043 
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="keyword">namespace </span>detail {
<a name="l00047"></a>00047 
<a name="l00048"></a>00048 <span class="keyword">struct </span>hash_bool_flags
<a name="l00049"></a>00049 {
<a name="l00050"></a>00050    <span class="keyword">static</span> <span class="keyword">const</span> std::size_t unique_keys_pos        = 1u;
<a name="l00051"></a>00051    <span class="keyword">static</span> <span class="keyword">const</span> std::size_t constant_time_size_pos = 2u;
<a name="l00052"></a>00052    <span class="keyword">static</span> <span class="keyword">const</span> std::size_t power_2_buckets_pos    = 4u;
<a name="l00053"></a>00053    <span class="keyword">static</span> <span class="keyword">const</span> std::size_t cache_begin_pos        = 8u;
<a name="l00054"></a>00054    <span class="keyword">static</span> <span class="keyword">const</span> std::size_t compare_hash_pos       = 16u;
<a name="l00055"></a>00055    <span class="keyword">static</span> <span class="keyword">const</span> std::size_t incremental_pos        = 32u;
<a name="l00056"></a>00056 };
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 <span class="keyword">template</span> 
<a name="l00059"></a>00059    &lt; <span class="keyword">class  </span>ValueTraits
<a name="l00060"></a>00060    , <span class="keyword">class  </span>Hash
<a name="l00061"></a>00061    , <span class="keyword">class  </span>Equal
<a name="l00062"></a>00062    , <span class="keyword">class  </span>SizeType
<a name="l00063"></a>00063    , <span class="keyword">class  </span>BucketTraits
<a name="l00064"></a>00064    , std::size_t BoolFlags
<a name="l00065"></a>00065    &gt;
<a name="l00066"></a>00066 <span class="keyword">struct </span>usetopt
<a name="l00067"></a>00067 {
<a name="l00068"></a>00068    <span class="keyword">typedef</span> ValueTraits  value_traits;
<a name="l00069"></a>00069    <span class="keyword">typedef</span> Hash         hash;
<a name="l00070"></a>00070    <span class="keyword">typedef</span> Equal        equal;
<a name="l00071"></a>00071    <span class="keyword">typedef</span> SizeType     size_type;
<a name="l00072"></a>00072    <span class="keyword">typedef</span> BucketTraits bucket_traits;
<a name="l00073"></a>00073    <span class="keyword">static</span> <span class="keyword">const</span> std::size_t bool_flags = BoolFlags;
<a name="l00074"></a>00074 };
<a name="l00075"></a>00075 
<a name="l00076"></a>00076 <span class="keyword">template</span>
<a name="l00077"></a>00077    &lt; <span class="keyword">class </span>UsetOpt
<a name="l00078"></a>00078    , std::size_t BoolMask
<a name="l00079"></a>00079    &gt;
<a name="l00080"></a>00080 <span class="keyword">struct </span>usetopt_mask
<a name="l00081"></a>00081 {
<a name="l00082"></a>00082    <span class="keyword">typedef</span> usetopt
<a name="l00083"></a>00083       &lt;<span class="keyword">typename</span> UsetOpt::value_traits
<a name="l00084"></a>00084       ,<span class="keyword">typename</span> UsetOpt::hash
<a name="l00085"></a>00085       ,<span class="keyword">typename</span> UsetOpt::equal
<a name="l00086"></a>00086       ,<span class="keyword">typename</span> UsetOpt::size_type
<a name="l00087"></a>00087       ,<span class="keyword">typename</span> UsetOpt::bucket_traits
<a name="l00088"></a>00088       ,UsetOpt::bool_flags &amp; BoolMask
<a name="l00089"></a>00089       &gt; type;
<a name="l00090"></a>00090 };
<a name="l00091"></a>00091 
<a name="l00092"></a>00092 <span class="keyword">template</span> &lt;<span class="keyword">class</span> NodeTraits&gt;
<a name="l00093"></a>00093 <span class="keyword">struct </span>hash_reduced_slist_node_traits
<a name="l00094"></a>00094 {
<a name="l00095"></a>00095    <span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt; <span class="keyword">static</span> detail::one test(...);
<a name="l00096"></a>00096    <span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt; <span class="keyword">static</span> detail::two test(<span class="keyword">typename</span> U::reduced_slist_node_traits* = 0);
<a name="l00097"></a>00097    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> value = <span class="keyword">sizeof</span>(test&lt;NodeTraits&gt;(0)) == <span class="keyword">sizeof</span>(detail::two);
<a name="l00098"></a>00098 };
<a name="l00099"></a>00099 
<a name="l00100"></a>00100 <span class="keyword">template</span> &lt;<span class="keyword">class</span> NodeTraits&gt;
<a name="l00101"></a>00101 <span class="keyword">struct </span>apply_reduced_slist_node_traits
<a name="l00102"></a>00102 {
<a name="l00103"></a>00103    <span class="keyword">typedef</span> <span class="keyword">typename</span> NodeTraits::reduced_slist_node_traits type;
<a name="l00104"></a>00104 };
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 <span class="keyword">template</span> &lt;<span class="keyword">class</span> NodeTraits&gt;
<a name="l00107"></a>00107 <span class="keyword">struct </span>reduced_slist_node_traits
<a name="l00108"></a>00108 {
<a name="l00109"></a>00109    <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::eval_if_c
<a name="l00110"></a>00110       &lt; hash_reduced_slist_node_traits&lt;NodeTraits&gt;::value
<a name="l00111"></a>00111       , apply_reduced_slist_node_traits&lt;NodeTraits&gt;
<a name="l00112"></a>00112       , detail::identity&lt;NodeTraits&gt;
<a name="l00113"></a>00113       &gt;::type type;
<a name="l00114"></a>00114 };
<a name="l00115"></a>00115 
<a name="l00116"></a>00116 <span class="keyword">template</span>&lt;<span class="keyword">class</span> NodeTraits&gt;
<a name="l00117"></a>00117 <span class="keyword">struct </span>get_slist_impl
<a name="l00118"></a>00118 {
<a name="l00119"></a>00119    <span class="keyword">typedef</span> trivial_value_traits&lt;NodeTraits, normal_link&gt; trivial_traits;
<a name="l00120"></a>00120 
<a name="l00121"></a>00121    <span class="comment">//Reducing symbol length</span>
<a name="l00122"></a>00122    <span class="keyword">struct </span>type : make_slist
<a name="l00123"></a>00123       &lt; typename NodeTraits::node
<a name="l00124"></a>00124       , boost::intrusive::value_traits&lt;trivial_traits&gt;
<a name="l00125"></a>00125       , boost::intrusive::constant_time_size&lt;false&gt;
<a name="l00126"></a>00126       , boost::intrusive::size_type&lt;std::size_t&gt;
<a name="l00127"></a>00127       &gt;::type
<a name="l00128"></a>00128    {};
<a name="l00129"></a>00129 };
<a name="l00130"></a>00130 
<a name="l00131"></a>00131 <span class="keyword">template</span>&lt;<span class="keyword">class</span> SupposedValueTraits&gt;
<a name="l00132"></a>00132 <span class="keyword">struct </span>real_from_supposed_value_traits
<a name="l00133"></a>00133 {
<a name="l00134"></a>00134    <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::eval_if_c
<a name="l00135"></a>00135       &lt; detail::external_value_traits_is_true
<a name="l00136"></a>00136          &lt;SupposedValueTraits&gt;::value
<a name="l00137"></a>00137       , detail::eval_value_traits
<a name="l00138"></a>00138          &lt;SupposedValueTraits&gt;
<a name="l00139"></a>00139       , detail::identity
<a name="l00140"></a>00140          &lt;SupposedValueTraits&gt;
<a name="l00141"></a>00141       &gt;::type  type;
<a name="l00142"></a>00142 };
<a name="l00143"></a>00143 
<a name="l00144"></a>00144 <span class="keyword">template</span>&lt;<span class="keyword">class</span> SupposedValueTraits&gt;
<a name="l00145"></a>00145 <span class="keyword">struct </span>get_slist_impl_from_supposed_value_traits
<a name="l00146"></a>00146 {
<a name="l00147"></a>00147    <span class="keyword">typedef</span> <span class="keyword">typename</span>
<a name="l00148"></a>00148       real_from_supposed_value_traits
<a name="l00149"></a>00149          &lt; SupposedValueTraits&gt;::type           real_value_traits;
<a name="l00150"></a>00150    <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::get_node_traits
<a name="l00151"></a>00151       &lt;real_value_traits&gt;::type                 node_traits;
<a name="l00152"></a>00152    <span class="keyword">typedef</span> <span class="keyword">typename</span> get_slist_impl
<a name="l00153"></a>00153       &lt;<span class="keyword">typename</span> reduced_slist_node_traits
<a name="l00154"></a>00154          &lt;node_traits&gt;::type
<a name="l00155"></a>00155       &gt;::type                                   type;
<a name="l00156"></a>00156 };
<a name="l00157"></a>00157 
<a name="l00158"></a>00158 <span class="keyword">template</span>&lt;<span class="keyword">class</span> SupposedValueTraits&gt;
<a name="l00159"></a>00159 <span class="keyword">struct </span>unordered_bucket_impl
<a name="l00160"></a>00160 {
<a name="l00162"></a>00162    <span class="keyword">typedef</span> <span class="keyword">typename</span> 
<a name="l00163"></a>00163       get_slist_impl_from_supposed_value_traits
<a name="l00164"></a>00164          &lt;SupposedValueTraits&gt;::type            slist_impl;
<a name="l00165"></a>00165    <span class="keyword">typedef</span> detail::bucket_impl&lt;slist_impl&gt;      implementation_defined;
<a name="l00167"></a>00167    <span class="keyword">typedef</span> implementation_defined               type;
<a name="l00168"></a>00168 };
<a name="l00169"></a>00169 
<a name="l00170"></a>00170 <span class="keyword">template</span>&lt;<span class="keyword">class</span> SupposedValueTraits&gt;
<a name="l00171"></a>00171 <span class="keyword">struct </span>unordered_bucket_ptr_impl
<a name="l00172"></a>00172 {
<a name="l00174"></a>00174    <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::get_node_traits
<a name="l00175"></a>00175       &lt;SupposedValueTraits&gt;::type::node_ptr     node_ptr;
<a name="l00176"></a>00176    <span class="keyword">typedef</span> <span class="keyword">typename</span> unordered_bucket_impl
<a name="l00177"></a>00177       &lt;SupposedValueTraits&gt;::type               bucket_type;
<a name="l00178"></a>00178    <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::pointer_to_other
<a name="l00179"></a>00179       &lt;node_ptr, bucket_type&gt;::type             implementation_defined;
<a name="l00181"></a>00181    <span class="keyword">typedef</span> implementation_defined               type;
<a name="l00182"></a>00182 };
<a name="l00183"></a>00183 
<a name="l00184"></a>00184 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00185"></a>00185 <span class="keyword">struct </span>store_hash_bool
<a name="l00186"></a>00186 {
<a name="l00187"></a>00187    <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> Add&gt;
<a name="l00188"></a>00188    <span class="keyword">struct </span>two_or_three {one _[2 + Add];};
<a name="l00189"></a>00189    <span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt; <span class="keyword">static</span> one test(...);
<a name="l00190"></a>00190    <span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt; <span class="keyword">static</span> two_or_three&lt;U::store_hash&gt; test (<span class="keywordtype">int</span>);
<a name="l00191"></a>00191    <span class="keyword">static</span> <span class="keyword">const</span> std::size_t value = <span class="keyword">sizeof</span>(test&lt;T&gt;(0));
<a name="l00192"></a>00192 };
<a name="l00193"></a>00193 
<a name="l00194"></a>00194 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00195"></a>00195 <span class="keyword">struct </span>store_hash_is_true
<a name="l00196"></a>00196 {
<a name="l00197"></a>00197    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> value = store_hash_bool&lt;T&gt;::value &gt; <span class="keyword">sizeof</span>(one)*2;
<a name="l00198"></a>00198 };
<a name="l00199"></a>00199 
<a name="l00200"></a>00200 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00201"></a>00201 <span class="keyword">struct </span>optimize_multikey_bool
<a name="l00202"></a>00202 {
<a name="l00203"></a>00203    <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> Add&gt;
<a name="l00204"></a>00204    <span class="keyword">struct </span>two_or_three {one _[2 + Add];};
<a name="l00205"></a>00205    <span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt; <span class="keyword">static</span> one test(...);
<a name="l00206"></a>00206    <span class="keyword">template</span> &lt;<span class="keyword">class</span> U&gt; <span class="keyword">static</span> two_or_three&lt;U::optimize_multikey&gt; test (<span class="keywordtype">int</span>);
<a name="l00207"></a>00207    <span class="keyword">static</span> <span class="keyword">const</span> std::size_t value = <span class="keyword">sizeof</span>(test&lt;T&gt;(0));
<a name="l00208"></a>00208 };
<a name="l00209"></a>00209 
<a name="l00210"></a>00210 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00211"></a>00211 <span class="keyword">struct </span>optimize_multikey_is_true
<a name="l00212"></a>00212 {
<a name="l00213"></a>00213    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> value = optimize_multikey_bool&lt;T&gt;::value &gt; <span class="keyword">sizeof</span>(one)*2;
<a name="l00214"></a>00214 };
<a name="l00215"></a>00215 
<a name="l00216"></a>00216 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Config&gt;
<a name="l00217"></a>00217 <span class="keyword">struct </span>bucket_plus_size
<a name="l00218"></a>00218    : <span class="keyword">public</span> detail::size_holder
<a name="l00219"></a>00219       &lt; 0 != (Config::bool_flags &amp; hash_bool_flags::constant_time_size_pos)
<a name="l00220"></a>00220       , typename Config::size_type&gt;
<a name="l00221"></a>00221 {
<a name="l00222"></a>00222    <span class="keyword">typedef</span> detail::size_holder
<a name="l00223"></a>00223       &lt; 0 != (Config::bool_flags &amp; hash_bool_flags::constant_time_size_pos)
<a name="l00224"></a>00224       , <span class="keyword">typename</span> Config::size_type&gt;       size_traits;
<a name="l00225"></a>00225    <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::bucket_traits bucket_traits;
<a name="l00226"></a>00226 
<a name="l00227"></a>00227    bucket_plus_size(<span class="keyword">const</span> bucket_traits &amp;b_traits)
<a name="l00228"></a>00228       :  bucket_traits_(b_traits)
<a name="l00229"></a>00229    {}
<a name="l00230"></a>00230    bucket_traits bucket_traits_;
<a name="l00231"></a>00231 };
<a name="l00232"></a>00232 
<a name="l00233"></a>00233 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Config&gt;
<a name="l00234"></a>00234 <span class="keyword">struct </span>bucket_hash_t
<a name="l00235"></a>00235    : <span class="keyword">public</span> detail::ebo_functor_holder&lt;typename Config::hash&gt;
<a name="l00236"></a>00236 {
<a name="l00237"></a>00237    <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::hash          hasher;
<a name="l00238"></a>00238    <span class="keyword">typedef</span> detail::size_holder
<a name="l00239"></a>00239       &lt; 0 != (Config::bool_flags &amp; hash_bool_flags::constant_time_size_pos)
<a name="l00240"></a>00240       , <span class="keyword">typename</span> Config::size_type&gt;       size_traits;
<a name="l00241"></a>00241    <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::bucket_traits bucket_traits;
<a name="l00242"></a>00242 
<a name="l00243"></a>00243    bucket_hash_t(<span class="keyword">const</span> bucket_traits &amp;b_traits, <span class="keyword">const</span> hasher &amp; h)
<a name="l00244"></a>00244       :  detail::ebo_functor_holder&lt;hasher&gt;(h), bucket_plus_size_(b_traits)
<a name="l00245"></a>00245    {}
<a name="l00246"></a>00246 
<a name="l00247"></a>00247    bucket_plus_size&lt;Config&gt; bucket_plus_size_;
<a name="l00248"></a>00248 };
<a name="l00249"></a>00249 
<a name="l00250"></a>00250 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Config, <span class="keywordtype">bool</span>&gt;
<a name="l00251"></a>00251 <span class="keyword">struct </span>bucket_hash_equal_t : <span class="keyword">public</span> detail::ebo_functor_holder&lt;typename Config::equal&gt;
<a name="l00252"></a>00252 {
<a name="l00253"></a>00253    <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::equal         equal;
<a name="l00254"></a>00254    <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::hash          hasher;
<a name="l00255"></a>00255    <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::bucket_traits bucket_traits;
<a name="l00256"></a>00256 
<a name="l00257"></a>00257    bucket_hash_equal_t(<span class="keyword">const</span> bucket_traits &amp;b_traits, <span class="keyword">const</span> hasher &amp; h, <span class="keyword">const</span> equal &amp;e)
<a name="l00258"></a>00258       :  detail::ebo_functor_holder&lt;typename Config::equal&gt;(e), bucket_hash(b_traits, h)
<a name="l00259"></a>00259    {}
<a name="l00260"></a>00260    bucket_hash_t&lt;Config&gt; bucket_hash;
<a name="l00261"></a>00261 };
<a name="l00262"></a>00262 
<a name="l00263"></a>00263 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Config&gt;  <span class="comment">//cache_begin == true version</span>
<a name="l00264"></a>00264 <span class="keyword">struct </span>bucket_hash_equal_t&lt;Config, true&gt;
<a name="l00265"></a>00265    : <span class="keyword">public</span> detail::ebo_functor_holder&lt;typename Config::equal&gt;
<a name="l00266"></a>00266 {
<a name="l00267"></a>00267    <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::equal               equal;
<a name="l00268"></a>00268    <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::hash                hasher;
<a name="l00269"></a>00269    <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::bucket_traits       bucket_traits;
<a name="l00270"></a>00270    <span class="keyword">typedef</span> <span class="keyword">typename</span> unordered_bucket_ptr_impl
<a name="l00271"></a>00271       &lt;<span class="keyword">typename</span> Config::value_traits&gt;::type     bucket_ptr;
<a name="l00272"></a>00272 
<a name="l00273"></a>00273    bucket_hash_equal_t(<span class="keyword">const</span> bucket_traits &amp;b_traits, <span class="keyword">const</span> hasher &amp; h, <span class="keyword">const</span> equal &amp;e)
<a name="l00274"></a>00274       :  detail::ebo_functor_holder&lt;typename Config::equal&gt;(e), bucket_hash(b_traits, h)
<a name="l00275"></a>00275    {}
<a name="l00276"></a>00276    bucket_hash_t&lt;Config&gt; bucket_hash;
<a name="l00277"></a>00277    bucket_ptr cached_begin_;
<a name="l00278"></a>00278 };
<a name="l00279"></a>00279 
<a name="l00280"></a>00280 <span class="keyword">template</span>&lt;<span class="keyword">class</span> Config&gt;
<a name="l00281"></a>00281 <span class="keyword">struct </span>hashtable_data_t : <span class="keyword">public</span> Config::value_traits
<a name="l00282"></a>00282 {
<a name="l00283"></a>00283    <span class="keyword">static</span> <span class="keyword">const</span> std::size_t bool_flags       = Config::bool_flags;
<a name="l00284"></a>00284    <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::value_traits  value_traits;
<a name="l00285"></a>00285    <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::equal         equal;
<a name="l00286"></a>00286    <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::hash          hasher;
<a name="l00287"></a>00287    <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::bucket_traits bucket_traits;
<a name="l00288"></a>00288 
<a name="l00289"></a>00289    hashtable_data_t( <span class="keyword">const</span> bucket_traits &amp;b_traits, <span class="keyword">const</span> hasher &amp; h
<a name="l00290"></a>00290                    , <span class="keyword">const</span> equal &amp;e, <span class="keyword">const</span> value_traits &amp;val_traits)
<a name="l00291"></a>00291       :  Config::value_traits(val_traits), internal_(b_traits, h, e)
<a name="l00292"></a>00292    {}
<a name="l00293"></a>00293    <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::usetopt_mask
<a name="l00294"></a>00294       &lt; Config
<a name="l00295"></a>00295       , detail::hash_bool_flags::constant_time_size_pos
<a name="l00296"></a>00296       | detail::hash_bool_flags::incremental_pos
<a name="l00297"></a>00297       &gt;::type masked_config_t;
<a name="l00298"></a>00298    <span class="keyword">struct </span>internal
<a name="l00299"></a>00299       :  <span class="keyword">public</span> detail::size_holder
<a name="l00300"></a>00300          &lt; 0 != (Config::bool_flags &amp; hash_bool_flags::incremental_pos)
<a name="l00301"></a>00301          , typename Config::size_type&gt;
<a name="l00302"></a>00302    {
<a name="l00303"></a>00303       <span class="keyword">internal</span>(<span class="keyword">const</span> bucket_traits &amp;b_traits, <span class="keyword">const</span> hasher &amp; h, <span class="keyword">const</span> equal &amp;e)
<a name="l00304"></a>00304          :  bucket_hash_equal_(b_traits, h, e)
<a name="l00305"></a>00305       {}
<a name="l00306"></a>00306 
<a name="l00307"></a>00307       bucket_hash_equal_t
<a name="l00308"></a>00308          &lt; masked_config_t
<a name="l00309"></a>00309          , 0 != (bool_flags &amp; hash_bool_flags::cache_begin_pos)
<a name="l00310"></a>00310          &gt; bucket_hash_equal_;
<a name="l00311"></a>00311    } internal_;
<a name="l00312"></a>00312 };
<a name="l00313"></a>00313 
<a name="l00314"></a>00314 <span class="keyword">struct </span>insert_commit_data_impl
<a name="l00315"></a>00315 {
<a name="l00316"></a>00316    std::size_t hash;
<a name="l00317"></a>00317 };
<a name="l00318"></a>00318 
<a name="l00319"></a>00319 <span class="keyword">template</span>&lt;<span class="keyword">class</span> NodeTraits&gt;
<a name="l00320"></a>00320 <span class="keyword">struct </span>group_functions
<a name="l00321"></a>00321 {
<a name="l00322"></a>00322    <span class="keyword">typedef</span> NodeTraits                                             node_traits;
<a name="l00323"></a>00323    <span class="keyword">typedef</span> unordered_group_adapter&lt;node_traits&gt;                   group_traits;
<a name="l00324"></a>00324    <span class="keyword">typedef</span> <span class="keyword">typename</span> node_traits::node_ptr                         node_ptr;
<a name="l00325"></a>00325    <span class="keyword">typedef</span> <span class="keyword">typename</span> node_traits::node                             node;
<a name="l00326"></a>00326    <span class="keyword">typedef</span> <span class="keyword">typename</span> reduced_slist_node_traits
<a name="l00327"></a>00327       &lt;node_traits&gt;::type                                         reduced_node_traits;
<a name="l00328"></a>00328    <span class="keyword">typedef</span> <span class="keyword">typename</span> reduced_node_traits::node_ptr                 slist_node_ptr;
<a name="l00329"></a>00329    <span class="keyword">typedef</span> <span class="keyword">typename</span> reduced_node_traits::node                     slist_node;
<a name="l00330"></a>00330    <span class="keyword">typedef</span> circular_slist_algorithms&lt;group_traits&gt;                group_algorithms;
<a name="l00331"></a>00331 
<a name="l00332"></a>00332    <span class="keyword">static</span> node_ptr dcast_bucket_ptr(slist_node_ptr p)
<a name="l00333"></a>00333    {
<a name="l00334"></a>00334       using ::boost::static_pointer_cast;
<a name="l00335"></a>00335       <span class="keywordflow">return</span> static_pointer_cast&lt;node&gt;(p);
<a name="l00336"></a>00336    }
<a name="l00337"></a>00337 
<a name="l00338"></a>00338    <span class="keyword">static</span> slist_node_ptr priv_get_bucket_before_begin
<a name="l00339"></a>00339       (slist_node_ptr bucket_beg, slist_node_ptr bucket_end, node_ptr p)
<a name="l00340"></a>00340    {
<a name="l00341"></a>00341       <span class="comment">//First find the last node of p&#39;s group.</span>
<a name="l00342"></a>00342       <span class="comment">//This requires checking the first node of the next group or</span>
<a name="l00343"></a>00343       <span class="comment">//the bucket node.</span>
<a name="l00344"></a>00344       node_ptr prev_node = p;
<a name="l00345"></a>00345       node_ptr nxt(node_traits::get_next(p));
<a name="l00346"></a>00346       <span class="keywordflow">while</span>(!(bucket_beg &lt;= nxt &amp;&amp; nxt &lt;= bucket_end) &amp;&amp;
<a name="l00347"></a>00347              (group_traits::get_next(nxt) == prev_node)){
<a name="l00348"></a>00348          prev_node = nxt;
<a name="l00349"></a>00349          nxt = node_traits::get_next(nxt);
<a name="l00350"></a>00350       }
<a name="l00351"></a>00351 
<a name="l00352"></a>00352       <span class="comment">//If we&#39;ve reached the bucket node just return it.</span>
<a name="l00353"></a>00353       <span class="keywordflow">if</span>(bucket_beg &lt;= nxt &amp;&amp; nxt &lt;= bucket_end){
<a name="l00354"></a>00354          <span class="keywordflow">return</span> nxt;
<a name="l00355"></a>00355       }
<a name="l00356"></a>00356 
<a name="l00357"></a>00357       <span class="comment">//Otherwise, iterate using group links until the bucket node</span>
<a name="l00358"></a>00358       node_ptr first_node_of_group  = nxt;
<a name="l00359"></a>00359       node_ptr last_node_group      = group_traits::get_next(first_node_of_group);
<a name="l00360"></a>00360       slist_node_ptr possible_end   = node_traits::get_next(last_node_group);
<a name="l00361"></a>00361 
<a name="l00362"></a>00362       <span class="keywordflow">while</span>(!(bucket_beg &lt;= possible_end &amp;&amp; possible_end &lt;= bucket_end)){
<a name="l00363"></a>00363          first_node_of_group = dcast_bucket_ptr(possible_end);
<a name="l00364"></a>00364          last_node_group   = group_traits::get_next(first_node_of_group);
<a name="l00365"></a>00365          possible_end      = node_traits::get_next(last_node_group);
<a name="l00366"></a>00366       }
<a name="l00367"></a>00367       <span class="keywordflow">return</span> possible_end;
<a name="l00368"></a>00368    }
<a name="l00369"></a>00369 
<a name="l00370"></a>00370    <span class="keyword">static</span> node_ptr priv_get_prev_to_first_in_group(slist_node_ptr bucket_node, node_ptr first_in_group)
<a name="l00371"></a>00371    {
<a name="l00372"></a>00372       <span class="comment">//Just iterate using group links and obtain the node</span>
<a name="l00373"></a>00373       <span class="comment">//before &quot;first_in_group)&quot;</span>
<a name="l00374"></a>00374       node_ptr prev_node = dcast_bucket_ptr(bucket_node);
<a name="l00375"></a>00375       node_ptr nxt(node_traits::get_next(prev_node));
<a name="l00376"></a>00376       <span class="keywordflow">while</span>(nxt != first_in_group){
<a name="l00377"></a>00377          prev_node = group_traits::get_next(nxt);
<a name="l00378"></a>00378          nxt = node_traits::get_next(prev_node);
<a name="l00379"></a>00379       }
<a name="l00380"></a>00380       <span class="keywordflow">return</span> prev_node;
<a name="l00381"></a>00381    }
<a name="l00382"></a>00382 
<a name="l00383"></a>00383    <span class="keyword">static</span> node_ptr priv_get_first_in_group_of_last_in_group(node_ptr last_in_group)
<a name="l00384"></a>00384    {
<a name="l00385"></a>00385       <span class="comment">//Just iterate using group links and obtain the node</span>
<a name="l00386"></a>00386       <span class="comment">//before &quot;last_in_group&quot;</span>
<a name="l00387"></a>00387       node_ptr possible_first = group_traits::get_next(last_in_group);
<a name="l00388"></a>00388       node_ptr possible_first_prev = group_traits::get_next(possible_first);
<a name="l00389"></a>00389       <span class="comment">// The deleted node is at the end of the group, so the</span>
<a name="l00390"></a>00390       <span class="comment">// node in the group pointing to it is at the beginning</span>
<a name="l00391"></a>00391       <span class="comment">// of the group. Find that to change its pointer.</span>
<a name="l00392"></a>00392       <span class="keywordflow">while</span>(possible_first_prev != last_in_group){
<a name="l00393"></a>00393          possible_first = possible_first_prev;
<a name="l00394"></a>00394          possible_first_prev = group_traits::get_next(possible_first);
<a name="l00395"></a>00395       }
<a name="l00396"></a>00396       <span class="keywordflow">return</span> possible_first;
<a name="l00397"></a>00397    }
<a name="l00398"></a>00398 
<a name="l00399"></a>00399 
<a name="l00400"></a>00400    <span class="keyword">static</span> <span class="keywordtype">void</span> priv_erase_from_group(slist_node_ptr end_ptr, node_ptr to_erase_ptr, detail::true_)
<a name="l00401"></a>00401    {
<a name="l00402"></a>00402       node_ptr nxt_ptr(node_traits::get_next(to_erase_ptr));
<a name="l00403"></a>00403       node_ptr prev_in_group_ptr(group_traits::get_next(to_erase_ptr));
<a name="l00404"></a>00404       <span class="keywordtype">bool</span> last_in_group = (end_ptr == nxt_ptr) ||
<a name="l00405"></a>00405          (group_traits::get_next(nxt_ptr) != to_erase_ptr);
<a name="l00406"></a>00406       <span class="keywordtype">bool</span> first_in_group = node_traits::get_next(prev_in_group_ptr) != to_erase_ptr;
<a name="l00407"></a>00407 
<a name="l00408"></a>00408       <span class="keywordflow">if</span>(first_in_group &amp;&amp; last_in_group){
<a name="l00409"></a>00409          group_algorithms::init(to_erase_ptr);
<a name="l00410"></a>00410       }
<a name="l00411"></a>00411       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(first_in_group){
<a name="l00412"></a>00412          group_algorithms::unlink_after(nxt_ptr);
<a name="l00413"></a>00413       }
<a name="l00414"></a>00414       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(last_in_group){
<a name="l00415"></a>00415          node_ptr first_in_group =
<a name="l00416"></a>00416             priv_get_first_in_group_of_last_in_group(to_erase_ptr);
<a name="l00417"></a>00417          group_algorithms::unlink_after(first_in_group);
<a name="l00418"></a>00418       }
<a name="l00419"></a>00419       <span class="keywordflow">else</span>{
<a name="l00420"></a>00420          group_algorithms::unlink_after(nxt_ptr);
<a name="l00421"></a>00421       }
<a name="l00422"></a>00422    }
<a name="l00423"></a>00423 
<a name="l00424"></a>00424    <span class="keyword">static</span> <span class="keywordtype">void</span> priv_erase_from_group(slist_node_ptr, node_ptr, detail::false_)
<a name="l00425"></a>00425    {}
<a name="l00426"></a>00426 
<a name="l00427"></a>00427    <span class="keyword">static</span> node_ptr priv_get_last_in_group(node_ptr first_in_group, detail::true_)
<a name="l00428"></a>00428    {  <span class="keywordflow">return</span> group_traits::get_next(first_in_group);  }
<a name="l00429"></a>00429 
<a name="l00430"></a>00430    <span class="keyword">static</span> node_ptr priv_get_last_in_group(node_ptr n, detail::false_)
<a name="l00431"></a>00431    {  <span class="keywordflow">return</span> n;  }
<a name="l00432"></a>00432 };
<a name="l00433"></a>00433 
<a name="l00434"></a>00434 <span class="keyword">template</span>&lt;<span class="keyword">class</span> BucketType, <span class="keyword">class</span> SplitTraits&gt;
<a name="l00435"></a>00435 <span class="keyword">class </span>incremental_rehash_rollback
<a name="l00436"></a>00436 {
<a name="l00437"></a>00437    <span class="keyword">private</span>:
<a name="l00438"></a>00438    <span class="keyword">typedef</span> BucketType   bucket_type;
<a name="l00439"></a>00439    <span class="keyword">typedef</span> SplitTraits  split_traits;
<a name="l00440"></a>00440 
<a name="l00441"></a>00441    incremental_rehash_rollback();
<a name="l00442"></a>00442    incremental_rehash_rollback &amp; operator=(<span class="keyword">const</span> incremental_rehash_rollback &amp;);
<a name="l00443"></a>00443    incremental_rehash_rollback (<span class="keyword">const</span> incremental_rehash_rollback &amp;);
<a name="l00444"></a>00444 
<a name="l00445"></a>00445    <span class="keyword">public</span>:
<a name="l00446"></a>00446    incremental_rehash_rollback
<a name="l00447"></a>00447       (bucket_type &amp;source_bucket, bucket_type &amp;destiny_bucket, split_traits &amp;split_traits)
<a name="l00448"></a>00448       :  source_bucket_(source_bucket),  destiny_bucket_(destiny_bucket)
<a name="l00449"></a>00449       ,  split_traits_(split_traits),  released_(false)
<a name="l00450"></a>00450    {}
<a name="l00451"></a>00451 
<a name="l00452"></a>00452    <span class="keywordtype">void</span> release()
<a name="l00453"></a>00453    {  released_ = <span class="keyword">true</span>; }
<a name="l00454"></a>00454 
<a name="l00455"></a>00455    ~incremental_rehash_rollback()
<a name="l00456"></a>00456    {
<a name="l00457"></a>00457       <span class="keywordflow">if</span>(!released_){
<a name="l00458"></a>00458          <span class="comment">//If an exception is thrown, just put all moved nodes back in the old bucket</span>
<a name="l00459"></a>00459          <span class="comment">//and move back the split mark.</span>
<a name="l00460"></a>00460          destiny_bucket_.splice_after(destiny_bucket_.before_begin(), source_bucket_);
<a name="l00461"></a>00461          split_traits_.decrement();
<a name="l00462"></a>00462       }
<a name="l00463"></a>00463    }
<a name="l00464"></a>00464 
<a name="l00465"></a>00465    <span class="keyword">private</span>:
<a name="l00466"></a>00466    bucket_type &amp;source_bucket_;
<a name="l00467"></a>00467    bucket_type &amp;destiny_bucket_;
<a name="l00468"></a>00468    split_traits &amp;split_traits_;
<a name="l00469"></a>00469    <span class="keywordtype">bool</span> released_;
<a name="l00470"></a>00470 };
<a name="l00471"></a>00471 
<a name="l00472"></a>00472 }  <span class="comment">//namespace detail {</span>
<a name="l00473"></a>00473 
<a name="l00477"></a>00477 <span class="keyword">template</span>&lt;<span class="keyword">class</span> ValueTraitsOrHookOption&gt;
<a name="l00478"></a>00478 <span class="keyword">struct </span>unordered_bucket
<a name="l00479"></a>00479    : <span class="keyword">public</span> detail::unordered_bucket_impl
<a name="l00480"></a>00480       &lt;typename ValueTraitsOrHookOption::
<a name="l00481"></a>00481          template pack&lt;none&gt;::value_traits
<a name="l00482"></a>00482       &gt;
<a name="l00483"></a>00483 {};
<a name="l00484"></a>00484 
<a name="l00488"></a>00488 <span class="keyword">template</span>&lt;<span class="keyword">class</span> ValueTraitsOrHookOption&gt;
<a name="l00489"></a>00489 <span class="keyword">struct </span>unordered_bucket_ptr
<a name="l00490"></a>00490    :  <span class="keyword">public</span> detail::unordered_bucket_ptr_impl
<a name="l00491"></a>00491          &lt;typename ValueTraitsOrHookOption::
<a name="l00492"></a>00492           template pack&lt;none&gt;::value_traits
<a name="l00493"></a>00493          &gt;
<a name="l00494"></a>00494 {};
<a name="l00495"></a>00495 
<a name="l00500"></a>00500 <span class="keyword">template</span>&lt;<span class="keyword">class</span> ValueTraitsOrHookOption&gt;
<a name="l00501"></a>00501 <span class="keyword">struct </span>unordered_default_bucket_traits
<a name="l00502"></a>00502 {
<a name="l00504"></a>00504    <span class="keyword">typedef</span> <span class="keyword">typename</span> ValueTraitsOrHookOption::
<a name="l00505"></a>00505       template pack&lt;none&gt;::value_traits         supposed_value_traits;
<a name="l00506"></a>00506    <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::
<a name="l00507"></a>00507       get_slist_impl_from_supposed_value_traits
<a name="l00508"></a>00508          &lt;supposed_value_traits&gt;::type          slist_impl;
<a name="l00509"></a>00509    <span class="keyword">typedef</span> detail::bucket_traits_impl
<a name="l00510"></a>00510       &lt;slist_impl&gt;                              implementation_defined;
<a name="l00512"></a>00512    <span class="keyword">typedef</span> implementation_defined               type;
<a name="l00513"></a>00513 };
<a name="l00514"></a>00514 
<a name="l00515"></a>00515 <span class="keyword">struct </span>default_bucket_traits;
<a name="l00516"></a>00516 
<a name="l00517"></a>00517 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00518"></a>00518 <span class="keyword">struct </span>uset_defaults
<a name="l00519"></a>00519    :  pack_options
<a name="l00520"></a>00520       &lt; none
<a name="l00521"></a>00521       , base_hook&lt;detail::default_uset_hook&gt;
<a name="l00522"></a>00522       , constant_time_size&lt;true&gt;
<a name="l00523"></a>00523       , size_type&lt;std::size_t&gt;
<a name="l00524"></a>00524       , equal&lt;std::equal_to&lt;T&gt; &gt;
<a name="l00525"></a>00525       , hash&lt;boost::hash&lt;T&gt; &gt;
<a name="l00526"></a>00526       , bucket_traits&lt;default_bucket_traits&gt;
<a name="l00527"></a>00527       , power_2_buckets&lt;false&gt;
<a name="l00528"></a>00528       , cache_begin&lt;false&gt;
<a name="l00529"></a>00529       , compare_hash&lt;false&gt;
<a name="l00530"></a>00530       , incremental&lt;false&gt;
<a name="l00531"></a>00531       &gt;::type
<a name="l00532"></a>00532 {};
<a name="l00533"></a>00533 
<a name="l00535"></a>00535 
<a name="l00572"></a>00572 <span class="preprocessor">#if defined(BOOST_INTRUSIVE_DOXYGEN_INVOKED)</span>
<a name="l00573"></a>00573 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class </span>T, <span class="keyword">class </span>...Options&gt;
<a name="l00574"></a>00574 <span class="preprocessor">#else</span>
<a name="l00575"></a>00575 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class</span> Config&gt;
<a name="l00576"></a>00576 <span class="preprocessor">#endif</span>
<a name="l00577"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html">00577</a> <span class="preprocessor"></span><span class="keyword">class </span><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html">hashtable_impl</a>
<a name="l00578"></a>00578    :  <span class="keyword">private</span> detail::clear_on_destructor_base&lt;hashtable_impl&lt;Config&gt; &gt;
<a name="l00579"></a>00579 {
<a name="l00580"></a>00580    <span class="keyword">template</span>&lt;<span class="keyword">class</span> C&gt; <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classboost_1_1intrusive_1_1detail_1_1clear__on__destructor__base.html">detail::clear_on_destructor_base</a>;
<a name="l00581"></a>00581    <span class="keyword">public</span>:
<a name="l00582"></a>00582    <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::value_traits                             value_traits;
<a name="l00583"></a>00583 
<a name="l00585"></a>00585    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> external_value_traits =
<a name="l00586"></a>00586       <a class="code" href="structboost_1_1intrusive_1_1detail_1_1external__value__traits__is__true.html">detail::external_value_traits_is_true&lt;value_traits&gt;::value</a>;
<a name="l00587"></a>00587    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structboost_1_1intrusive_1_1detail_1_1eval__if__c.html">detail::eval_if_c</a>
<a name="l00588"></a>00588       &lt; external_value_traits
<a name="l00589"></a>00589       , detail::eval_value_traits&lt;value_traits&gt;
<a name="l00590"></a>00590       , <a class="code" href="structboost_1_1intrusive_1_1detail_1_1identity.html">detail::identity&lt;value_traits&gt;</a>
<a name="l00591"></a>00591       &gt;::type                                                        real_value_traits;
<a name="l00592"></a>00592    <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::bucket_traits                            <a class="code" href="structboost_1_1intrusive_1_1bucket__traits.html">bucket_traits</a>;
<a name="l00593"></a>00593    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> external_bucket_traits =
<a name="l00594"></a>00594       detail::external_bucket_traits_is_true&lt;bucket_traits&gt;::value;
<a name="l00595"></a>00595    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structboost_1_1intrusive_1_1detail_1_1eval__if__c.html">detail::eval_if_c</a>
<a name="l00596"></a>00596       &lt; external_bucket_traits
<a name="l00597"></a>00597       , detail::eval_bucket_traits&lt;bucket_traits&gt;
<a name="l00598"></a>00598       , <a class="code" href="structboost_1_1intrusive_1_1detail_1_1identity.html">detail::identity&lt;bucket_traits&gt;</a>
<a name="l00599"></a>00599       &gt;::type                                                        real_bucket_traits;
<a name="l00600"></a>00600    <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::get_slist_impl
<a name="l00601"></a>00601       &lt;<span class="keyword">typename</span> detail::reduced_slist_node_traits
<a name="l00602"></a>00602          &lt;<span class="keyword">typename</span> real_value_traits::node_traits&gt;::type
<a name="l00603"></a>00603       &gt;::type                                                        <a class="code" href="classboost_1_1intrusive_1_1slist__impl.html">slist_impl</a>;
<a name="l00605"></a>00605 
<a name="l00606"></a>00606    <span class="keyword">typedef</span> <span class="keyword">typename</span> real_value_traits::pointer                       pointer;
<a name="l00607"></a>00607    <span class="keyword">typedef</span> <span class="keyword">typename</span> real_value_traits::const_pointer                 const_pointer;
<a name="l00608"></a>00608    <span class="keyword">typedef</span> <span class="keyword">typename</span> real_value_traits::value_type                                                value_type;
<a name="l00609"></a>00609    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;pointer&gt;::reference         reference;
<a name="l00610"></a>00610    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;const_pointer&gt;::reference   const_reference;
<a name="l00611"></a>00611    <span class="keyword">typedef</span> <span class="keyword">typename</span> std::iterator_traits&lt;pointer&gt;::difference_type   difference_type;
<a name="l00612"></a>00612    <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::size_type                                size_type;
<a name="l00613"></a>00613    <span class="keyword">typedef</span> value_type                                                key_type;
<a name="l00614"></a>00614    <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::equal                                    key_equal;
<a name="l00615"></a>00615    <span class="keyword">typedef</span> <span class="keyword">typename</span> Config::hash                                     hasher;
<a name="l00616"></a>00616    <span class="keyword">typedef</span> <a class="code" href="structboost_1_1intrusive_1_1detail_1_1bucket__impl.html">detail::bucket_impl&lt;slist_impl&gt;</a>                           <a class="code" href="structboost_1_1intrusive_1_1detail_1_1bucket__impl.html">bucket_type</a>;
<a name="l00617"></a>00617    <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::pointer_to_other
<a name="l00618"></a>00618       &lt;pointer, <a class="code" href="structboost_1_1intrusive_1_1detail_1_1bucket__impl.html">bucket_type</a>&gt;::type                                   bucket_ptr;
<a name="l00619"></a>00619    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">slist_impl::iterator</a>                             <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a>;
<a name="l00620"></a>00620    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">slist_impl::const_iterator</a>                       <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">const_siterator</a>;
<a name="l00621"></a>00621    <span class="keyword">typedef</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">detail::hashtable_iterator&lt;hashtable_impl, false&gt;</a>         <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">iterator</a>;
<a name="l00622"></a>00622    <span class="keyword">typedef</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">detail::hashtable_iterator&lt;hashtable_impl, true&gt;</a>          <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">const_iterator</a>;
<a name="l00623"></a>00623    <span class="keyword">typedef</span> <span class="keyword">typename</span> real_value_traits::node_traits                   node_traits;
<a name="l00624"></a>00624    <span class="keyword">typedef</span> <span class="keyword">typename</span> node_traits::node                                node;
<a name="l00625"></a>00625    <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::pointer_to_other
<a name="l00626"></a>00626       &lt;pointer, node&gt;::type                                          node_ptr;
<a name="l00627"></a>00627    <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::pointer_to_other
<a name="l00628"></a>00628       &lt;node_ptr, <span class="keyword">const</span> node&gt;::type                                   const_node_ptr;
<a name="l00629"></a>00629    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structboost_1_1intrusive_1_1detail_1_1constptr.html">slist_impl::node_algorithms</a>                      <a class="code" href="structboost_1_1intrusive_1_1detail_1_1constptr.html">node_algorithms</a>;
<a name="l00630"></a>00630 
<a name="l00631"></a>00631    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> stateful_value_traits = <a class="code" href="structboost_1_1intrusive_1_1detail_1_1is__stateful__value__traits.html">detail::is_stateful_value_traits&lt;real_value_traits&gt;::value</a>;
<a name="l00632"></a>00632    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="structboost_1_1intrusive_1_1store__hash.html">store_hash</a> = detail::store_hash_is_true&lt;node_traits&gt;::value;
<a name="l00633"></a>00633 
<a name="l00634"></a>00634    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> unique_keys          = 0 != (Config::bool_flags  &amp; detail::hash_bool_flags::unique_keys_pos);
<a name="l00635"></a>00635    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="structboost_1_1intrusive_1_1constant__time__size.html">constant_time_size</a>   = 0 != (Config::bool_flags  &amp; detail::hash_bool_flags::constant_time_size_pos);
<a name="l00636"></a>00636    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="structboost_1_1intrusive_1_1cache__begin.html">cache_begin</a>          = 0 != (Config::bool_flags  &amp; detail::hash_bool_flags::cache_begin_pos);
<a name="l00637"></a>00637    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="structboost_1_1intrusive_1_1compare__hash.html">compare_hash</a>         = 0 != (Config::bool_flags  &amp; detail::hash_bool_flags::compare_hash_pos);
<a name="l00638"></a>00638    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="structboost_1_1intrusive_1_1incremental.html">incremental</a>          = 0 != (Config::bool_flags  &amp; detail::hash_bool_flags::incremental_pos);
<a name="l00639"></a>00639    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="structboost_1_1intrusive_1_1power__2__buckets.html">power_2_buckets</a>      = <a class="code" href="structboost_1_1intrusive_1_1incremental.html">incremental</a> || (0 != (Config::bool_flags  &amp; detail::hash_bool_flags::power_2_buckets_pos));
<a name="l00640"></a>00640 
<a name="l00641"></a>00641    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> <a class="code" href="structboost_1_1intrusive_1_1optimize__multikey.html">optimize_multikey</a>
<a name="l00642"></a>00642       = detail::optimize_multikey_is_true&lt;node_traits&gt;::value &amp;&amp; !unique_keys;
<a name="l00643"></a>00643 
<a name="l00645"></a>00645    <span class="keyword">private</span>:
<a name="l00646"></a>00646 
<a name="l00647"></a>00647    <span class="comment">//Configuration error: compare_hash&lt;&gt; can&#39;t be specified without store_hash&lt;&gt;</span>
<a name="l00648"></a>00648    <span class="comment">//See documentation for more explanations</span>
<a name="l00649"></a>00649    BOOST_STATIC_ASSERT((!<a class="code" href="structboost_1_1intrusive_1_1compare__hash.html">compare_hash</a> || <a class="code" href="structboost_1_1intrusive_1_1store__hash.html">store_hash</a>));
<a name="l00650"></a>00650 
<a name="l00651"></a>00651    <span class="keyword">typedef</span> <span class="keyword">typename</span> slist_impl::node_ptr                             slist_node_ptr;
<a name="l00652"></a>00652    <span class="keyword">typedef</span> <span class="keyword">typename</span> boost::pointer_to_other
<a name="l00653"></a>00653          &lt;slist_node_ptr, <span class="keywordtype">void</span>&gt;::type                                <a class="code" href="structboost_1_1intrusive_1_1void__pointer.html">void_pointer</a>;
<a name="l00654"></a>00654    <span class="comment">//We&#39;ll define group traits, but these won&#39;t be instantiated if</span>
<a name="l00655"></a>00655    <span class="comment">//optimize_multikey is not true</span>
<a name="l00656"></a>00656    <span class="keyword">typedef</span> unordered_group_adapter&lt;node_traits&gt;                      group_traits;
<a name="l00657"></a>00657    <span class="keyword">typedef</span> <a class="code" href="classboost_1_1intrusive_1_1circular__slist__algorithms.html">circular_slist_algorithms&lt;group_traits&gt;</a>                   group_algorithms;
<a name="l00658"></a>00658    <span class="keyword">typedef</span> <a class="code" href="structboost_1_1intrusive_1_1detail_1_1bool__.html">detail::bool_&lt;store_hash&gt;</a>                                 store_hash_t;
<a name="l00659"></a>00659    <span class="keyword">typedef</span> <a class="code" href="structboost_1_1intrusive_1_1detail_1_1bool__.html">detail::bool_&lt;optimize_multikey&gt;</a>                          optimize_multikey_t;
<a name="l00660"></a>00660    <span class="keyword">typedef</span> <a class="code" href="structboost_1_1intrusive_1_1detail_1_1bool__.html">detail::bool_&lt;cache_begin&gt;</a>                                cache_begin_t;
<a name="l00661"></a>00661    <span class="keyword">typedef</span> <a class="code" href="structboost_1_1intrusive_1_1detail_1_1bool__.html">detail::bool_&lt;power_2_buckets&gt;</a>                            power_2_buckets_t;
<a name="l00662"></a>00662    <span class="keyword">typedef</span> <a class="code" href="structboost_1_1intrusive_1_1detail_1_1size__holder.html">detail::size_holder&lt;constant_time_size, size_type&gt;</a>        size_traits;
<a name="l00663"></a>00663    <span class="keyword">typedef</span> <a class="code" href="structboost_1_1intrusive_1_1detail_1_1size__holder.html">detail::size_holder&lt;incremental, size_type&gt;</a>               split_traits;
<a name="l00664"></a>00664    <span class="keyword">typedef</span> detail::group_functions&lt;node_traits&gt;                      group_functions_t;
<a name="l00665"></a>00665 
<a name="l00666"></a>00666    <span class="keyword">static</span> <span class="keyword">const</span> std::size_t hashtable_data_bool_flags_mask  =
<a name="l00667"></a>00667       ( detail::hash_bool_flags::cache_begin_pos
<a name="l00668"></a>00668       | detail::hash_bool_flags::constant_time_size_pos
<a name="l00669"></a>00669       | detail::hash_bool_flags::incremental_pos
<a name="l00670"></a>00670       );
<a name="l00671"></a>00671    <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::usetopt_mask
<a name="l00672"></a>00672       &lt;Config, hashtable_data_bool_flags_mask&gt;::type masked_config_t;
<a name="l00673"></a>00673    detail::hashtable_data_t&lt;masked_config_t&gt;   data_;
<a name="l00674"></a>00674 
<a name="l00675"></a>00675    <span class="keyword">template</span>&lt;<span class="keywordtype">bool</span> IsConst&gt;
<a name="l00676"></a>00676    <span class="keyword">struct </span>downcast_node_to_value
<a name="l00677"></a>00677       :  <span class="keyword">public</span> detail::node_to_value&lt;hashtable_impl, IsConst&gt;
<a name="l00678"></a>00678    {
<a name="l00679"></a>00679       <span class="keyword">typedef</span> <a class="code" href="structboost_1_1intrusive_1_1detail_1_1node__to__value.html">detail::node_to_value&lt;hashtable_impl, IsConst&gt;</a> base_t;
<a name="l00680"></a>00680       <span class="keyword">typedef</span> <span class="keyword">typename</span> base_t::result_type               result_type;
<a name="l00681"></a>00681       <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structboost_1_1intrusive_1_1detail_1_1add__const__if__c.html">detail::add_const_if_c</a>
<a name="l00682"></a>00682             &lt;<span class="keyword">typename</span> slist_impl::node, IsConst&gt;::type  &amp;first_argument_type;
<a name="l00683"></a>00683       <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structboost_1_1intrusive_1_1detail_1_1add__const__if__c.html">detail::add_const_if_c</a>
<a name="l00684"></a>00684             &lt;node, IsConst&gt;::type                       &amp;intermediate_argument_type;
<a name="l00685"></a>00685 
<a name="l00686"></a>00686       downcast_node_to_value(<span class="keyword">const</span> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html">hashtable_impl</a> *cont)
<a name="l00687"></a>00687          :  base_t(cont)
<a name="l00688"></a>00688       {}
<a name="l00689"></a>00689 
<a name="l00690"></a>00690       result_type operator()(first_argument_type arg)<span class="keyword"> const</span>
<a name="l00691"></a>00691 <span class="keyword">      </span>{  <span class="keywordflow">return</span> this-&gt;base_t::operator()(static_cast&lt;intermediate_argument_type&gt;(arg)); }
<a name="l00692"></a>00692    };
<a name="l00693"></a>00693 
<a name="l00694"></a>00694    <span class="keyword">template</span>&lt;<span class="keyword">class</span> F&gt;
<a name="l00695"></a>00695    <span class="keyword">struct </span>node_cast_adaptor
<a name="l00696"></a>00696       :  <span class="keyword">private</span> detail::ebo_functor_holder&lt;F&gt;
<a name="l00697"></a>00697    {
<a name="l00698"></a>00698       <span class="keyword">typedef</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1ebo__functor__holder.html">detail::ebo_functor_holder&lt;F&gt;</a> base_t;
<a name="l00699"></a>00699 
<a name="l00700"></a>00700       <span class="keyword">template</span>&lt;<span class="keyword">class</span> ConvertibleToF&gt;
<a name="l00701"></a>00701       node_cast_adaptor(<span class="keyword">const</span> ConvertibleToF &amp;c2f, <span class="keyword">const</span> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html">hashtable_impl</a> *cont)
<a name="l00702"></a>00702          :  base_t(base_t(c2f, cont))
<a name="l00703"></a>00703       {}
<a name="l00704"></a>00704       
<a name="l00705"></a>00705       <span class="keyword">typename</span> base_t::node_ptr operator()(<span class="keyword">const</span> <span class="keyword">typename</span> slist_impl::node &amp;to_clone)
<a name="l00706"></a>00706       {  <span class="keywordflow">return</span> base_t::operator()(static_cast&lt;const node &amp;&gt;(to_clone));   }
<a name="l00707"></a>00707 
<a name="l00708"></a>00708       <span class="keywordtype">void</span> operator()(<span class="keyword">typename</span> slist_impl::node_ptr to_clone)
<a name="l00709"></a>00709       {  base_t::operator()(node_ptr(&amp;static_cast&lt;node &amp;&gt;(*to_clone)));   }
<a name="l00710"></a>00710    };
<a name="l00711"></a>00711 
<a name="l00712"></a>00712    <span class="keyword">private</span>:
<a name="l00713"></a>00713    <span class="comment">//noncopyable</span>
<a name="l00714"></a>00714    <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a5f699f562acc743153b66b4020f788f0">hashtable_impl</a> (<span class="keyword">const</span> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html">hashtable_impl</a>&amp;);
<a name="l00715"></a>00715    <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html">hashtable_impl</a> operator =(<span class="keyword">const</span> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html">hashtable_impl</a>&amp;);
<a name="l00716"></a>00716 
<a name="l00717"></a>00717    <span class="keyword">enum</span> { safemode_or_autounlink  = 
<a name="l00718"></a>00718             (int)real_value_traits::link_mode == (<span class="keywordtype">int</span>)auto_unlink   ||
<a name="l00719"></a>00719             (int)real_value_traits::link_mode == (<span class="keywordtype">int</span>)safe_link     };
<a name="l00720"></a>00720 
<a name="l00721"></a>00721    <span class="comment">//Constant-time size is incompatible with auto-unlink hooks!</span>
<a name="l00722"></a>00722    BOOST_STATIC_ASSERT(!(<a class="code" href="structboost_1_1intrusive_1_1constant__time__size.html">constant_time_size</a> &amp;&amp; ((<span class="keywordtype">int</span>)real_value_traits::link_mode == (<span class="keywordtype">int</span>)auto_unlink)));
<a name="l00723"></a>00723    <span class="comment">//Cache begin is incompatible with auto-unlink hooks!</span>
<a name="l00724"></a>00724    BOOST_STATIC_ASSERT(!(<a class="code" href="structboost_1_1intrusive_1_1cache__begin.html">cache_begin</a> &amp;&amp; ((<span class="keywordtype">int</span>)real_value_traits::link_mode == (<span class="keywordtype">int</span>)auto_unlink)));
<a name="l00725"></a>00725 
<a name="l00726"></a>00726    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Disposer&gt;
<a name="l00727"></a>00727    node_cast_adaptor&lt;detail::node_disposer&lt;Disposer, hashtable_impl&gt; &gt;
<a name="l00728"></a>00728       make_node_disposer(<span class="keyword">const</span> Disposer &amp;disposer)<span class="keyword"> const</span>
<a name="l00729"></a>00729 <span class="keyword">   </span>{  <span class="keywordflow">return</span> node_cast_adaptor&lt;detail::node_disposer&lt;Disposer, hashtable_impl&gt; &gt;(disposer, <span class="keyword">this</span>);   }
<a name="l00730"></a>00730 
<a name="l00732"></a>00732 
<a name="l00733"></a>00733    <span class="keyword">public</span>:
<a name="l00734"></a>00734    <span class="keyword">typedef</span> detail::insert_commit_data_impl insert_commit_data;
<a name="l00735"></a>00735 
<a name="l00736"></a>00736    <span class="keyword">typedef</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1transform__iterator.html">detail::transform_iterator</a>
<a name="l00737"></a>00737       &lt; <span class="keyword">typename</span> <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">slist_impl::iterator</a>
<a name="l00738"></a>00738       , downcast_node_to_value&lt;false&gt; &gt;                              <a class="code" href="classboost_1_1intrusive_1_1detail_1_1transform__iterator.html">local_iterator</a>;
<a name="l00739"></a>00739 
<a name="l00740"></a>00740    <span class="keyword">typedef</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1transform__iterator.html">detail::transform_iterator</a>
<a name="l00741"></a>00741       &lt; <span class="keyword">typename</span> <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">slist_impl::iterator</a>
<a name="l00742"></a>00742       , downcast_node_to_value&lt;true&gt; &gt;                               <a class="code" href="classboost_1_1intrusive_1_1detail_1_1transform__iterator.html">const_local_iterator</a>;
<a name="l00743"></a>00743 
<a name="l00745"></a>00745 
<a name="l00746"></a>00746    <span class="keyword">const</span> real_value_traits &amp;get_real_value_traits(<a class="code" href="structboost_1_1intrusive_1_1detail_1_1bool__.html">detail::bool_&lt;false&gt;</a>)<span class="keyword"> const</span>
<a name="l00747"></a>00747 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;data_;  }
<a name="l00748"></a>00748 
<a name="l00749"></a>00749    <span class="keyword">const</span> real_value_traits &amp;get_real_value_traits(<a class="code" href="structboost_1_1intrusive_1_1detail_1_1bool__.html">detail::bool_&lt;true&gt;</a>)<span class="keyword"> const</span>
<a name="l00750"></a>00750 <span class="keyword">   </span>{  <span class="keywordflow">return</span> data_.get_value_traits(*<span class="keyword">this</span>);  }
<a name="l00751"></a>00751 
<a name="l00752"></a>00752    real_value_traits &amp;get_real_value_traits(<a class="code" href="structboost_1_1intrusive_1_1detail_1_1bool__.html">detail::bool_&lt;false&gt;</a>)
<a name="l00753"></a>00753    {  <span class="keywordflow">return</span> this-&gt;data_;  }
<a name="l00754"></a>00754 
<a name="l00755"></a>00755    real_value_traits &amp;get_real_value_traits(<a class="code" href="structboost_1_1intrusive_1_1detail_1_1bool__.html">detail::bool_&lt;true&gt;</a>)
<a name="l00756"></a>00756    {  <span class="keywordflow">return</span> data_.get_value_traits(*<span class="keyword">this</span>);  }
<a name="l00757"></a>00757 
<a name="l00759"></a>00759 
<a name="l00760"></a>00760    <span class="keyword">public</span>:
<a name="l00761"></a>00761 
<a name="l00762"></a>00762    <span class="keyword">const</span> real_value_traits &amp;get_real_value_traits()<span class="keyword"> const</span>
<a name="l00763"></a>00763 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;get_real_value_traits(<a class="code" href="structboost_1_1intrusive_1_1detail_1_1bool__.html">detail::bool_&lt;external_value_traits&gt;</a>());  }
<a name="l00764"></a>00764 
<a name="l00765"></a>00765    real_value_traits &amp;get_real_value_traits()
<a name="l00766"></a>00766    {  <span class="keywordflow">return</span> this-&gt;get_real_value_traits(<a class="code" href="structboost_1_1intrusive_1_1detail_1_1bool__.html">detail::bool_&lt;external_value_traits&gt;</a>());  }
<a name="l00767"></a>00767 
<a name="l00781"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a5f699f562acc743153b66b4020f788f0">00781</a>    <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a5f699f562acc743153b66b4020f788f0">hashtable_impl</a> ( <span class="keyword">const</span> <a class="code" href="structboost_1_1intrusive_1_1bucket__traits.html">bucket_traits</a> &amp;b_traits
<a name="l00782"></a>00782                   , <span class="keyword">const</span> hasher &amp; hash_func = hasher()
<a name="l00783"></a>00783                   , <span class="keyword">const</span> key_equal &amp;equal_func = key_equal()
<a name="l00784"></a>00784                   , <span class="keyword">const</span> value_traits &amp;v_traits = value_traits()) 
<a name="l00785"></a>00785       :  data_(b_traits, hash_func, equal_func, v_traits)
<a name="l00786"></a>00786    {
<a name="l00787"></a>00787       priv_initialize_buckets();
<a name="l00788"></a>00788       this-&gt;priv_size_traits().set_size(size_type(0));
<a name="l00789"></a>00789       size_type <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a251215bbd295ee729e752196cdb65476">bucket_size</a> = this-&gt;priv_buckets_len();
<a name="l00790"></a>00790       BOOST_INTRUSIVE_INVARIANT_ASSERT(bucket_size != 0);
<a name="l00791"></a>00791       <span class="comment">//Check power of two bucket array if the option is activated</span>
<a name="l00792"></a>00792       BOOST_INTRUSIVE_INVARIANT_ASSERT
<a name="l00793"></a>00793          (!<a class="code" href="structboost_1_1intrusive_1_1power__2__buckets.html">power_2_buckets</a> || (0 == (bucket_size &amp; (bucket_size-1))));
<a name="l00794"></a>00794       priv_split_traits().set_size(bucket_size&gt;&gt;1);
<a name="l00795"></a>00795    }
<a name="l00796"></a>00796 
<a name="l00804"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a0ece1769fc3f4b96eed19c3477849a06">00804</a>    <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a0ece1769fc3f4b96eed19c3477849a06">~hashtable_impl</a>() 
<a name="l00805"></a>00805    {}
<a name="l00806"></a>00806 
<a name="l00813"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#ab5d772f059e3232e024dcff5af61f9e2">00813</a>    <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#ab5d772f059e3232e024dcff5af61f9e2">begin</a>()
<a name="l00814"></a>00814    {  <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">iterator</a>(this-&gt;priv_begin(), <span class="keyword">this</span>);   }
<a name="l00815"></a>00815 
<a name="l00823"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#afa4ae9add5b728e138e80c661cf59586">00823</a>    <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">const_iterator</a> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#ab5d772f059e3232e024dcff5af61f9e2">begin</a>()<span class="keyword"> const</span>
<a name="l00824"></a>00824 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#afc1c7507cc01bf686393028c92201def">cbegin</a>();  }
<a name="l00825"></a>00825 
<a name="l00833"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#afc1c7507cc01bf686393028c92201def">00833</a>    <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">const_iterator</a> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#afc1c7507cc01bf686393028c92201def">cbegin</a>()<span class="keyword"> const</span>
<a name="l00834"></a>00834 <span class="keyword">   </span>{  <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">const_iterator</a>(this-&gt;priv_begin(), <span class="keyword">this</span>);   }
<a name="l00835"></a>00835 
<a name="l00841"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a3bb26f838e8c85730ae98204134fd813">00841</a>    <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a3bb26f838e8c85730ae98204134fd813">end</a>()
<a name="l00842"></a>00842    {  <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">iterator</a>(priv_invalid_local_it(), 0);   }
<a name="l00843"></a>00843 
<a name="l00849"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#abb29a29d7bd1168b6e4c33b5d7824f24">00849</a>    <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">const_iterator</a> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a3bb26f838e8c85730ae98204134fd813">end</a>()<span class="keyword"> const</span>
<a name="l00850"></a>00850 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a5b50e47a307986f2011f5090a7fd6c15">cend</a>(); }
<a name="l00851"></a>00851 
<a name="l00857"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a5b50e47a307986f2011f5090a7fd6c15">00857</a>    <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">const_iterator</a> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a5b50e47a307986f2011f5090a7fd6c15">cend</a>()<span class="keyword"> const</span>
<a name="l00858"></a>00858 <span class="keyword">   </span>{  <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">const_iterator</a>(priv_invalid_local_it(), 0);  }
<a name="l00859"></a>00859 
<a name="l00865"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a9bfaabc9b2fd965e1dd56349dfb7cc43">00865</a>    hasher <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a9bfaabc9b2fd965e1dd56349dfb7cc43">hash_function</a>()<span class="keyword"> const</span>
<a name="l00866"></a>00866 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;priv_hasher();  }
<a name="l00867"></a>00867 
<a name="l00873"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a2fca9d4d7688fac884fda2c574f7d67a">00873</a>    key_equal <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a2fca9d4d7688fac884fda2c574f7d67a">key_eq</a>()<span class="keyword"> const</span>
<a name="l00874"></a>00874 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;priv_equal();   }
<a name="l00875"></a>00875 
<a name="l00883"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a70e71ceca07382bd97a45e1d1a1b3b4b">00883</a>    <span class="keywordtype">bool</span> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a70e71ceca07382bd97a45e1d1a1b3b4b">empty</a>()<span class="keyword"> const</span>
<a name="l00884"></a>00884 <span class="keyword">   </span>{
<a name="l00885"></a>00885       <span class="keywordflow">if</span>(<a class="code" href="structboost_1_1intrusive_1_1constant__time__size.html">constant_time_size</a>){
<a name="l00886"></a>00886          <span class="keywordflow">return</span> !this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#ac6a1412a8d4768b3dc4428b6378a56a3">size</a>();
<a name="l00887"></a>00887       }
<a name="l00888"></a>00888       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="structboost_1_1intrusive_1_1cache__begin.html">cache_begin</a>){
<a name="l00889"></a>00889          <span class="keywordflow">return</span> this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#ab5d772f059e3232e024dcff5af61f9e2">begin</a>() == this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a3bb26f838e8c85730ae98204134fd813">end</a>();
<a name="l00890"></a>00890       }
<a name="l00891"></a>00891       <span class="keywordflow">else</span>{
<a name="l00892"></a>00892          size_type buckets_len = this-&gt;priv_buckets_len();
<a name="l00893"></a>00893          <span class="keyword">const</span> <a class="code" href="structboost_1_1intrusive_1_1detail_1_1bucket__impl.html">bucket_type</a> *b = detail::boost_intrusive_get_pointer(this-&gt;priv_buckets());
<a name="l00894"></a>00894          <span class="keywordflow">for</span> (size_type n = 0; n &lt; buckets_len; ++n, ++b){
<a name="l00895"></a>00895             <span class="keywordflow">if</span>(!b-&gt;empty()){
<a name="l00896"></a>00896                <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00897"></a>00897             }
<a name="l00898"></a>00898          }
<a name="l00899"></a>00899          <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00900"></a>00900       }
<a name="l00901"></a>00901    }
<a name="l00902"></a>00902 
<a name="l00909"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#ac6a1412a8d4768b3dc4428b6378a56a3">00909</a>    size_type <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#ac6a1412a8d4768b3dc4428b6378a56a3">size</a>()<span class="keyword"> const</span>
<a name="l00910"></a>00910 <span class="keyword">   </span>{
<a name="l00911"></a>00911       <span class="keywordflow">if</span>(<a class="code" href="structboost_1_1intrusive_1_1constant__time__size.html">constant_time_size</a>)
<a name="l00912"></a>00912          <span class="keywordflow">return</span> this-&gt;priv_size_traits().get_size();
<a name="l00913"></a>00913       <span class="keywordflow">else</span>{
<a name="l00914"></a>00914          size_type len = 0;
<a name="l00915"></a>00915          size_type buckets_len = this-&gt;priv_buckets_len();
<a name="l00916"></a>00916          <span class="keyword">const</span> <a class="code" href="structboost_1_1intrusive_1_1detail_1_1bucket__impl.html">bucket_type</a> *b = detail::boost_intrusive_get_pointer(this-&gt;priv_buckets());
<a name="l00917"></a>00917          <span class="keywordflow">for</span> (size_type n = 0; n &lt; buckets_len; ++n, ++b){
<a name="l00918"></a>00918             len += b-&gt;size();
<a name="l00919"></a>00919          }
<a name="l00920"></a>00920          <span class="keywordflow">return</span> len;
<a name="l00921"></a>00921       }
<a name="l00922"></a>00922    }
<a name="l00923"></a>00923 
<a name="l00934"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a409d6dc57547168d08264128e9d85d74">00934</a>    <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a409d6dc57547168d08264128e9d85d74">swap</a>(<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html">hashtable_impl</a>&amp; other)
<a name="l00935"></a>00935    {
<a name="l00936"></a>00936       <span class="keyword">using</span> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a409d6dc57547168d08264128e9d85d74">std::swap</a>;
<a name="l00937"></a>00937       <span class="comment">//These can throw</span>
<a name="l00938"></a>00938       <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a409d6dc57547168d08264128e9d85d74">swap</a>(this-&gt;priv_equal(), other.priv_equal());
<a name="l00939"></a>00939       <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a409d6dc57547168d08264128e9d85d74">swap</a>(this-&gt;priv_hasher(), other.priv_hasher());
<a name="l00940"></a>00940       <span class="comment">//These can&#39;t throw</span>
<a name="l00941"></a>00941       <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a409d6dc57547168d08264128e9d85d74">swap</a>(this-&gt;priv_real_bucket_traits(), other.priv_real_bucket_traits());
<a name="l00942"></a>00942       priv_swap_cache(cache_begin_t(), other);
<a name="l00943"></a>00943       <span class="keywordflow">if</span>(<a class="code" href="structboost_1_1intrusive_1_1constant__time__size.html">constant_time_size</a>){
<a name="l00944"></a>00944          size_type backup = this-&gt;priv_size_traits().get_size();
<a name="l00945"></a>00945          this-&gt;priv_size_traits().set_size(other.priv_size_traits().get_size());
<a name="l00946"></a>00946          other.priv_size_traits().set_size(backup);
<a name="l00947"></a>00947       }
<a name="l00948"></a>00948       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="structboost_1_1intrusive_1_1incremental.html">incremental</a>){
<a name="l00949"></a>00949          size_type backup = this-&gt;priv_split_traits().get_size();
<a name="l00950"></a>00950          this-&gt;priv_split_traits().set_size(other.priv_split_traits().get_size());
<a name="l00951"></a>00951          other.priv_split_traits().set_size(backup);
<a name="l00952"></a>00952       }
<a name="l00953"></a>00953    }
<a name="l00954"></a>00954 
<a name="l00974"></a>00974    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Cloner, <span class="keyword">class</span> Disposer&gt;
<a name="l00975"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#adf3c7c47a20f5ed115214226e68e8dc1">00975</a>    <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#adf3c7c47a20f5ed115214226e68e8dc1">clone_from</a>(<span class="keyword">const</span> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html">hashtable_impl</a> &amp;src, Cloner cloner, Disposer disposer)
<a name="l00976"></a>00976    {
<a name="l00977"></a>00977       this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a6f8ada5bf39c7de871e164bf7c0d26ec">clear_and_dispose</a>(disposer);
<a name="l00978"></a>00978       <span class="keywordflow">if</span>(!<a class="code" href="structboost_1_1intrusive_1_1constant__time__size.html">constant_time_size</a> || !src.<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a70e71ceca07382bd97a45e1d1a1b3b4b">empty</a>()){
<a name="l00979"></a>00979          <span class="keyword">const</span> size_type src_bucket_count = src.<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a11750786436937da5e72352d0dbfcbb7">bucket_count</a>();
<a name="l00980"></a>00980          <span class="keyword">const</span> size_type dst_bucket_count = this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a11750786436937da5e72352d0dbfcbb7">bucket_count</a>();
<a name="l00981"></a>00981          <span class="comment">//Check power of two bucket array if the option is activated</span>
<a name="l00982"></a>00982          BOOST_INTRUSIVE_INVARIANT_ASSERT
<a name="l00983"></a>00983          (!<a class="code" href="structboost_1_1intrusive_1_1power__2__buckets.html">power_2_buckets</a> || (0 == (src_bucket_count &amp; (src_bucket_count-1))));
<a name="l00984"></a>00984          BOOST_INTRUSIVE_INVARIANT_ASSERT
<a name="l00985"></a>00985          (!<a class="code" href="structboost_1_1intrusive_1_1power__2__buckets.html">power_2_buckets</a> || (0 == (dst_bucket_count &amp; (dst_bucket_count-1))));
<a name="l00986"></a>00986 
<a name="l00987"></a>00987          <span class="comment">//If src bucket count is bigger or equal, structural copy is possible</span>
<a name="l00988"></a>00988          <span class="keywordflow">if</span>(!<a class="code" href="structboost_1_1intrusive_1_1incremental.html">incremental</a> &amp;&amp; (src_bucket_count &gt;= dst_bucket_count)){
<a name="l00989"></a>00989             <span class="comment">//First clone the first ones</span>
<a name="l00990"></a>00990             <span class="keyword">const</span> bucket_ptr src_buckets = src.priv_buckets();
<a name="l00991"></a>00991             <span class="keyword">const</span> bucket_ptr dst_buckets = this-&gt;priv_buckets();
<a name="l00992"></a>00992             size_type constructed;
<a name="l00993"></a>00993             <span class="keyword">typedef</span> node_cast_adaptor&lt;detail::node_disposer&lt;Disposer, hashtable_impl&gt; &gt; NodeDisposer;
<a name="l00994"></a>00994             <span class="keyword">typedef</span> node_cast_adaptor&lt;detail::node_cloner&lt;Cloner, hashtable_impl&gt; &gt; NodeCloner;
<a name="l00995"></a>00995             NodeDisposer node_disp(disposer, <span class="keyword">this</span>);
<a name="l00996"></a>00996    
<a name="l00997"></a>00997             <a class="code" href="classboost_1_1intrusive_1_1detail_1_1exception__array__disposer.html">detail::exception_array_disposer&lt;bucket_type, NodeDisposer&gt;</a>
<a name="l00998"></a>00998                rollback(dst_buckets[0], node_disp, constructed);
<a name="l00999"></a>00999             <span class="keywordflow">for</span>( constructed = 0
<a name="l01000"></a>01000                ; constructed &lt; dst_bucket_count
<a name="l01001"></a>01001                ; ++constructed){
<a name="l01002"></a>01002                dst_buckets[constructed].clone_from
<a name="l01003"></a>01003                   ( src_buckets[constructed]
<a name="l01004"></a>01004                   , NodeCloner(cloner, <span class="keyword">this</span>), node_disp);
<a name="l01005"></a>01005             }
<a name="l01006"></a>01006             <span class="keywordflow">if</span>(src_bucket_count != dst_bucket_count){
<a name="l01007"></a>01007                <span class="comment">//Now insert the remaining ones using the modulo trick</span>
<a name="l01008"></a>01008                <span class="keywordflow">for</span>(<span class="comment">//&quot;constructed&quot; comes from the previous loop</span>
<a name="l01009"></a>01009                   ; constructed &lt; src_bucket_count
<a name="l01010"></a>01010                   ; ++constructed){
<a name="l01011"></a>01011                   <a class="code" href="structboost_1_1intrusive_1_1detail_1_1bucket__impl.html">bucket_type</a> &amp;dst_b =
<a name="l01012"></a>01012                      dst_buckets[priv_hash_to_bucket(constructed, dst_bucket_count, dst_bucket_count)];
<a name="l01013"></a>01013                   <a class="code" href="structboost_1_1intrusive_1_1detail_1_1bucket__impl.html">bucket_type</a> &amp;src_b = src_buckets[constructed];
<a name="l01014"></a>01014                   <span class="keywordflow">for</span>( <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> b(src_b.begin()), e(src_b.end())
<a name="l01015"></a>01015                      ; b != e
<a name="l01016"></a>01016                      ; ++b){
<a name="l01017"></a>01017                      dst_b.push_front(*(NodeCloner(cloner, <span class="keyword">this</span>)(*b.pointed_node())));
<a name="l01018"></a>01018                   }
<a name="l01019"></a>01019                }
<a name="l01020"></a>01020             }
<a name="l01021"></a>01021             this-&gt;priv_hasher() = src.priv_hasher();
<a name="l01022"></a>01022             this-&gt;priv_equal()  = src.priv_equal();
<a name="l01023"></a>01023             rollback.release();
<a name="l01024"></a>01024             this-&gt;priv_size_traits().set_size(src.priv_size_traits().get_size());
<a name="l01025"></a>01025             this-&gt;priv_split_traits().set_size(dst_bucket_count);
<a name="l01026"></a>01026             priv_insertion_update_cache(0u);
<a name="l01027"></a>01027             priv_erasure_update_cache();
<a name="l01028"></a>01028          }
<a name="l01029"></a>01029          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="structboost_1_1intrusive_1_1store__hash.html">store_hash</a>){
<a name="l01030"></a>01030             <span class="comment">//Unlike previous cloning algorithm, this can throw</span>
<a name="l01031"></a>01031             <span class="comment">//if cloner, hasher or comparison functor throw</span>
<a name="l01032"></a>01032             <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">const_iterator</a> b(src.<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#ab5d772f059e3232e024dcff5af61f9e2">begin</a>()), e(src.<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a3bb26f838e8c85730ae98204134fd813">end</a>());
<a name="l01033"></a>01033             <a class="code" href="classboost_1_1intrusive_1_1detail_1_1exception__disposer.html">detail::exception_disposer&lt;hashtable_impl, Disposer&gt;</a>
<a name="l01034"></a>01034                rollback(*<span class="keyword">this</span>, disposer);
<a name="l01035"></a>01035             <span class="keywordflow">for</span>(; b != e; ++b){
<a name="l01036"></a>01036                std::size_t hash_value = this-&gt;priv_stored_or_compute_hash(*b, store_hash_t());;
<a name="l01037"></a>01037                this-&gt;priv_insert_equal_with_hash(*cloner(*b), hash_value);
<a name="l01038"></a>01038             }
<a name="l01039"></a>01039             rollback.release();
<a name="l01040"></a>01040          }
<a name="l01041"></a>01041          <span class="keywordflow">else</span>{
<a name="l01042"></a>01042             <span class="comment">//Unlike previous cloning algorithm, this can throw</span>
<a name="l01043"></a>01043             <span class="comment">//if cloner, hasher or comparison functor throw</span>
<a name="l01044"></a>01044             <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">const_iterator</a> b(src.<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#ab5d772f059e3232e024dcff5af61f9e2">begin</a>()), e(src.<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a3bb26f838e8c85730ae98204134fd813">end</a>());
<a name="l01045"></a>01045             <a class="code" href="classboost_1_1intrusive_1_1detail_1_1exception__disposer.html">detail::exception_disposer&lt;hashtable_impl, Disposer&gt;</a>
<a name="l01046"></a>01046                rollback(*<span class="keyword">this</span>, disposer);
<a name="l01047"></a>01047             <span class="keywordflow">for</span>(; b != e; ++b){
<a name="l01048"></a>01048                this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a8ae16eefe2bca717f72df62bbfa72eec">insert_equal</a>(*cloner(*b));
<a name="l01049"></a>01049             }
<a name="l01050"></a>01050             rollback.release();
<a name="l01051"></a>01051          }
<a name="l01052"></a>01052       }
<a name="l01053"></a>01053    }
<a name="l01054"></a>01054 
<a name="l01067"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a8ae16eefe2bca717f72df62bbfa72eec">01067</a>    <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a8ae16eefe2bca717f72df62bbfa72eec">insert_equal</a>(reference value)
<a name="l01068"></a>01068    {
<a name="l01069"></a>01069       size_type bucket_num;
<a name="l01070"></a>01070       std::size_t hash_value;
<a name="l01071"></a>01071       <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> prev;
<a name="l01072"></a>01072       <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> it = this-&gt;priv_find
<a name="l01073"></a>01073          (value, this-&gt;priv_hasher(), this-&gt;priv_equal(), bucket_num, hash_value, prev);
<a name="l01074"></a>01074       <span class="keywordflow">return</span> priv_insert_equal_find(value, bucket_num, hash_value, it);
<a name="l01075"></a>01075    }
<a name="l01076"></a>01076 
<a name="l01089"></a>01089    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;
<a name="l01090"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a892f676a9266f9e676e57231b32abc4c">01090</a>    <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a8ae16eefe2bca717f72df62bbfa72eec">insert_equal</a>(Iterator b, Iterator e)
<a name="l01091"></a>01091    {
<a name="l01092"></a>01092       <span class="keywordflow">for</span> (; b != e; ++b)
<a name="l01093"></a>01093          this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a8ae16eefe2bca717f72df62bbfa72eec">insert_equal</a>(*b);
<a name="l01094"></a>01094    }
<a name="l01095"></a>01095 
<a name="l01112"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a8a761552b51e89fb9174eaaa517fb43c">01112</a>    std::pair&lt;iterator, bool&gt; <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a8a761552b51e89fb9174eaaa517fb43c">insert_unique</a>(reference value)
<a name="l01113"></a>01113    {
<a name="l01114"></a>01114       insert_commit_data commit_data;
<a name="l01115"></a>01115       std::pair&lt;iterator, bool&gt; ret = this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a84c3d1be2cf60bcd2c1c3f2c10bd6dfb">insert_unique_check</a>
<a name="l01116"></a>01116          (value, this-&gt;priv_hasher(), this-&gt;priv_equal(), commit_data);
<a name="l01117"></a>01117       <span class="keywordflow">if</span>(!ret.second)
<a name="l01118"></a>01118          <span class="keywordflow">return</span> ret;
<a name="l01119"></a>01119       <span class="keywordflow">return</span> std::pair&lt;iterator, bool&gt; 
<a name="l01120"></a>01120          (this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a9e33685e5b7c448939323109241ea56f">insert_unique_commit</a>(value, commit_data), <span class="keyword">true</span>);
<a name="l01121"></a>01121    }
<a name="l01122"></a>01122 
<a name="l01135"></a>01135    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Iterator&gt;
<a name="l01136"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a0af93c0fc618cc047ae9a9b843d1bfe8">01136</a>    <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a8a761552b51e89fb9174eaaa517fb43c">insert_unique</a>(Iterator b, Iterator e)
<a name="l01137"></a>01137    {
<a name="l01138"></a>01138       <span class="keywordflow">for</span> (; b != e; ++b)
<a name="l01139"></a>01139          this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a8a761552b51e89fb9174eaaa517fb43c">insert_unique</a>(*b);
<a name="l01140"></a>01140    }
<a name="l01141"></a>01141 
<a name="l01177"></a>01177    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyHasher, <span class="keyword">class</span> KeyValueEqual&gt;
<a name="l01178"></a>01178    std::pair&lt;iterator, bool&gt; <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a84c3d1be2cf60bcd2c1c3f2c10bd6dfb">insert_unique_check</a>
<a name="l01179"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a84c3d1be2cf60bcd2c1c3f2c10bd6dfb">01179</a>       ( <span class="keyword">const</span> KeyType &amp;key
<a name="l01180"></a>01180       , KeyHasher hash_func
<a name="l01181"></a>01181       , KeyValueEqual equal_func
<a name="l01182"></a>01182       , insert_commit_data &amp;commit_data)
<a name="l01183"></a>01183    {
<a name="l01184"></a>01184       size_type bucket_num;
<a name="l01185"></a>01185       <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> prev;
<a name="l01186"></a>01186       <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> prev_pos =
<a name="l01187"></a>01187          this-&gt;priv_find(key, hash_func, equal_func, bucket_num, commit_data.hash, prev);
<a name="l01188"></a>01188       <span class="keywordtype">bool</span> success = prev_pos == priv_invalid_local_it();
<a name="l01189"></a>01189       <span class="keywordflow">if</span>(success){
<a name="l01190"></a>01190          prev_pos = prev;
<a name="l01191"></a>01191       }
<a name="l01192"></a>01192       <span class="keywordflow">return</span> std::pair&lt;iterator, bool&gt;(<a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">iterator</a>(prev_pos, <span class="keyword">this</span>),success);
<a name="l01193"></a>01193    }
<a name="l01194"></a>01194 
<a name="l01214"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a9e33685e5b7c448939323109241ea56f">01214</a>    <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a9e33685e5b7c448939323109241ea56f">insert_unique_commit</a>(reference value, <span class="keyword">const</span> insert_commit_data &amp;commit_data)
<a name="l01215"></a>01215    {
<a name="l01216"></a>01216       size_type bucket_num = priv_hash_to_bucket(commit_data.hash);
<a name="l01217"></a>01217       <a class="code" href="structboost_1_1intrusive_1_1detail_1_1bucket__impl.html">bucket_type</a> &amp;b = this-&gt;priv_buckets()[bucket_num];
<a name="l01218"></a>01218       this-&gt;priv_size_traits().increment();
<a name="l01219"></a>01219       node_ptr n = node_ptr(&amp;priv_value_to_node(value));
<a name="l01220"></a>01220       this-&gt;priv_store_hash(n, commit_data.hash, store_hash_t());
<a name="l01221"></a>01221       <span class="keywordflow">if</span>(safemode_or_autounlink)
<a name="l01222"></a>01222          BOOST_INTRUSIVE_SAFE_HOOK_DEFAULT_ASSERT(node_algorithms::unique(n));
<a name="l01223"></a>01223       priv_insertion_update_cache(bucket_num);
<a name="l01224"></a>01224       this-&gt;priv_insert_in_group(node_ptr(0), n, optimize_multikey_t());
<a name="l01225"></a>01225       <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">iterator</a>(b.insert_after(b.before_begin(), *n), <span class="keyword">this</span>);
<a name="l01226"></a>01226    }
<a name="l01227"></a>01227 
<a name="l01236"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#adcdba236d967350e0e0321cb07ef2364">01236</a>    <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#adcdba236d967350e0e0321cb07ef2364">erase</a>(<a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">const_iterator</a> i)
<a name="l01237"></a>01237    {  this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a3d6d5044b981d30f87459010a53d553a">erase_and_dispose</a>(i, <a class="code" href="classboost_1_1intrusive_1_1detail_1_1null__disposer.html">detail::null_disposer</a>());  }
<a name="l01238"></a>01238 
<a name="l01248"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a1d64df5ddd19ab6a381f2ce9603ce600">01248</a>    <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#adcdba236d967350e0e0321cb07ef2364">erase</a>(<a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">const_iterator</a> b, <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">const_iterator</a> e)
<a name="l01249"></a>01249    {  this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a3d6d5044b981d30f87459010a53d553a">erase_and_dispose</a>(b, e, <a class="code" href="classboost_1_1intrusive_1_1detail_1_1null__disposer.html">detail::null_disposer</a>());  }
<a name="l01250"></a>01250 
<a name="l01263"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a533d6187dffe16f2b23d21c9e3a8bfe5">01263</a>    size_type <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#adcdba236d967350e0e0321cb07ef2364">erase</a>(const_reference value)
<a name="l01264"></a>01264    {  <span class="keywordflow">return</span> this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a533d6187dffe16f2b23d21c9e3a8bfe5">erase</a>(value, this-&gt;priv_hasher(), this-&gt;priv_equal());  }
<a name="l01265"></a>01265 
<a name="l01286"></a>01286    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyHasher, <span class="keyword">class</span> KeyValueEqual&gt;
<a name="l01287"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a78ea6b45d50f374dbcc568dc5f3328dc">01287</a>    size_type <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#adcdba236d967350e0e0321cb07ef2364">erase</a>(<span class="keyword">const</span> KeyType&amp; key, KeyHasher hash_func, KeyValueEqual equal_func)
<a name="l01288"></a>01288    {  <span class="keywordflow">return</span> this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a3d6d5044b981d30f87459010a53d553a">erase_and_dispose</a>(key, hash_func, equal_func, <a class="code" href="classboost_1_1intrusive_1_1detail_1_1null__disposer.html">detail::null_disposer</a>()); }
<a name="l01289"></a>01289 
<a name="l01301"></a>01301    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Disposer&gt;
<a name="l01302"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a3d6d5044b981d30f87459010a53d553a">01302</a>    <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a3d6d5044b981d30f87459010a53d553a">erase_and_dispose</a>(<a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">const_iterator</a> i, Disposer disposer
<a name="l01304"></a>01304                               , <span class="keyword">typename</span> <a class="code" href="structboost_1_1intrusive_1_1detail_1_1enable__if__c.html">detail::enable_if_c</a>&lt;!<a class="code" href="classboost_1_1intrusive_1_1detail_1_1is__convertible.html">detail::is_convertible&lt;Disposer, const_iterator&gt;::value</a> &gt;::type * = 0
<a name="l01306"></a>01306                               )
<a name="l01307"></a>01307    {
<a name="l01308"></a>01308       priv_erase(i, disposer, optimize_multikey_t());
<a name="l01309"></a>01309       this-&gt;priv_size_traits().decrement();
<a name="l01310"></a>01310       priv_erasure_update_cache();
<a name="l01311"></a>01311    }
<a name="l01312"></a>01312 
<a name="l01325"></a>01325    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Disposer&gt;
<a name="l01326"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a9a65bc5e7206082f2d9545aade424d20">01326</a>    <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a3d6d5044b981d30f87459010a53d553a">erase_and_dispose</a>(<a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">const_iterator</a> b, <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">const_iterator</a> e, Disposer disposer)
<a name="l01327"></a>01327    {
<a name="l01328"></a>01328       <span class="keywordflow">if</span>(b != e){
<a name="l01329"></a>01329          <span class="comment">//Get the bucket number and local iterator for both iterators</span>
<a name="l01330"></a>01330          <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> first_local_it(b.slist_it());
<a name="l01331"></a>01331          size_type first_bucket_num = this-&gt;priv_get_bucket_num(first_local_it);
<a name="l01332"></a>01332 
<a name="l01333"></a>01333          <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> before_first_local_it
<a name="l01334"></a>01334             = priv_get_previous(priv_buckets()[first_bucket_num], first_local_it);
<a name="l01335"></a>01335          size_type last_bucket_num;
<a name="l01336"></a>01336          <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> last_local_it;
<a name="l01337"></a>01337 
<a name="l01338"></a>01338          <span class="comment">//For the end iterator, we will assign the end iterator</span>
<a name="l01339"></a>01339          <span class="comment">//of the last bucket</span>
<a name="l01340"></a>01340          <span class="keywordflow">if</span>(e == this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a3bb26f838e8c85730ae98204134fd813">end</a>()){
<a name="l01341"></a>01341             last_bucket_num   = this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a11750786436937da5e72352d0dbfcbb7">bucket_count</a>() - 1;
<a name="l01342"></a>01342             last_local_it     = priv_buckets()[last_bucket_num].end();
<a name="l01343"></a>01343          }
<a name="l01344"></a>01344          <span class="keywordflow">else</span>{
<a name="l01345"></a>01345             last_local_it     = e.slist_it();
<a name="l01346"></a>01346             last_bucket_num = this-&gt;priv_get_bucket_num(last_local_it);
<a name="l01347"></a>01347          }
<a name="l01348"></a>01348          priv_erase_range(before_first_local_it, first_bucket_num, last_local_it, last_bucket_num, disposer);
<a name="l01349"></a>01349          priv_erasure_update_cache(first_bucket_num, last_bucket_num);
<a name="l01350"></a>01350       }
<a name="l01351"></a>01351    }
<a name="l01352"></a>01352 
<a name="l01368"></a>01368    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Disposer&gt;
<a name="l01369"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a822717f77e536fb24735179f67cfa721">01369</a>    size_type <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a3d6d5044b981d30f87459010a53d553a">erase_and_dispose</a>(const_reference value, Disposer disposer)
<a name="l01370"></a>01370    {  <span class="keywordflow">return</span> this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a822717f77e536fb24735179f67cfa721">erase_and_dispose</a>(value, priv_hasher(), priv_equal(), disposer);   }
<a name="l01371"></a>01371 
<a name="l01387"></a>01387    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyHasher, <span class="keyword">class</span> KeyValueEqual, <span class="keyword">class</span> Disposer&gt;
<a name="l01388"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#aea02bea1b6648e78a2e567ce571a951d">01388</a>    size_type <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a3d6d5044b981d30f87459010a53d553a">erase_and_dispose</a>(<span class="keyword">const</span> KeyType&amp; key, KeyHasher hash_func
<a name="l01389"></a>01389                               ,KeyValueEqual equal_func, Disposer disposer)
<a name="l01390"></a>01390    {
<a name="l01391"></a>01391       size_type bucket_num;
<a name="l01392"></a>01392       std::size_t h;
<a name="l01393"></a>01393       <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> prev;
<a name="l01394"></a>01394       <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> it =
<a name="l01395"></a>01395          this-&gt;priv_find(key, hash_func, equal_func, bucket_num, h, prev);
<a name="l01396"></a>01396       <span class="keywordtype">bool</span> success = it != priv_invalid_local_it();
<a name="l01397"></a>01397       size_type <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a45a810b8add3071142d41cdb6e33e1dc">count</a>(0);
<a name="l01398"></a>01398       <span class="keywordflow">if</span>(!success){
<a name="l01399"></a>01399          <span class="keywordflow">return</span> 0;
<a name="l01400"></a>01400       }
<a name="l01401"></a>01401       <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="structboost_1_1intrusive_1_1optimize__multikey.html">optimize_multikey</a>){
<a name="l01402"></a>01402          <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> last = bucket_type::s_iterator_to
<a name="l01403"></a>01403             (*node_traits::get_next(group_functions_t::priv_get_last_in_group
<a name="l01404"></a>01404                (dcast_bucket_ptr(it.pointed_node()), optimize_multikey_t())));
<a name="l01405"></a>01405          this-&gt;priv_erase_range_impl(bucket_num, prev, last, disposer, count);
<a name="l01406"></a>01406       }
<a name="l01407"></a>01407       <span class="keywordflow">else</span>{
<a name="l01408"></a>01408          <span class="comment">//If found erase all equal values</span>
<a name="l01409"></a>01409          <a class="code" href="structboost_1_1intrusive_1_1detail_1_1bucket__impl.html">bucket_type</a> &amp;b = this-&gt;priv_buckets()[bucket_num];
<a name="l01410"></a>01410          <span class="keywordflow">for</span>(<a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a3bb26f838e8c85730ae98204134fd813">end</a> = b.end(); it != <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a3bb26f838e8c85730ae98204134fd813">end</a>; ++<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a45a810b8add3071142d41cdb6e33e1dc">count</a>, ++it){
<a name="l01411"></a>01411             slist_node_ptr n(it.pointed_node());
<a name="l01412"></a>01412             <span class="keyword">const</span> value_type &amp;v = priv_value_from_slist_node(n);
<a name="l01413"></a>01413             <span class="keywordflow">if</span>(<a class="code" href="structboost_1_1intrusive_1_1compare__hash.html">compare_hash</a>){
<a name="l01414"></a>01414                std::size_t vh = this-&gt;priv_stored_or_compute_hash(v, store_hash_t());
<a name="l01415"></a>01415                <span class="keywordflow">if</span>(h != vh || !equal_func(key, v)){
<a name="l01416"></a>01416                   <span class="keywordflow">break</span>;
<a name="l01417"></a>01417                }
<a name="l01418"></a>01418             }
<a name="l01419"></a>01419             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!equal_func(key, v)){
<a name="l01420"></a>01420                <span class="keywordflow">break</span>;
<a name="l01421"></a>01421             }
<a name="l01422"></a>01422             this-&gt;priv_size_traits().decrement();
<a name="l01423"></a>01423          }
<a name="l01424"></a>01424          b.erase_after_and_dispose(prev, it, make_node_disposer(disposer));
<a name="l01425"></a>01425       }
<a name="l01426"></a>01426       priv_erasure_update_cache();
<a name="l01427"></a>01427       <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a45a810b8add3071142d41cdb6e33e1dc">count</a>;
<a name="l01428"></a>01428    }
<a name="l01429"></a>01429 
<a name="l01439"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a8291af6da64d2eba922c9c4a9dabcc18">01439</a>    <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a8291af6da64d2eba922c9c4a9dabcc18">clear</a>()
<a name="l01440"></a>01440    {
<a name="l01441"></a>01441       priv_clear_buckets();
<a name="l01442"></a>01442       this-&gt;priv_size_traits().set_size(size_type(0));
<a name="l01443"></a>01443    }
<a name="l01444"></a>01444 
<a name="l01456"></a>01456    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Disposer&gt;
<a name="l01457"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a6f8ada5bf39c7de871e164bf7c0d26ec">01457</a>    <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a6f8ada5bf39c7de871e164bf7c0d26ec">clear_and_dispose</a>(Disposer disposer)
<a name="l01458"></a>01458    {
<a name="l01459"></a>01459       <span class="keywordflow">if</span>(!<a class="code" href="structboost_1_1intrusive_1_1constant__time__size.html">constant_time_size</a> || !this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a70e71ceca07382bd97a45e1d1a1b3b4b">empty</a>()){
<a name="l01460"></a>01460          size_type num_buckets = this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a11750786436937da5e72352d0dbfcbb7">bucket_count</a>();
<a name="l01461"></a>01461          bucket_ptr b = this-&gt;priv_buckets();
<a name="l01462"></a>01462          <span class="keywordflow">for</span>(; num_buckets--; ++b){
<a name="l01463"></a>01463             b-&gt;clear_and_dispose(make_node_disposer(disposer));
<a name="l01464"></a>01464          }
<a name="l01465"></a>01465          this-&gt;priv_size_traits().set_size(size_type(0));
<a name="l01466"></a>01466       }
<a name="l01467"></a>01467       priv_initialize_cache();
<a name="l01468"></a>01468    }
<a name="l01469"></a>01469 
<a name="l01475"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a45a810b8add3071142d41cdb6e33e1dc">01475</a>    size_type <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a45a810b8add3071142d41cdb6e33e1dc">count</a>(const_reference value)<span class="keyword"> const</span>
<a name="l01476"></a>01476 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a45a810b8add3071142d41cdb6e33e1dc">count</a>(value, this-&gt;priv_hasher(), this-&gt;priv_equal());  }
<a name="l01477"></a>01477 
<a name="l01491"></a>01491    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyHasher, <span class="keyword">class</span> KeyValueEqual&gt;
<a name="l01492"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a18772b8615a7d37f0c6101752c50a2e2">01492</a>    size_type <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a45a810b8add3071142d41cdb6e33e1dc">count</a>(<span class="keyword">const</span> KeyType &amp;key, <span class="keyword">const</span> KeyHasher &amp;hash_func, <span class="keyword">const</span> KeyValueEqual &amp;equal_func)<span class="keyword"> const</span>
<a name="l01493"></a>01493 <span class="keyword">   </span>{
<a name="l01494"></a>01494       size_type bucket_n1, bucket_n2, <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a45a810b8add3071142d41cdb6e33e1dc">count</a>;
<a name="l01495"></a>01495       this-&gt;priv_equal_range(key, hash_func, equal_func, bucket_n1, bucket_n2, count);
<a name="l01496"></a>01496       <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a45a810b8add3071142d41cdb6e33e1dc">count</a>;
<a name="l01497"></a>01497    }
<a name="l01498"></a>01498 
<a name="l01505"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a9abea34d4312d9b6c09092b1cec4e947">01505</a>    <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a9abea34d4312d9b6c09092b1cec4e947">find</a>(const_reference value)
<a name="l01506"></a>01506    {  <span class="keywordflow">return</span> this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a9abea34d4312d9b6c09092b1cec4e947">find</a>(value, this-&gt;priv_hasher(), this-&gt;priv_equal());   }
<a name="l01507"></a>01507 
<a name="l01527"></a>01527    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyHasher, <span class="keyword">class</span> KeyValueEqual&gt;
<a name="l01528"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#ac42d06f0c68250e8bd5b09beb71077f6">01528</a>    <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a9abea34d4312d9b6c09092b1cec4e947">find</a>(<span class="keyword">const</span> KeyType &amp;key, KeyHasher hash_func, KeyValueEqual equal_func)
<a name="l01529"></a>01529    {
<a name="l01530"></a>01530       size_type bucket_n;
<a name="l01531"></a>01531       std::size_t <a class="code" href="structboost_1_1intrusive_1_1hash.html">hash</a>;
<a name="l01532"></a>01532       <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> prev;
<a name="l01533"></a>01533       <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> local_it = this-&gt;priv_find(key, hash_func, equal_func, bucket_n, hash, prev);
<a name="l01534"></a>01534       <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">iterator</a>(local_it, <span class="keyword">this</span>);
<a name="l01535"></a>01535    }
<a name="l01536"></a>01536 
<a name="l01543"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#ad7cc41606ef8928dbd4b2ae47327b9e8">01543</a>    <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">const_iterator</a> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a9abea34d4312d9b6c09092b1cec4e947">find</a>(const_reference value)<span class="keyword"> const</span>
<a name="l01544"></a>01544 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#ad7cc41606ef8928dbd4b2ae47327b9e8">find</a>(value, this-&gt;priv_hasher(), this-&gt;priv_equal());   }
<a name="l01545"></a>01545 
<a name="l01565"></a>01565    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyHasher, <span class="keyword">class</span> KeyValueEqual&gt;
<a name="l01566"></a>01566    const_iterator <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a9abea34d4312d9b6c09092b1cec4e947">find</a>
<a name="l01567"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a2314531b83b5aae7cdf0d4f107040372">01567</a>       (<span class="keyword">const</span> KeyType &amp;key, KeyHasher hash_func, KeyValueEqual equal_func) <span class="keyword">const</span>
<a name="l01568"></a>01568    {
<a name="l01569"></a>01569       size_type bucket_n;
<a name="l01570"></a>01570       std::size_t hash_value;
<a name="l01571"></a>01571       <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> prev;
<a name="l01572"></a>01572       <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> sit = this-&gt;priv_find(key, hash_func, equal_func, bucket_n, hash_value, prev);
<a name="l01573"></a>01573       <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">const_iterator</a>(sit, <span class="keyword">this</span>);
<a name="l01574"></a>01574    }
<a name="l01575"></a>01575 
<a name="l01583"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a9b43da97afa9ccd817be01b6dbf91ec1">01583</a>    std::pair&lt;iterator,iterator&gt; <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a9b43da97afa9ccd817be01b6dbf91ec1">equal_range</a>(const_reference value)
<a name="l01584"></a>01584    {  <span class="keywordflow">return</span> this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a9b43da97afa9ccd817be01b6dbf91ec1">equal_range</a>(value, this-&gt;priv_hasher(), this-&gt;priv_equal());  }
<a name="l01585"></a>01585 
<a name="l01606"></a>01606    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyHasher, <span class="keyword">class</span> KeyValueEqual&gt;
<a name="l01607"></a>01607    std::pair&lt;iterator,iterator&gt; <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a9b43da97afa9ccd817be01b6dbf91ec1">equal_range</a>
<a name="l01608"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#aeb33bd361e06e734c7b1728a1070ed1c">01608</a>       (<span class="keyword">const</span> KeyType &amp;key, KeyHasher hash_func, KeyValueEqual equal_func)
<a name="l01609"></a>01609    {
<a name="l01610"></a>01610       size_type bucket_n1, bucket_n2, <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a45a810b8add3071142d41cdb6e33e1dc">count</a>;
<a name="l01611"></a>01611       std::pair&lt;siterator, siterator&gt; ret = this-&gt;priv_equal_range
<a name="l01612"></a>01612          (key, hash_func, equal_func, bucket_n1, bucket_n2, count);
<a name="l01613"></a>01613       <span class="keywordflow">return</span> std::pair&lt;iterator, iterator&gt;
<a name="l01614"></a>01614          (<a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">iterator</a>(ret.first, <span class="keyword">this</span>), <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">iterator</a>(ret.second, <span class="keyword">this</span>));
<a name="l01615"></a>01615    }
<a name="l01616"></a>01616 
<a name="l01624"></a>01624    std::pair&lt;const_iterator, const_iterator&gt;
<a name="l01625"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#ae156d0632fbcfb6b1e3639be4838e91a">01625</a>       <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a9b43da97afa9ccd817be01b6dbf91ec1">equal_range</a>(const_reference value)<span class="keyword"> const</span>
<a name="l01626"></a>01626 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#ae156d0632fbcfb6b1e3639be4838e91a">equal_range</a>(value, this-&gt;priv_hasher(), this-&gt;priv_equal());  }
<a name="l01627"></a>01627 
<a name="l01648"></a>01648    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyHasher, <span class="keyword">class</span> KeyValueEqual&gt;
<a name="l01649"></a>01649    std::pair&lt;const_iterator,const_iterator&gt; <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a9b43da97afa9ccd817be01b6dbf91ec1">equal_range</a>
<a name="l01650"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#adef63803cd82b08caca828b0756bd0bb">01650</a>       (<span class="keyword">const</span> KeyType &amp;key, KeyHasher hash_func, KeyValueEqual equal_func) <span class="keyword">const</span>
<a name="l01651"></a>01651    {
<a name="l01652"></a>01652       size_type bucket_n1, bucket_n2, <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a45a810b8add3071142d41cdb6e33e1dc">count</a>;
<a name="l01653"></a>01653       std::pair&lt;siterator, siterator&gt; ret =
<a name="l01654"></a>01654          this-&gt;priv_equal_range(key, hash_func, equal_func, bucket_n1, bucket_n2, count);
<a name="l01655"></a>01655       <span class="keywordflow">return</span> std::pair&lt;const_iterator, const_iterator&gt;
<a name="l01656"></a>01656          (<a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">const_iterator</a>(ret.first, <span class="keyword">this</span>), <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">const_iterator</a>(ret.second, <span class="keyword">this</span>));
<a name="l01657"></a>01657    }
<a name="l01658"></a>01658 
<a name="l01668"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#afb55dba84cd3befe476b97a544727d1d">01668</a>    <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">iterator</a> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#afb55dba84cd3befe476b97a544727d1d">iterator_to</a>(reference value)
<a name="l01669"></a>01669    {
<a name="l01670"></a>01670       <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">iterator</a>(bucket_type::s_iterator_to(priv_value_to_node(value)), <span class="keyword">this</span>);
<a name="l01671"></a>01671    }
<a name="l01672"></a>01672 
<a name="l01682"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a53706042b69e51b6020d9ef6b60a635f">01682</a>    <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">const_iterator</a> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#afb55dba84cd3befe476b97a544727d1d">iterator_to</a>(const_reference value)<span class="keyword"> const</span>
<a name="l01683"></a>01683 <span class="keyword">   </span>{
<a name="l01684"></a>01684       <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1hashtable__iterator.html">const_iterator</a>(bucket_type::s_iterator_to(priv_value_to_node(const_cast&lt;reference&gt;(value))), <span class="keyword">this</span>);
<a name="l01685"></a>01685    }
<a name="l01686"></a>01686 
<a name="l01699"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a4c1ce5a3e506e43351568ad27f2f02fc">01699</a>    <span class="keyword">static</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1transform__iterator.html">local_iterator</a> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a4c1ce5a3e506e43351568ad27f2f02fc">s_local_iterator_to</a>(reference value)
<a name="l01700"></a>01700    {
<a name="l01701"></a>01701       BOOST_STATIC_ASSERT((!stateful_value_traits));
<a name="l01702"></a>01702       <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> sit = bucket_type::s_iterator_to(((<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html">hashtable_impl</a>*)0)-&gt;priv_value_to_node(value));
<a name="l01703"></a>01703       <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1transform__iterator.html">local_iterator</a>(sit, (<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html">hashtable_impl</a>*)0);  
<a name="l01704"></a>01704    }
<a name="l01705"></a>01705 
<a name="l01718"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#afdc8aac4bff30a63bc752b02dcb0fae4">01718</a>    <span class="keyword">static</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1transform__iterator.html">const_local_iterator</a> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a4c1ce5a3e506e43351568ad27f2f02fc">s_local_iterator_to</a>(const_reference value)
<a name="l01719"></a>01719    {
<a name="l01720"></a>01720       BOOST_STATIC_ASSERT((!stateful_value_traits));
<a name="l01721"></a>01721       <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> sit = bucket_type::s_iterator_to(((<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html">hashtable_impl</a>*)0)-&gt;priv_value_to_node(const_cast&lt;value_type&amp;&gt;(value)));
<a name="l01722"></a>01722       <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1transform__iterator.html">const_local_iterator</a>(sit, (<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html">hashtable_impl</a>*)0);  
<a name="l01723"></a>01723    }
<a name="l01724"></a>01724 
<a name="l01734"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a8a85ccc8916c4f6e8e2b6aaee421ad4e">01734</a>    <a class="code" href="classboost_1_1intrusive_1_1detail_1_1transform__iterator.html">local_iterator</a> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a8a85ccc8916c4f6e8e2b6aaee421ad4e">local_iterator_to</a>(reference value)
<a name="l01735"></a>01735    {
<a name="l01736"></a>01736       <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> sit = bucket_type::s_iterator_to(this-&gt;priv_value_to_node(value));
<a name="l01737"></a>01737       <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1transform__iterator.html">local_iterator</a>(sit, <span class="keyword">this</span>);  
<a name="l01738"></a>01738    }
<a name="l01739"></a>01739 
<a name="l01749"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a2b422598818dbf0b169893a40ff04a9b">01749</a>    <a class="code" href="classboost_1_1intrusive_1_1detail_1_1transform__iterator.html">const_local_iterator</a> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a8a85ccc8916c4f6e8e2b6aaee421ad4e">local_iterator_to</a>(const_reference value)<span class="keyword"> const</span>
<a name="l01750"></a>01750 <span class="keyword">   </span>{
<a name="l01751"></a>01751       <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> sit = bucket_type::s_iterator_to
<a name="l01752"></a>01752          (const_cast&lt;node &amp;&gt;(this-&gt;priv_value_to_node(value)));
<a name="l01753"></a>01753       <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1transform__iterator.html">const_local_iterator</a>(sit, <span class="keyword">this</span>);  
<a name="l01754"></a>01754    }
<a name="l01755"></a>01755 
<a name="l01762"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a11750786436937da5e72352d0dbfcbb7">01762</a>    size_type <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a11750786436937da5e72352d0dbfcbb7">bucket_count</a>()<span class="keyword"> const</span>
<a name="l01763"></a>01763 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;priv_buckets_len();   }
<a name="l01764"></a>01764 
<a name="l01772"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a251215bbd295ee729e752196cdb65476">01772</a>    size_type <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a251215bbd295ee729e752196cdb65476">bucket_size</a>(size_type n)<span class="keyword"> const</span>
<a name="l01773"></a>01773 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;priv_buckets()[n].size();   }
<a name="l01774"></a>01774 
<a name="l01783"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a44231d55d47bf0349e4f107c09d42550">01783</a>    size_type <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a44231d55d47bf0349e4f107c09d42550">bucket</a>(<span class="keyword">const</span> key_type&amp; k)<span class="keyword">  const</span>
<a name="l01784"></a>01784 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a44231d55d47bf0349e4f107c09d42550">bucket</a>(k, this-&gt;priv_hasher());   }
<a name="l01785"></a>01785 
<a name="l01798"></a>01798    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyHasher&gt;
<a name="l01799"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a52306b6caa6b05ca56e714b935b9eff2">01799</a>    size_type <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a44231d55d47bf0349e4f107c09d42550">bucket</a>(<span class="keyword">const</span> KeyType&amp; k, <span class="keyword">const</span> KeyHasher &amp;hash_func)<span class="keyword">  const</span>
<a name="l01800"></a>01800 <span class="keyword">   </span>{  <span class="keywordflow">return</span> priv_hash_to_bucket(hash_func(k));   }
<a name="l01801"></a>01801 
<a name="l01808"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a420d0697f43aa50ef4c4fe81db550580">01808</a>    bucket_ptr <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a420d0697f43aa50ef4c4fe81db550580">bucket_pointer</a>()<span class="keyword"> const</span>
<a name="l01809"></a>01809 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;priv_buckets();   }
<a name="l01810"></a>01810 
<a name="l01822"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#afb2e170aa3b2d46751b1aeabb2efc414">01822</a>    <a class="code" href="classboost_1_1intrusive_1_1detail_1_1transform__iterator.html">local_iterator</a> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#ab5d772f059e3232e024dcff5af61f9e2">begin</a>(size_type n)
<a name="l01823"></a>01823    {  <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1transform__iterator.html">local_iterator</a>(this-&gt;priv_buckets()[n].<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#afb2e170aa3b2d46751b1aeabb2efc414">begin</a>(), <span class="keyword">this</span>);  }
<a name="l01824"></a>01824 
<a name="l01836"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#adf09353b8a78477d487e1d69166eb634">01836</a>    <a class="code" href="classboost_1_1intrusive_1_1detail_1_1transform__iterator.html">const_local_iterator</a> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#ab5d772f059e3232e024dcff5af61f9e2">begin</a>(size_type n)<span class="keyword"> const</span>
<a name="l01837"></a>01837 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#afc1c7507cc01bf686393028c92201def">cbegin</a>(n);  }
<a name="l01838"></a>01838 
<a name="l01850"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#aa35c63b1e16fb693ab1e12beee87137c">01850</a>    <a class="code" href="classboost_1_1intrusive_1_1detail_1_1transform__iterator.html">const_local_iterator</a> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#afc1c7507cc01bf686393028c92201def">cbegin</a>(size_type n)<span class="keyword"> const</span>
<a name="l01851"></a>01851 <span class="keyword">   </span>{
<a name="l01852"></a>01852       <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> sit = <span class="keyword">const_cast&lt;</span><a class="code" href="structboost_1_1intrusive_1_1detail_1_1bucket__impl.html">bucket_type</a>&amp;<span class="keyword">&gt;</span>(this-&gt;priv_buckets()[n]).<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#ab5d772f059e3232e024dcff5af61f9e2">begin</a>();
<a name="l01853"></a>01853       <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1transform__iterator.html">const_local_iterator</a>(sit, <span class="keyword">this</span>);
<a name="l01854"></a>01854    }
<a name="l01855"></a>01855 
<a name="l01867"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a9cb8ba05a11a302c7e6a8e5f656cc5f8">01867</a>    <a class="code" href="classboost_1_1intrusive_1_1detail_1_1transform__iterator.html">local_iterator</a> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a3bb26f838e8c85730ae98204134fd813">end</a>(size_type n)
<a name="l01868"></a>01868    {  <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1transform__iterator.html">local_iterator</a>(this-&gt;priv_buckets()[n].<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a9cb8ba05a11a302c7e6a8e5f656cc5f8">end</a>(), <span class="keyword">this</span>);  }
<a name="l01869"></a>01869 
<a name="l01881"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a714dca349b6ea139cbe20e7ebe4dc969">01881</a>    <a class="code" href="classboost_1_1intrusive_1_1detail_1_1transform__iterator.html">const_local_iterator</a> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a3bb26f838e8c85730ae98204134fd813">end</a>(size_type n)<span class="keyword"> const</span>
<a name="l01882"></a>01882 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a5b50e47a307986f2011f5090a7fd6c15">cend</a>(n);  }
<a name="l01883"></a>01883 
<a name="l01895"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a940f3f3417af83584a0e39b490be872d">01895</a>    <a class="code" href="classboost_1_1intrusive_1_1detail_1_1transform__iterator.html">const_local_iterator</a> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a5b50e47a307986f2011f5090a7fd6c15">cend</a>(size_type n)<span class="keyword"> const</span>
<a name="l01896"></a>01896 <span class="keyword">   </span>{  <span class="keywordflow">return</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1transform__iterator.html">const_local_iterator</a>(const_cast&lt;bucket_type&amp;&gt;(this-&gt;priv_buckets()[n]).<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a3bb26f838e8c85730ae98204134fd813">end</a>(), <span class="keyword">this</span>);  }
<a name="l01897"></a>01897 
<a name="l01915"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a2b8716ead1f4d3ccc684d20eda5a7c30">01915</a>    <span class="keywordtype">void</span> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a2b8716ead1f4d3ccc684d20eda5a7c30">rehash</a>(<span class="keyword">const</span> <a class="code" href="structboost_1_1intrusive_1_1bucket__traits.html">bucket_traits</a> &amp;new_bucket_traits)
<a name="l01916"></a>01916    {
<a name="l01917"></a>01917       bucket_ptr new_buckets     = new_bucket_traits.bucket_begin();
<a name="l01918"></a>01918       size_type  new_buckets_len = new_bucket_traits.bucket_count();
<a name="l01919"></a>01919       bucket_ptr old_buckets     = this-&gt;priv_buckets();
<a name="l01920"></a>01920       size_type  old_buckets_len = this-&gt;priv_buckets_len();
<a name="l01921"></a>01921 
<a name="l01922"></a>01922       <span class="comment">//Check power of two bucket array if the option is activated      </span>
<a name="l01923"></a>01923       BOOST_INTRUSIVE_INVARIANT_ASSERT
<a name="l01924"></a>01924       (!<a class="code" href="structboost_1_1intrusive_1_1power__2__buckets.html">power_2_buckets</a> || (0 == (new_buckets_len &amp; (new_buckets_len-1u))));
<a name="l01925"></a>01925 
<a name="l01926"></a>01926       size_type n = priv_get_cache_bucket_num();
<a name="l01927"></a>01927       <span class="keyword">const</span> <span class="keywordtype">bool</span> same_buffer = old_buckets == new_buckets;
<a name="l01928"></a>01928       <span class="comment">//If the new bucket length is a common factor</span>
<a name="l01929"></a>01929       <span class="comment">//of the old one we can avoid hash calculations.</span>
<a name="l01930"></a>01930       <span class="keyword">const</span> <span class="keywordtype">bool</span> fast_shrink = (!<a class="code" href="structboost_1_1intrusive_1_1incremental.html">incremental</a>) &amp;&amp; (old_buckets_len &gt; new_buckets_len) &amp;&amp; 
<a name="l01931"></a>01931          (<a class="code" href="structboost_1_1intrusive_1_1power__2__buckets.html">power_2_buckets</a> ||(old_buckets_len % new_buckets_len) == 0);
<a name="l01932"></a>01932       <span class="comment">//If we are shrinking the same bucket array and it&#39;s</span>
<a name="l01933"></a>01933       <span class="comment">//is a fast shrink, just rehash the last nodes</span>
<a name="l01934"></a>01934       size_type new_first_bucket_num = new_buckets_len;
<a name="l01935"></a>01935       <span class="keywordflow">if</span>(same_buffer &amp;&amp; fast_shrink &amp;&amp; (n &lt; new_buckets_len)){
<a name="l01936"></a>01936          n = new_buckets_len;
<a name="l01937"></a>01937          new_first_bucket_num = priv_get_cache_bucket_num();
<a name="l01938"></a>01938       }
<a name="l01939"></a>01939 
<a name="l01940"></a>01940       <span class="comment">//Anti-exception stuff: they destroy the elements if something goes wrong.</span>
<a name="l01941"></a>01941       <span class="comment">//If the source and destination buckets are the same, the second rollback function</span>
<a name="l01942"></a>01942       <span class="comment">//is harmless, because all elements have been already unlinked and destroyed</span>
<a name="l01943"></a>01943       <span class="keyword">typedef</span> <a class="code" href="classboost_1_1intrusive_1_1detail_1_1init__disposer.html">detail::init_disposer&lt;node_algorithms&gt;</a> NodeDisposer;
<a name="l01944"></a>01944       NodeDisposer node_disp;
<a name="l01945"></a>01945       <a class="code" href="classboost_1_1intrusive_1_1detail_1_1exception__array__disposer.html">detail::exception_array_disposer&lt;bucket_type, NodeDisposer&gt;</a>
<a name="l01946"></a>01946          rollback1(new_buckets[0], node_disp, new_buckets_len);
<a name="l01947"></a>01947       <a class="code" href="classboost_1_1intrusive_1_1detail_1_1exception__array__disposer.html">detail::exception_array_disposer&lt;bucket_type, NodeDisposer&gt;</a>
<a name="l01948"></a>01948          rollback2(old_buckets[0], node_disp, old_buckets_len);
<a name="l01949"></a>01949 
<a name="l01950"></a>01950       <span class="comment">//Put size in a safe value for rollback exception</span>
<a name="l01951"></a>01951       size_type size_backup = this-&gt;priv_size_traits().get_size();
<a name="l01952"></a>01952       this-&gt;priv_size_traits().set_size(0);
<a name="l01953"></a>01953       <span class="comment">//Put cache to safe position</span>
<a name="l01954"></a>01954       priv_initialize_cache();
<a name="l01955"></a>01955       priv_insertion_update_cache(size_type(0u));
<a name="l01956"></a>01956 
<a name="l01957"></a>01957       <span class="comment">//Iterate through nodes</span>
<a name="l01958"></a>01958       <span class="keywordflow">for</span>(; n &lt; old_buckets_len; ++n){
<a name="l01959"></a>01959          <a class="code" href="structboost_1_1intrusive_1_1detail_1_1bucket__impl.html">bucket_type</a> &amp;old_bucket = old_buckets[n];
<a name="l01960"></a>01960 
<a name="l01961"></a>01961          <span class="keywordflow">if</span>(!fast_shrink){
<a name="l01962"></a>01962             <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> before_i(old_bucket.before_begin());
<a name="l01963"></a>01963             <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a3bb26f838e8c85730ae98204134fd813">end</a>(old_bucket.end());
<a name="l01964"></a>01964             <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> i(old_bucket.begin());
<a name="l01965"></a>01965             <span class="keywordflow">for</span>(;i != <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a3bb26f838e8c85730ae98204134fd813">end</a>; ++i){
<a name="l01966"></a>01966                <span class="keyword">const</span> value_type &amp;v = priv_value_from_slist_node(i.pointed_node());
<a name="l01967"></a>01967                <span class="keyword">const</span> std::size_t hash_value = this-&gt;priv_stored_or_compute_hash(v, store_hash_t());
<a name="l01968"></a>01968                <span class="keyword">const</span> size_type new_n = priv_hash_to_bucket(hash_value, new_buckets_len, new_buckets_len);
<a name="l01969"></a>01969                <span class="keywordflow">if</span>(<a class="code" href="structboost_1_1intrusive_1_1cache__begin.html">cache_begin</a> &amp;&amp; new_n &lt; new_first_bucket_num)
<a name="l01970"></a>01970                   new_first_bucket_num = new_n;
<a name="l01971"></a>01971                <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> last = bucket_type::s_iterator_to
<a name="l01972"></a>01972                   (*group_functions_t::priv_get_last_in_group
<a name="l01973"></a>01973                      (dcast_bucket_ptr(i.pointed_node()), optimize_multikey_t()));
<a name="l01974"></a>01974                <span class="keywordflow">if</span>(same_buffer &amp;&amp; new_n == n){
<a name="l01975"></a>01975                   before_i = last;
<a name="l01976"></a>01976                }
<a name="l01977"></a>01977                <span class="keywordflow">else</span>{
<a name="l01978"></a>01978                   <a class="code" href="structboost_1_1intrusive_1_1detail_1_1bucket__impl.html">bucket_type</a> &amp;new_b = new_buckets[new_n];
<a name="l01979"></a>01979                   new_b.splice_after(new_b.before_begin(), old_bucket, before_i, last);
<a name="l01980"></a>01980                }
<a name="l01981"></a>01981                i = before_i;
<a name="l01982"></a>01982             }
<a name="l01983"></a>01983          }
<a name="l01984"></a>01984          <span class="keywordflow">else</span>{
<a name="l01985"></a>01985             <span class="keyword">const</span> size_type new_n = priv_hash_to_bucket(n, new_buckets_len, new_buckets_len);
<a name="l01986"></a>01986             <span class="keywordflow">if</span>(<a class="code" href="structboost_1_1intrusive_1_1cache__begin.html">cache_begin</a> &amp;&amp; new_n &lt; new_first_bucket_num)
<a name="l01987"></a>01987                new_first_bucket_num = new_n;
<a name="l01988"></a>01988             <a class="code" href="structboost_1_1intrusive_1_1detail_1_1bucket__impl.html">bucket_type</a> &amp;new_b = new_buckets[new_n];
<a name="l01989"></a>01989             <span class="keywordflow">if</span>(!old_bucket.empty()){
<a name="l01990"></a>01990                new_b.splice_after( new_b.before_begin()
<a name="l01991"></a>01991                                  , old_bucket
<a name="l01992"></a>01992                                  , old_bucket.before_begin()
<a name="l01993"></a>01993                                  , priv_get_last(old_bucket));
<a name="l01994"></a>01994             }
<a name="l01995"></a>01995          }
<a name="l01996"></a>01996       }
<a name="l01997"></a>01997 
<a name="l01998"></a>01998       this-&gt;priv_size_traits().set_size(size_backup);
<a name="l01999"></a>01999       this-&gt;priv_split_traits().set_size(new_buckets_len);
<a name="l02000"></a>02000       this-&gt;priv_real_bucket_traits() = new_bucket_traits;
<a name="l02001"></a>02001       priv_initialize_cache();
<a name="l02002"></a>02002       priv_insertion_update_cache(new_first_bucket_num);
<a name="l02003"></a>02003       rollback1.release();
<a name="l02004"></a>02004       rollback2.release();
<a name="l02005"></a>02005    }
<a name="l02006"></a>02006 
<a name="l02016"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a167c0127dc025346321a864335fd8a4f">02016</a>    <span class="keywordtype">bool</span> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a167c0127dc025346321a864335fd8a4f">incremental_rehash</a>(<span class="keywordtype">bool</span> grow = <span class="keyword">true</span>)
<a name="l02017"></a>02017    {
<a name="l02018"></a>02018       <span class="comment">//This function is only available for containers with incremental hashing</span>
<a name="l02019"></a>02019       BOOST_STATIC_ASSERT(( <a class="code" href="structboost_1_1intrusive_1_1incremental.html">incremental</a> &amp;&amp; <a class="code" href="structboost_1_1intrusive_1_1power__2__buckets.html">power_2_buckets</a> ));
<a name="l02020"></a>02020       size_type split_idx = priv_split_traits().get_size();
<a name="l02021"></a>02021       size_type bucket_len = priv_buckets_len();
<a name="l02022"></a>02022 
<a name="l02023"></a>02023       <span class="keywordflow">if</span>(grow){
<a name="l02024"></a>02024          <span class="comment">//Test if the split variable can be changed</span>
<a name="l02025"></a>02025          <span class="keywordflow">if</span>(split_idx &gt;= bucket_len)
<a name="l02026"></a>02026             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02027"></a>02027 
<a name="l02028"></a>02028          size_type bucket_len = priv_buckets_len();
<a name="l02029"></a>02029          size_type bucket_to_rehash = split_idx - bucket_len/2;
<a name="l02030"></a>02030          <a class="code" href="structboost_1_1intrusive_1_1detail_1_1bucket__impl.html">bucket_type</a> &amp;old_bucket = this-&gt;priv_buckets()[bucket_to_rehash];
<a name="l02031"></a>02031          <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> before_i(old_bucket.before_begin());
<a name="l02032"></a>02032          <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a3bb26f838e8c85730ae98204134fd813">end</a>(old_bucket.end());
<a name="l02033"></a>02033          <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> i(old_bucket.begin());
<a name="l02034"></a>02034          priv_split_traits().increment();
<a name="l02035"></a>02035 
<a name="l02036"></a>02036          <span class="comment">//Anti-exception stuff: if an exception is thrown while</span>
<a name="l02037"></a>02037          <span class="comment">//moving elements from old_bucket to the target bucket, all moved</span>
<a name="l02038"></a>02038          <span class="comment">//elements are moved back to the original one.</span>
<a name="l02039"></a>02039          detail::incremental_rehash_rollback&lt;bucket_type, split_traits&gt; rollback
<a name="l02040"></a>02040             ( this-&gt;priv_buckets()[split_idx], old_bucket, priv_split_traits());
<a name="l02041"></a>02041          <span class="keywordflow">for</span>(;i != <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a3bb26f838e8c85730ae98204134fd813">end</a>; ++i){
<a name="l02042"></a>02042             <span class="keyword">const</span> value_type &amp;v = priv_value_from_slist_node(i.pointed_node());
<a name="l02043"></a>02043             <span class="keyword">const</span> std::size_t hash_value = this-&gt;priv_stored_or_compute_hash(v, store_hash_t());
<a name="l02044"></a>02044             <span class="keyword">const</span> size_type new_n = priv_hash_to_bucket(hash_value);
<a name="l02045"></a>02045             <a class="code" href="classboost_1_1intrusive_1_1slist__iterator.html">siterator</a> last = bucket_type::s_iterator_to
<a name="l02046"></a>02046                (*group_functions_t::priv_get_last_in_group
<a name="l02047"></a>02047                   (dcast_bucket_ptr(i.pointed_node()), optimize_multikey_t()));
<a name="l02048"></a>02048             <span class="keywordflow">if</span>(new_n == bucket_to_rehash){
<a name="l02049"></a>02049                before_i = last;
<a name="l02050"></a>02050             }
<a name="l02051"></a>02051             <span class="keywordflow">else</span>{
<a name="l02052"></a>02052                <a class="code" href="structboost_1_1intrusive_1_1detail_1_1bucket__impl.html">bucket_type</a> &amp;new_b = this-&gt;priv_buckets()[new_n];
<a name="l02053"></a>02053                new_b.splice_after(new_b.before_begin(), old_bucket, before_i, last);
<a name="l02054"></a>02054             }
<a name="l02055"></a>02055             i = before_i;
<a name="l02056"></a>02056          }
<a name="l02057"></a>02057          rollback.release();
<a name="l02058"></a>02058          priv_erasure_update_cache();
<a name="l02059"></a>02059          <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02060"></a>02060       }
<a name="l02061"></a>02061       <span class="keywordflow">else</span>{
<a name="l02062"></a>02062          <span class="comment">//Test if the split variable can be changed</span>
<a name="l02063"></a>02063          <span class="keywordflow">if</span>(split_idx &lt;= bucket_len/2)
<a name="l02064"></a>02064             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02065"></a>02065          <span class="keyword">const</span> size_type target_bucket_num = split_idx - 1 - bucket_len/2;
<a name="l02066"></a>02066          <a class="code" href="structboost_1_1intrusive_1_1detail_1_1bucket__impl.html">bucket_type</a> &amp;target_bucket = this-&gt;priv_buckets()[target_bucket_num];
<a name="l02067"></a>02067          <a class="code" href="structboost_1_1intrusive_1_1detail_1_1bucket__impl.html">bucket_type</a> &amp;source_bucket = this-&gt;priv_buckets()[split_idx-1];
<a name="l02068"></a>02068          target_bucket.splice_after(target_bucket.cbefore_begin(), source_bucket);
<a name="l02069"></a>02069          priv_split_traits().decrement();
<a name="l02070"></a>02070          priv_insertion_update_cache(target_bucket_num);
<a name="l02071"></a>02071          <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02072"></a>02072       }
<a name="l02073"></a>02073    }
<a name="l02074"></a>02074 
<a name="l02088"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#aa595c6a69f43714133f34d564ed79a74">02088</a>    <span class="keywordtype">bool</span> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a167c0127dc025346321a864335fd8a4f">incremental_rehash</a>(<span class="keyword">const</span> <a class="code" href="structboost_1_1intrusive_1_1bucket__traits.html">bucket_traits</a> &amp;new_bucket_traits)
<a name="l02089"></a>02089    {
<a name="l02090"></a>02090       <span class="comment">//This function is only available for containers with incremental hashing</span>
<a name="l02091"></a>02091       BOOST_STATIC_ASSERT(( <a class="code" href="structboost_1_1intrusive_1_1incremental.html">incremental</a> &amp;&amp; <a class="code" href="structboost_1_1intrusive_1_1power__2__buckets.html">power_2_buckets</a> ));
<a name="l02092"></a>02092       size_type new_bucket_traits_size = new_bucket_traits.bucket_count();
<a name="l02093"></a>02093       size_type cur_bucket_traits      = this-&gt;priv_buckets_len();
<a name="l02094"></a>02094       <span class="keywordflow">if</span>(new_bucket_traits_size/2 != cur_bucket_traits &amp;&amp; new_bucket_traits_size != cur_bucket_traits/2){
<a name="l02095"></a>02095          <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02096"></a>02096       }
<a name="l02097"></a>02097 
<a name="l02098"></a>02098       <span class="keyword">const</span> size_type split_idx = this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#ad8009242a758d09e48fbe6440a6b2f47">split_count</a>();
<a name="l02099"></a>02099 
<a name="l02100"></a>02100       <span class="keywordflow">if</span>(new_bucket_traits_size/2 == cur_bucket_traits){
<a name="l02101"></a>02101          <span class="comment">//Test if the split variable can be changed</span>
<a name="l02102"></a>02102          <span class="keywordflow">if</span>(!(split_idx &gt;= cur_bucket_traits))
<a name="l02103"></a>02103             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02104"></a>02104       }
<a name="l02105"></a>02105       <span class="keywordflow">else</span>{
<a name="l02106"></a>02106          <span class="comment">//Test if the split variable can be changed</span>
<a name="l02107"></a>02107          <span class="keywordflow">if</span>(!(split_idx &lt;= cur_bucket_traits/2))
<a name="l02108"></a>02108             <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l02109"></a>02109       }
<a name="l02110"></a>02110 
<a name="l02111"></a>02111       <span class="keyword">const</span> size_type ini_n = priv_get_cache_bucket_num();
<a name="l02112"></a>02112       <span class="keyword">const</span> bucket_ptr old_buckets = this-&gt;priv_buckets();
<a name="l02113"></a>02113       this-&gt;priv_real_bucket_traits() = new_bucket_traits;
<a name="l02114"></a>02114       <span class="keywordflow">if</span>(new_bucket_traits.bucket_begin() != old_buckets){
<a name="l02115"></a>02115          <span class="keywordflow">for</span>(size_type n = ini_n; n &lt; split_idx; ++n){
<a name="l02116"></a>02116             <a class="code" href="structboost_1_1intrusive_1_1detail_1_1bucket__impl.html">bucket_type</a> &amp;new_bucket = new_bucket_traits.bucket_begin()[n];
<a name="l02117"></a>02117             <a class="code" href="structboost_1_1intrusive_1_1detail_1_1bucket__impl.html">bucket_type</a> &amp;old_bucket = old_buckets[n];
<a name="l02118"></a>02118             new_bucket.splice_after(new_bucket.cbefore_begin(), old_bucket);
<a name="l02119"></a>02119          }
<a name="l02120"></a>02120          <span class="comment">//Put cache to safe position</span>
<a name="l02121"></a>02121          priv_initialize_cache();
<a name="l02122"></a>02122          priv_insertion_update_cache(ini_n);
<a name="l02123"></a>02123       }
<a name="l02124"></a>02124       <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02125"></a>02125    }
<a name="l02126"></a>02126 
<a name="l02134"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#ad8009242a758d09e48fbe6440a6b2f47">02134</a>    size_type <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#ad8009242a758d09e48fbe6440a6b2f47">split_count</a>()<span class="keyword"> const</span>
<a name="l02135"></a>02135 <span class="keyword">   </span>{
<a name="l02136"></a>02136       <span class="comment">//This function is only available if incremental hashing is activated</span>
<a name="l02137"></a>02137       BOOST_STATIC_ASSERT(( <a class="code" href="structboost_1_1intrusive_1_1incremental.html">incremental</a> &amp;&amp; <a class="code" href="structboost_1_1intrusive_1_1power__2__buckets.html">power_2_buckets</a> ));
<a name="l02138"></a>02138       <span class="keywordflow">return</span> this-&gt;priv_split_traits().get_size();
<a name="l02139"></a>02139    }
<a name="l02140"></a>02140 
<a name="l02150"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a1e845a8b5afdd4641a04cc1eb8af3395">02150</a>    <span class="keyword">static</span> size_type <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a1e845a8b5afdd4641a04cc1eb8af3395">suggested_upper_bucket_count</a>(size_type n)
<a name="l02151"></a>02151    {
<a name="l02152"></a>02152       <span class="keyword">const</span> std::size_t *primes     = &amp;<a class="code" href="structboost_1_1intrusive_1_1detail_1_1prime__list__holder.html">detail::prime_list_holder&lt;0&gt;::prime_list</a>[0];
<a name="l02153"></a>02153       <span class="keyword">const</span> std::size_t *primes_end = primes + <a class="code" href="structboost_1_1intrusive_1_1detail_1_1prime__list__holder.html">detail::prime_list_holder&lt;0&gt;::prime_list_size</a>;
<a name="l02154"></a>02154       size_type <span class="keyword">const</span>* bound = std::lower_bound(primes, primes_end, n);
<a name="l02155"></a>02155       <span class="keywordflow">if</span>(bound == primes_end)
<a name="l02156"></a>02156          --bound;
<a name="l02157"></a>02157       <span class="keywordflow">return</span> size_type(*bound);
<a name="l02158"></a>02158    }
<a name="l02159"></a>02159 
<a name="l02169"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a58040afa0336f9f7affb58bc0610401e">02169</a>    <span class="keyword">static</span> size_type <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a58040afa0336f9f7affb58bc0610401e">suggested_lower_bucket_count</a>(size_type n)
<a name="l02170"></a>02170    {
<a name="l02171"></a>02171       <span class="keyword">const</span> std::size_t *primes     = &amp;<a class="code" href="structboost_1_1intrusive_1_1detail_1_1prime__list__holder.html">detail::prime_list_holder&lt;0&gt;::prime_list</a>[0];
<a name="l02172"></a>02172       <span class="keyword">const</span> std::size_t *primes_end = primes + <a class="code" href="structboost_1_1intrusive_1_1detail_1_1prime__list__holder.html">detail::prime_list_holder&lt;0&gt;::prime_list_size</a>;
<a name="l02173"></a>02173       size_type <span class="keyword">const</span>* bound = std::upper_bound(primes, primes_end, n);
<a name="l02174"></a>02174       <span class="keywordflow">if</span>(bound != primes)
<a name="l02175"></a>02175          --bound;
<a name="l02176"></a>02176       <span class="keywordflow">return</span> size_type(*bound);
<a name="l02177"></a>02177    }
<a name="l02178"></a>02178 
<a name="l02180"></a>02180    <span class="keyword">private</span>:
<a name="l02181"></a>02181 
<a name="l02182"></a>02182    std::size_t priv_hash_to_bucket(std::size_t hash_value)<span class="keyword"> const</span>
<a name="l02183"></a>02183 <span class="keyword">   </span>{  <span class="keywordflow">return</span> priv_hash_to_bucket(hash_value, this-&gt;priv_real_bucket_traits().<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a11750786436937da5e72352d0dbfcbb7">bucket_count</a>(), priv_split_traits().get_size()); }
<a name="l02184"></a>02184 
<a name="l02185"></a>02185    std::size_t priv_hash_to_bucket(std::size_t hash_value, std::size_t bucket_len, std::size_t split)<span class="keyword"> const</span>
<a name="l02186"></a>02186 <span class="keyword">   </span>{
<a name="l02187"></a>02187       std::size_t bucket_number = priv_hash_to_bucket_impl(hash_value, bucket_len, power_2_buckets_t());
<a name="l02188"></a>02188       <span class="keywordflow">if</span>(incremental)
<a name="l02189"></a>02189          <span class="keywordflow">if</span>(bucket_number &gt;= split)
<a name="l02190"></a>02190             bucket_number -= bucket_len/2;
<a name="l02191"></a>02191       <span class="keywordflow">return</span> bucket_number;
<a name="l02192"></a>02192    }
<a name="l02193"></a>02193 
<a name="l02194"></a>02194    std::size_t priv_hash_to_bucket_impl(std::size_t hash_value, std::size_t bucket_len, detail::bool_&lt;false&gt;)<span class="keyword"> const</span>
<a name="l02195"></a>02195 <span class="keyword">   </span>{  <span class="keywordflow">return</span> hash_value % bucket_len;  }
<a name="l02196"></a>02196 
<a name="l02197"></a>02197    std::size_t priv_hash_to_bucket_impl(std::size_t hash_value, std::size_t bucket_len, detail::bool_&lt;true&gt;)<span class="keyword"> const</span>
<a name="l02198"></a>02198 <span class="keyword">   </span>{  <span class="keywordflow">return</span> hash_value &amp; (bucket_len - 1);   }
<a name="l02199"></a>02199 
<a name="l02200"></a>02200    <span class="keyword">const</span> key_equal &amp;priv_equal()<span class="keyword"> const</span>
<a name="l02201"></a>02201 <span class="keyword">   </span>{  <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>key_equal&amp;<span class="keyword">&gt;</span>(this-&gt;data_.internal_.bucket_hash_equal_.get());  }
<a name="l02202"></a>02202 
<a name="l02203"></a>02203    key_equal &amp;priv_equal()
<a name="l02204"></a>02204    {  <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>key_equal&amp;<span class="keyword">&gt;</span>(this-&gt;data_.internal_.bucket_hash_equal_.get());  }
<a name="l02205"></a>02205 
<a name="l02206"></a>02206    value_type &amp;priv_value_from_slist_node(slist_node_ptr n)
<a name="l02207"></a>02207    {  <span class="keywordflow">return</span> *this-&gt;get_real_value_traits().to_value_ptr(dcast_bucket_ptr(n)); }
<a name="l02208"></a>02208 
<a name="l02209"></a>02209    <span class="keyword">const</span> value_type &amp;priv_value_from_slist_node(slist_node_ptr n)<span class="keyword"> const</span>
<a name="l02210"></a>02210 <span class="keyword">   </span>{  <span class="keywordflow">return</span> *this-&gt;get_real_value_traits().to_value_ptr(dcast_bucket_ptr(n)); }
<a name="l02211"></a>02211 
<a name="l02212"></a>02212    <span class="keyword">const</span> real_bucket_traits &amp;priv_real_bucket_traits(detail::bool_&lt;false&gt;)<span class="keyword"> const</span>
<a name="l02213"></a>02213 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;data_.internal_.bucket_hash_equal_.bucket_hash.bucket_plus_size_.bucket_traits_;  }
<a name="l02214"></a>02214 
<a name="l02215"></a>02215    <span class="keyword">const</span> real_bucket_traits &amp;priv_real_bucket_traits(detail::bool_&lt;true&gt;)<span class="keyword"> const</span>
<a name="l02216"></a>02216 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;data_.internal_.bucket_hash_equal_.bucket_hash.bucket_plus_size_.bucket_traits_.get_bucket_traits(*<span class="keyword">this</span>);  }
<a name="l02217"></a>02217 
<a name="l02218"></a>02218    real_bucket_traits &amp;priv_real_bucket_traits(detail::bool_&lt;false&gt;)
<a name="l02219"></a>02219    {  <span class="keywordflow">return</span> this-&gt;data_.internal_.bucket_hash_equal_.bucket_hash.bucket_plus_size_.bucket_traits_;  }
<a name="l02220"></a>02220 
<a name="l02221"></a>02221    real_bucket_traits &amp;priv_real_bucket_traits(detail::bool_&lt;true&gt;)
<a name="l02222"></a>02222    {  <span class="keywordflow">return</span> this-&gt;data_.internal_.bucket_hash_equal_.bucket_hash.bucket_plus_size_.bucket_traits_.get_bucket_traits(*<span class="keyword">this</span>);  }
<a name="l02223"></a>02223 
<a name="l02224"></a>02224    <span class="keyword">const</span> real_bucket_traits &amp;priv_real_bucket_traits()<span class="keyword"> const</span>
<a name="l02225"></a>02225 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;priv_real_bucket_traits(detail::bool_&lt;external_bucket_traits&gt;());  }
<a name="l02226"></a>02226 
<a name="l02227"></a>02227    real_bucket_traits &amp;priv_real_bucket_traits()
<a name="l02228"></a>02228    {  <span class="keywordflow">return</span> this-&gt;priv_real_bucket_traits(detail::bool_&lt;external_bucket_traits&gt;());  }
<a name="l02229"></a>02229 
<a name="l02230"></a>02230    <span class="keyword">const</span> hasher &amp;priv_hasher()<span class="keyword"> const</span>
<a name="l02231"></a>02231 <span class="keyword">   </span>{  <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>hasher&amp;<span class="keyword">&gt;</span>(this-&gt;data_.internal_.bucket_hash_equal_.bucket_hash.get());  }
<a name="l02232"></a>02232 
<a name="l02233"></a>02233    hasher &amp;priv_hasher()
<a name="l02234"></a>02234    {  <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>hasher&amp;<span class="keyword">&gt;</span>(this-&gt;data_.internal_.bucket_hash_equal_.bucket_hash.get());  }
<a name="l02235"></a>02235 
<a name="l02236"></a>02236    bucket_ptr priv_buckets()<span class="keyword"> const</span>
<a name="l02237"></a>02237 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;priv_real_bucket_traits().bucket_begin();  }
<a name="l02238"></a>02238 
<a name="l02239"></a>02239    size_type priv_buckets_len()<span class="keyword"> const</span>
<a name="l02240"></a>02240 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;priv_real_bucket_traits().bucket_count();  }
<a name="l02241"></a>02241 
<a name="l02242"></a>02242    <span class="keyword">static</span> node_ptr uncast(const_node_ptr ptr)
<a name="l02243"></a>02243    {  <span class="keywordflow">return</span> node_ptr(const_cast&lt;node*&gt;(detail::boost_intrusive_get_pointer(ptr)));  }
<a name="l02244"></a>02244 
<a name="l02245"></a>02245    node &amp;priv_value_to_node(value_type &amp;v)
<a name="l02246"></a>02246    {  <span class="keywordflow">return</span> *this-&gt;get_real_value_traits().to_node_ptr(v);  }
<a name="l02247"></a>02247 
<a name="l02248"></a>02248    <span class="keyword">const</span> node &amp;priv_value_to_node(<span class="keyword">const</span> value_type &amp;v)<span class="keyword"> const</span>
<a name="l02249"></a>02249 <span class="keyword">   </span>{  <span class="keywordflow">return</span> *this-&gt;get_real_value_traits().to_node_ptr(v);  }
<a name="l02250"></a>02250 
<a name="l02251"></a>02251    size_traits &amp;priv_size_traits()
<a name="l02252"></a>02252    {  <span class="keywordflow">return</span> this-&gt;data_.internal_.bucket_hash_equal_.bucket_hash.bucket_plus_size_;  }
<a name="l02253"></a>02253 
<a name="l02254"></a>02254    <span class="keyword">const</span> size_traits &amp;priv_size_traits()<span class="keyword"> const</span>
<a name="l02255"></a>02255 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;data_.internal_.bucket_hash_equal_.bucket_hash.bucket_plus_size_;  }
<a name="l02256"></a>02256 
<a name="l02257"></a>02257    split_traits &amp;priv_split_traits()
<a name="l02258"></a>02258    {  <span class="keywordflow">return</span> this-&gt;data_.internal_;  }
<a name="l02259"></a>02259 
<a name="l02260"></a>02260    <span class="keyword">const</span> split_traits &amp;priv_split_traits()<span class="keyword"> const</span>
<a name="l02261"></a>02261 <span class="keyword">   </span>{  <span class="keywordflow">return</span> this-&gt;data_.internal_;  }
<a name="l02262"></a>02262 
<a name="l02263"></a>02263    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Disposer&gt;
<a name="l02264"></a>02264    <span class="keywordtype">void</span> priv_erase_range_impl
<a name="l02265"></a>02265       (size_type bucket_num, siterator before_first_it, siterator <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a3bb26f838e8c85730ae98204134fd813">end</a>, Disposer disposer, size_type &amp;num_erased)
<a name="l02266"></a>02266    {
<a name="l02267"></a>02267       <span class="keyword">const</span> bucket_ptr buckets = priv_buckets();
<a name="l02268"></a>02268       bucket_type &amp;b = buckets[bucket_num];
<a name="l02269"></a>02269 
<a name="l02270"></a>02270       <span class="keywordflow">if</span>(before_first_it == b.before_begin() &amp;&amp; end == b.end()){
<a name="l02271"></a>02271          priv_erase_range_impl(bucket_num, 1, disposer, num_erased);
<a name="l02272"></a>02272       }
<a name="l02273"></a>02273       <span class="keywordflow">else</span>{
<a name="l02274"></a>02274          num_erased = 0;
<a name="l02275"></a>02275          siterator to_erase(before_first_it);
<a name="l02276"></a>02276          ++to_erase;
<a name="l02277"></a>02277          slist_node_ptr end_ptr = end.pointed_node();
<a name="l02278"></a>02278          <span class="keywordflow">while</span>(to_erase != end){
<a name="l02279"></a>02279             group_functions_t::priv_erase_from_group(end_ptr, dcast_bucket_ptr(to_erase.pointed_node()), optimize_multikey_t());
<a name="l02280"></a>02280             to_erase = b.erase_after_and_dispose(before_first_it, make_node_disposer(disposer));
<a name="l02281"></a>02281             ++num_erased;
<a name="l02282"></a>02282          }
<a name="l02283"></a>02283          this-&gt;priv_size_traits().set_size(this-&gt;priv_size_traits().get_size()-num_erased);
<a name="l02284"></a>02284       }
<a name="l02285"></a>02285    }
<a name="l02286"></a>02286 
<a name="l02287"></a>02287    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Disposer&gt;
<a name="l02288"></a>02288    <span class="keywordtype">void</span> priv_erase_range_impl
<a name="l02289"></a>02289       (size_type first_bucket_num, size_type num_buckets, Disposer disposer, size_type &amp;num_erased)
<a name="l02290"></a>02290    {
<a name="l02291"></a>02291       <span class="comment">//Now fully clear the intermediate buckets</span>
<a name="l02292"></a>02292       <span class="keyword">const</span> bucket_ptr buckets = priv_buckets();
<a name="l02293"></a>02293       num_erased = 0;
<a name="l02294"></a>02294       <span class="keywordflow">for</span>(size_type i = first_bucket_num; i &lt; (num_buckets + first_bucket_num); ++i){
<a name="l02295"></a>02295          bucket_type &amp;b = buckets[i];
<a name="l02296"></a>02296          siterator b_begin(b.before_begin());
<a name="l02297"></a>02297          siterator nxt(b_begin);
<a name="l02298"></a>02298          ++nxt;
<a name="l02299"></a>02299          siterator <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a3bb26f838e8c85730ae98204134fd813">end</a>(b.end());
<a name="l02300"></a>02300          <span class="keywordflow">while</span>(nxt != end){
<a name="l02301"></a>02301             priv_init_group(nxt.pointed_node(), optimize_multikey_t());
<a name="l02302"></a>02302             nxt = b.erase_after_and_dispose
<a name="l02303"></a>02303                (b_begin, make_node_disposer(disposer));
<a name="l02304"></a>02304             this-&gt;priv_size_traits().decrement();
<a name="l02305"></a>02305             ++num_erased;
<a name="l02306"></a>02306          }
<a name="l02307"></a>02307       }
<a name="l02308"></a>02308    }
<a name="l02309"></a>02309 
<a name="l02310"></a>02310    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Disposer&gt;
<a name="l02311"></a>02311    <span class="keywordtype">void</span> priv_erase_range( siterator before_first_it,  size_type first_bucket
<a name="l02312"></a>02312                         , siterator last_it,          size_type last_bucket
<a name="l02313"></a>02313                         , Disposer disposer)
<a name="l02314"></a>02314    {
<a name="l02315"></a>02315       size_type num_erased;
<a name="l02316"></a>02316       <span class="keywordflow">if</span> (first_bucket == last_bucket){
<a name="l02317"></a>02317          priv_erase_range_impl(first_bucket, before_first_it, last_it, disposer, num_erased);
<a name="l02318"></a>02318       }
<a name="l02319"></a>02319       <span class="keywordflow">else</span> {
<a name="l02320"></a>02320          bucket_type *b = (&amp;this-&gt;priv_buckets()[0]);
<a name="l02321"></a>02321          priv_erase_range_impl(first_bucket, before_first_it, b[first_bucket].<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a3bb26f838e8c85730ae98204134fd813">end</a>(), disposer, num_erased);
<a name="l02322"></a>02322          <span class="keywordflow">if</span>(size_type n = (last_bucket - first_bucket - 1))
<a name="l02323"></a>02323             priv_erase_range_impl(first_bucket + 1, n, disposer, num_erased);
<a name="l02324"></a>02324          priv_erase_range_impl(last_bucket, b[last_bucket].before_begin(), last_it, disposer, num_erased);
<a name="l02325"></a>02325       }
<a name="l02326"></a>02326    }
<a name="l02327"></a>02327 
<a name="l02328"></a>02328    <span class="keyword">static</span> node_ptr dcast_bucket_ptr(<span class="keyword">typename</span> slist_impl::node_ptr p)
<a name="l02329"></a>02329    {
<a name="l02330"></a>02330       using ::boost::static_pointer_cast;
<a name="l02331"></a>02331       <span class="keywordflow">return</span> static_pointer_cast&lt;node&gt;(p);
<a name="l02332"></a>02332    }
<a name="l02333"></a>02333 
<a name="l02334"></a>02334    std::size_t priv_stored_or_compute_hash(<span class="keyword">const</span> value_type &amp;v, detail::true_)<span class="keyword"> const</span>
<a name="l02335"></a>02335 <span class="keyword">   </span>{  <span class="keywordflow">return</span> node_traits::get_hash(this-&gt;get_real_value_traits().to_node_ptr(v));  }
<a name="l02336"></a>02336 
<a name="l02337"></a>02337    std::size_t priv_stored_or_compute_hash(<span class="keyword">const</span> value_type &amp;v, detail::false_)<span class="keyword"> const</span>
<a name="l02338"></a>02338 <span class="keyword">   </span>{  <span class="keywordflow">return</span> priv_hasher()(v);   }
<a name="l02339"></a>02339 
<a name="l02340"></a>02340    std::size_t priv_stored_hash(slist_node_ptr n, detail::true_)<span class="keyword"> const</span>
<a name="l02341"></a>02341 <span class="keyword">   </span>{  <span class="keywordflow">return</span> node_traits::get_hash(dcast_bucket_ptr(n));  }
<a name="l02342"></a>02342 
<a name="l02343"></a>02343    std::size_t priv_stored_hash(slist_node_ptr, detail::false_)<span class="keyword"> const</span>
<a name="l02344"></a>02344 <span class="keyword">   </span>{
<a name="l02345"></a>02345       <span class="comment">//This code should never be reached!</span>
<a name="l02346"></a>02346       BOOST_INTRUSIVE_INVARIANT_ASSERT(0);
<a name="l02347"></a>02347       <span class="keywordflow">return</span> 0;
<a name="l02348"></a>02348    }
<a name="l02349"></a>02349 
<a name="l02350"></a>02350    <span class="keyword">static</span> <span class="keywordtype">void</span> priv_store_hash(node_ptr p, std::size_t h, detail::true_)
<a name="l02351"></a>02351    {  <span class="keywordflow">return</span> node_traits::set_hash(p, h); }
<a name="l02352"></a>02352 
<a name="l02353"></a>02353    <span class="keyword">static</span> <span class="keywordtype">void</span> priv_store_hash(node_ptr, std::size_t, detail::false_)
<a name="l02354"></a>02354    {}
<a name="l02355"></a>02355 
<a name="l02356"></a>02356    <span class="keyword">static</span> <span class="keywordtype">void</span> priv_clear_group_nodes(bucket_type &amp;b, detail::true_)
<a name="l02357"></a>02357    {
<a name="l02358"></a>02358       siterator it(b.begin()), itend(b.end());
<a name="l02359"></a>02359       <span class="keywordflow">while</span>(it != itend){
<a name="l02360"></a>02360          node_ptr to_erase(dcast_bucket_ptr(it.pointed_node()));
<a name="l02361"></a>02361          ++it;
<a name="l02362"></a>02362          group_algorithms::init(to_erase);
<a name="l02363"></a>02363       }
<a name="l02364"></a>02364    }
<a name="l02365"></a>02365 
<a name="l02366"></a>02366    <span class="keyword">static</span> <span class="keywordtype">void</span> priv_clear_group_nodes(bucket_type &amp;, detail::false_)
<a name="l02367"></a>02367    {}
<a name="l02368"></a>02368 
<a name="l02369"></a>02369    std::size_t priv_get_bucket_num(siterator it)
<a name="l02370"></a>02370    {  <span class="keywordflow">return</span> priv_get_bucket_num_hash_dispatch(it, store_hash_t());  }
<a name="l02371"></a>02371 
<a name="l02372"></a>02372    std::size_t priv_get_bucket_num_hash_dispatch(siterator it, detail::true_)
<a name="l02373"></a>02373    {
<a name="l02374"></a>02374       <span class="keywordflow">return</span> this-&gt;priv_hash_to_bucket
<a name="l02375"></a>02375          (this-&gt;priv_stored_hash(it.pointed_node(), store_hash_t()));
<a name="l02376"></a>02376    }
<a name="l02377"></a>02377 
<a name="l02378"></a>02378    std::size_t priv_get_bucket_num_hash_dispatch(siterator it, detail::false_)
<a name="l02379"></a>02379    {  <span class="keywordflow">return</span> priv_get_bucket_num_no_hash_store(it, optimize_multikey_t());  }
<a name="l02380"></a>02380 
<a name="l02381"></a>02381    std::size_t priv_get_bucket_num_no_hash_store(siterator it, detail::true_)
<a name="l02382"></a>02382    {
<a name="l02383"></a>02383       bucket_ptr f(priv_buckets()), l(f + priv_buckets_len() - 1);
<a name="l02384"></a>02384       slist_node_ptr bb = group_functions_t::priv_get_bucket_before_begin
<a name="l02385"></a>02385          ( f-&gt;end().pointed_node()
<a name="l02386"></a>02386          , l-&gt;end().pointed_node()
<a name="l02387"></a>02387          , dcast_bucket_ptr(it.pointed_node()));
<a name="l02388"></a>02388       <span class="comment">//Now get the bucket_impl from the iterator</span>
<a name="l02389"></a>02389       <span class="keyword">const</span> bucket_type &amp;b = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>bucket_type&amp;<span class="keyword">&gt;</span>
<a name="l02390"></a>02390          (bucket_type::slist_type::container_from_end_iterator(bucket_type::s_iterator_to(*bb)));
<a name="l02391"></a>02391       <span class="comment">//Now just calculate the index b has in the bucket array</span>
<a name="l02392"></a>02392       <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>size_type<span class="keyword">&gt;</span>(&amp;b - &amp;*f);
<a name="l02393"></a>02393    }
<a name="l02394"></a>02394 
<a name="l02395"></a>02395    std::size_t priv_get_bucket_num_no_hash_store(siterator it, detail::false_)
<a name="l02396"></a>02396    {
<a name="l02397"></a>02397       bucket_ptr f(priv_buckets()), l(f + priv_buckets_len() - 1);
<a name="l02398"></a>02398       slist_node_ptr first_ptr(f-&gt;cend().pointed_node())
<a name="l02399"></a>02399                    , last_ptr(l-&gt;cend().pointed_node());
<a name="l02400"></a>02400 
<a name="l02401"></a>02401       <span class="comment">//The end node is embedded in the singly linked list:</span>
<a name="l02402"></a>02402       <span class="comment">//iterate until we reach it.</span>
<a name="l02403"></a>02403       <span class="keywordflow">while</span>(!(first_ptr &lt;= it.pointed_node() &amp;&amp; it.pointed_node() &lt;= last_ptr)){
<a name="l02404"></a>02404          ++it;
<a name="l02405"></a>02405       }
<a name="l02406"></a>02406       <span class="comment">//Now get the bucket_impl from the iterator</span>
<a name="l02407"></a>02407       <span class="keyword">const</span> bucket_type &amp;b = <span class="keyword">static_cast&lt;</span><span class="keyword">const </span>bucket_type&amp;<span class="keyword">&gt;</span>
<a name="l02408"></a>02408          (bucket_type::container_from_end_iterator(it));
<a name="l02409"></a>02409 
<a name="l02410"></a>02410       <span class="comment">//Now just calculate the index b has in the bucket array</span>
<a name="l02411"></a>02411       <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>std::size_t<span class="keyword">&gt;</span>(&amp;b - &amp;*f);
<a name="l02412"></a>02412    }
<a name="l02413"></a>02413 
<a name="l02414"></a>02414    <span class="keywordtype">void</span> priv_init_group(slist_node_ptr n, detail::true_)
<a name="l02415"></a>02415    {  group_algorithms::init(dcast_bucket_ptr(n)); }
<a name="l02416"></a>02416 
<a name="l02417"></a>02417    <span class="keywordtype">void</span> priv_init_group(slist_node_ptr, detail::false_)
<a name="l02418"></a>02418    {}
<a name="l02419"></a>02419 
<a name="l02420"></a>02420    <span class="keywordtype">void</span> priv_insert_in_group(node_ptr first_in_group, node_ptr n, detail::true_)
<a name="l02421"></a>02421    {
<a name="l02422"></a>02422       <span class="keywordflow">if</span>(first_in_group){
<a name="l02423"></a>02423          <span class="keywordflow">if</span>(group_algorithms::unique(first_in_group))
<a name="l02424"></a>02424             group_algorithms::link_after(first_in_group, n);
<a name="l02425"></a>02425          <span class="keywordflow">else</span>{
<a name="l02426"></a>02426             group_algorithms::link_after(node_traits::get_next(first_in_group), n);
<a name="l02427"></a>02427          }
<a name="l02428"></a>02428       }
<a name="l02429"></a>02429       <span class="keywordflow">else</span>{
<a name="l02430"></a>02430          group_algorithms::init_header(n);
<a name="l02431"></a>02431       }
<a name="l02432"></a>02432    }
<a name="l02433"></a>02433 
<a name="l02434"></a>02434    <span class="keywordtype">void</span> priv_insert_in_group(node_ptr, node_ptr, detail::false_)
<a name="l02435"></a>02435    {}
<a name="l02436"></a>02436 
<a name="l02437"></a>02437    siterator priv_get_previous
<a name="l02438"></a>02438       (bucket_type &amp;b, siterator i)
<a name="l02439"></a>02439    {  <span class="keywordflow">return</span> priv_get_previous(b, i, optimize_multikey_t());   }
<a name="l02440"></a>02440 
<a name="l02441"></a>02441    siterator priv_get_previous
<a name="l02442"></a>02442       (bucket_type &amp;b, siterator i, detail::true_)
<a name="l02443"></a>02443    {
<a name="l02444"></a>02444       node_ptr elem(dcast_bucket_ptr(i.pointed_node()));
<a name="l02445"></a>02445       node_ptr prev_in_group(group_traits::get_next(elem));
<a name="l02446"></a>02446       <span class="keywordtype">bool</span> first_in_group = node_traits::get_next(prev_in_group) != elem;
<a name="l02447"></a>02447       <span class="keyword">typename</span> bucket_type::node &amp;n = first_in_group
<a name="l02448"></a>02448          ? *group_functions_t::priv_get_prev_to_first_in_group(b.end().pointed_node(), elem)
<a name="l02449"></a>02449          : *group_traits::get_next(elem)
<a name="l02450"></a>02450          ;
<a name="l02451"></a>02451       <span class="keywordflow">return</span> bucket_type::s_iterator_to(n);
<a name="l02452"></a>02452    }
<a name="l02453"></a>02453 
<a name="l02454"></a>02454    siterator priv_get_previous
<a name="l02455"></a>02455       (bucket_type &amp;b, siterator i, detail::false_)
<a name="l02456"></a>02456    {  <span class="keywordflow">return</span> b.previous(i);   }
<a name="l02457"></a>02457 
<a name="l02458"></a>02458    <span class="keyword">static</span> siterator priv_get_last(bucket_type &amp;b)
<a name="l02459"></a>02459    {  <span class="keywordflow">return</span> priv_get_last(b, optimize_multikey_t());  }
<a name="l02460"></a>02460 
<a name="l02461"></a>02461    <span class="keyword">static</span> siterator priv_get_last(bucket_type &amp;b, detail::true_)
<a name="l02462"></a>02462    {
<a name="l02463"></a>02463       <span class="comment">//First find the last node of p&#39;s group.</span>
<a name="l02464"></a>02464       <span class="comment">//This requires checking the first node of the next group or</span>
<a name="l02465"></a>02465       <span class="comment">//the bucket node.</span>
<a name="l02466"></a>02466       slist_node_ptr end_ptr(b.end().pointed_node());
<a name="l02467"></a>02467       node_ptr possible_end(node_traits::get_next( dcast_bucket_ptr(end_ptr)));
<a name="l02468"></a>02468       node_ptr last_node_group(possible_end);
<a name="l02469"></a>02469 
<a name="l02470"></a>02470       <span class="keywordflow">while</span>(end_ptr != possible_end){
<a name="l02471"></a>02471          last_node_group   = group_traits::get_next(dcast_bucket_ptr(possible_end));
<a name="l02472"></a>02472          possible_end      = node_traits::get_next(last_node_group);
<a name="l02473"></a>02473       }
<a name="l02474"></a>02474       <span class="keywordflow">return</span> bucket_type::s_iterator_to(*last_node_group);
<a name="l02475"></a>02475    }
<a name="l02476"></a>02476 
<a name="l02477"></a>02477    <span class="keyword">static</span> siterator priv_get_last(bucket_type &amp;b, detail::false_)
<a name="l02478"></a>02478    {  <span class="keywordflow">return</span> b.previous(b.end());   }
<a name="l02479"></a>02479 
<a name="l02480"></a>02480    siterator priv_get_previous_and_next_in_group
<a name="l02481"></a>02481       (siterator i, node_ptr &amp;nxt_in_group)
<a name="l02482"></a>02482    {
<a name="l02483"></a>02483       siterator prev;
<a name="l02484"></a>02484       node_ptr elem(dcast_bucket_ptr(i.pointed_node()));
<a name="l02485"></a>02485       bucket_ptr f(priv_buckets()), l(f + priv_buckets_len() - 1);
<a name="l02486"></a>02486 
<a name="l02487"></a>02487       slist_node_ptr first_end_ptr(f-&gt;cend().pointed_node());
<a name="l02488"></a>02488       slist_node_ptr last_end_ptr (l-&gt;cend().pointed_node());
<a name="l02489"></a>02489 
<a name="l02490"></a>02490       node_ptr nxt(node_traits::get_next(elem));
<a name="l02491"></a>02491       node_ptr prev_in_group(group_traits::get_next(elem));
<a name="l02492"></a>02492       <span class="keywordtype">bool</span> last_in_group = (first_end_ptr &lt;= nxt &amp;&amp; nxt &lt;= last_end_ptr) ||
<a name="l02493"></a>02493                             (group_traits::get_next(nxt) != elem);
<a name="l02494"></a>02494       <span class="keywordtype">bool</span> first_in_group = node_traits::get_next(prev_in_group) != elem;
<a name="l02495"></a>02495       
<a name="l02496"></a>02496       <span class="keywordflow">if</span>(first_in_group){
<a name="l02497"></a>02497          node_ptr start_pos;
<a name="l02498"></a>02498          <span class="keywordflow">if</span>(last_in_group){
<a name="l02499"></a>02499             start_pos = elem;
<a name="l02500"></a>02500             nxt_in_group = 0;
<a name="l02501"></a>02501          }
<a name="l02502"></a>02502          <span class="keywordflow">else</span>{
<a name="l02503"></a>02503             start_pos = prev_in_group;
<a name="l02504"></a>02504             nxt_in_group = node_traits::get_next(elem);
<a name="l02505"></a>02505          }
<a name="l02506"></a>02506          slist_node_ptr bucket_node;
<a name="l02507"></a>02507          <span class="keywordflow">if</span>(store_hash){
<a name="l02508"></a>02508             bucket_node = this-&gt;priv_buckets()
<a name="l02509"></a>02509                [this-&gt;priv_hash_to_bucket
<a name="l02510"></a>02510                   (this-&gt;priv_stored_hash(elem, store_hash_t()))
<a name="l02511"></a>02511                ].before_begin().pointed_node();
<a name="l02512"></a>02512          }
<a name="l02513"></a>02513          <span class="keywordflow">else</span>{
<a name="l02514"></a>02514             bucket_node = group_functions_t::priv_get_bucket_before_begin
<a name="l02515"></a>02515                   (first_end_ptr, last_end_ptr, start_pos);
<a name="l02516"></a>02516          }
<a name="l02517"></a>02517          prev = bucket_type::s_iterator_to
<a name="l02518"></a>02518             (*group_functions_t::priv_get_prev_to_first_in_group(bucket_node, elem));
<a name="l02519"></a>02519       }
<a name="l02520"></a>02520       <span class="keywordflow">else</span>{
<a name="l02521"></a>02521          <span class="keywordflow">if</span>(last_in_group){
<a name="l02522"></a>02522             nxt_in_group = group_functions_t::priv_get_first_in_group_of_last_in_group(elem);
<a name="l02523"></a>02523          }
<a name="l02524"></a>02524          <span class="keywordflow">else</span>{
<a name="l02525"></a>02525             nxt_in_group = node_traits::get_next(elem);
<a name="l02526"></a>02526          }
<a name="l02527"></a>02527          prev = bucket_type::s_iterator_to(*group_traits::get_next(elem));
<a name="l02528"></a>02528       }
<a name="l02529"></a>02529       <span class="keywordflow">return</span> prev;
<a name="l02530"></a>02530    }
<a name="l02531"></a>02531 
<a name="l02532"></a>02532    <span class="keyword">template</span>&lt;<span class="keyword">class</span> Disposer&gt;
<a name="l02533"></a>02533    <span class="keywordtype">void</span> priv_erase(const_iterator i, Disposer disposer, detail::true_)
<a name="l02534"></a>02534    {
<a name="l02535"></a>02535       siterator elem(i.slist_it());
<a name="l02536"></a>02536       node_ptr nxt_in_group;
<a name="l02537"></a>02537       siterator prev = priv_get_previous_and_next_in_group(elem, nxt_in_group);
<a name="l02538"></a>02538       bucket_type::s_erase_after_and_dispose(prev, make_node_disposer(disposer));
<a name="l02539"></a>02539       <span class="keywordflow">if</span>(nxt_in_group)
<a name="l02540"></a>02540          group_algorithms::unlink_after(nxt_in_group);
<a name="l02541"></a>02541       <span class="keywordflow">if</span>(safemode_or_autounlink)
<a name="l02542"></a>02542          group_algorithms::init(dcast_bucket_ptr(elem.pointed_node()));
<a name="l02543"></a>02543    }
<a name="l02544"></a>02544 
<a name="l02545"></a>02545    <span class="keyword">template</span> &lt;<span class="keyword">class</span> Disposer&gt;
<a name="l02546"></a>02546    <span class="keywordtype">void</span> priv_erase(const_iterator i, Disposer disposer, detail::false_)
<a name="l02547"></a>02547    {
<a name="l02548"></a>02548       siterator to_erase(i.slist_it());
<a name="l02549"></a>02549       bucket_type &amp;b = this-&gt;priv_buckets()[this-&gt;priv_get_bucket_num(to_erase)];
<a name="l02550"></a>02550       siterator prev(priv_get_previous(b, to_erase));
<a name="l02551"></a>02551       b.erase_after_and_dispose(prev, make_node_disposer(disposer));
<a name="l02552"></a>02552    }
<a name="l02553"></a>02553 
<a name="l02554"></a>02554    bucket_ptr priv_invalid_bucket()<span class="keyword"> const</span>
<a name="l02555"></a>02555 <span class="keyword">   </span>{
<a name="l02556"></a>02556       <span class="keyword">const</span> real_bucket_traits &amp;rbt = this-&gt;priv_real_bucket_traits();
<a name="l02557"></a>02557       <span class="keywordflow">return</span> rbt.bucket_begin() + rbt.bucket_count();
<a name="l02558"></a>02558    }
<a name="l02559"></a>02559    
<a name="l02560"></a>02560    siterator priv_invalid_local_it()<span class="keyword"> const</span>
<a name="l02561"></a>02561 <span class="keyword">   </span>{  <span class="keywordflow">return</span> priv_invalid_bucket()-&gt;end();  }
<a name="l02562"></a>02562 
<a name="l02563"></a>02563    siterator priv_begin()<span class="keyword"> const</span>
<a name="l02564"></a>02564 <span class="keyword">   </span>{  <span class="keywordflow">return</span> priv_begin(cache_begin_t()); }
<a name="l02565"></a>02565 
<a name="l02566"></a>02566    siterator priv_begin(detail::bool_&lt;false&gt;)<span class="keyword"> const</span>
<a name="l02567"></a>02567 <span class="keyword">   </span>{
<a name="l02568"></a>02568       size_type n = 0;
<a name="l02569"></a>02569       size_type buckets_len = this-&gt;priv_buckets_len();
<a name="l02570"></a>02570       <span class="keywordflow">for</span> (n = 0; n &lt; buckets_len; ++n){
<a name="l02571"></a>02571          bucket_type &amp;b = this-&gt;priv_buckets()[n];
<a name="l02572"></a>02572          <span class="keywordflow">if</span>(!b.empty()){
<a name="l02573"></a>02573             <span class="keywordflow">return</span> b.begin();
<a name="l02574"></a>02574          }
<a name="l02575"></a>02575       }
<a name="l02576"></a>02576       <span class="keywordflow">return</span> priv_invalid_local_it();
<a name="l02577"></a>02577    }
<a name="l02578"></a>02578 
<a name="l02579"></a>02579    siterator priv_begin(detail::bool_&lt;true&gt;)<span class="keyword"> const</span>
<a name="l02580"></a>02580 <span class="keyword">   </span>{
<a name="l02581"></a>02581       <span class="keywordflow">if</span>(this-&gt;data_.internal_.bucket_hash_equal_.cached_begin_ == priv_invalid_bucket()){
<a name="l02582"></a>02582          <span class="keywordflow">return</span> priv_invalid_local_it();
<a name="l02583"></a>02583       }
<a name="l02584"></a>02584       <span class="keywordflow">else</span>{
<a name="l02585"></a>02585          <span class="keywordflow">return</span> this-&gt;data_.internal_.bucket_hash_equal_.cached_begin_-&gt;begin();
<a name="l02586"></a>02586       }
<a name="l02587"></a>02587    }
<a name="l02588"></a>02588 
<a name="l02589"></a>02589    <span class="keywordtype">void</span> priv_initialize_cache()
<a name="l02590"></a>02590    {  priv_initialize_cache(cache_begin_t());   }
<a name="l02591"></a>02591 
<a name="l02592"></a>02592    <span class="keywordtype">void</span> priv_initialize_cache(detail::bool_&lt;true&gt;)
<a name="l02593"></a>02593    {  this-&gt;data_.internal_.bucket_hash_equal_.cached_begin_ = priv_invalid_bucket();  }
<a name="l02594"></a>02594 
<a name="l02595"></a>02595    <span class="keywordtype">void</span> priv_initialize_cache(detail::bool_&lt;false&gt;)
<a name="l02596"></a>02596    {}
<a name="l02597"></a>02597 
<a name="l02598"></a>02598    <span class="keywordtype">void</span> priv_insertion_update_cache(size_type insertion_bucket)
<a name="l02599"></a>02599    {  priv_insertion_update_cache(insertion_bucket, cache_begin_t()); }
<a name="l02600"></a>02600 
<a name="l02601"></a>02601    <span class="keywordtype">void</span> priv_insertion_update_cache(size_type insertion_bucket, detail::bool_&lt;true&gt;)
<a name="l02602"></a>02602    {
<a name="l02603"></a>02603       bucket_ptr p = priv_buckets() + insertion_bucket;
<a name="l02604"></a>02604       <span class="keywordflow">if</span>(p &lt; this-&gt;data_.internal_.bucket_hash_equal_.cached_begin_){
<a name="l02605"></a>02605          this-&gt;data_.internal_.bucket_hash_equal_.cached_begin_ = p;
<a name="l02606"></a>02606       }
<a name="l02607"></a>02607    }
<a name="l02608"></a>02608 
<a name="l02609"></a>02609    <span class="keywordtype">void</span> priv_insertion_update_cache(size_type, detail::bool_&lt;false&gt;)
<a name="l02610"></a>02610    {}
<a name="l02611"></a>02611 
<a name="l02612"></a>02612    <span class="keywordtype">void</span> priv_erasure_update_cache(size_type first_bucket, size_type last_bucket)
<a name="l02613"></a>02613    {  priv_erasure_update_cache(first_bucket, last_bucket, cache_begin_t()); }
<a name="l02614"></a>02614 
<a name="l02615"></a>02615    <span class="keywordtype">void</span> priv_erasure_update_cache(size_type first_bucket_num, size_type last_bucket_num, detail::bool_&lt;true&gt;)
<a name="l02616"></a>02616    {
<a name="l02617"></a>02617       <span class="comment">//If the last bucket is the end, the cache must be updated</span>
<a name="l02618"></a>02618       <span class="comment">//to the last position if all</span>
<a name="l02619"></a>02619       <span class="keywordflow">if</span>(priv_get_cache_bucket_num() == first_bucket_num   &amp;&amp;
<a name="l02620"></a>02620          priv_buckets()[first_bucket_num].<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a70e71ceca07382bd97a45e1d1a1b3b4b">empty</a>()          ){
<a name="l02621"></a>02621          priv_set_cache(priv_buckets() + last_bucket_num);
<a name="l02622"></a>02622          priv_erasure_update_cache();
<a name="l02623"></a>02623       }
<a name="l02624"></a>02624    }
<a name="l02625"></a>02625 
<a name="l02626"></a>02626    <span class="keywordtype">void</span> priv_erasure_update_cache(size_type, size_type, detail::bool_&lt;false&gt;)
<a name="l02627"></a>02627    {}
<a name="l02628"></a>02628 
<a name="l02629"></a>02629    <span class="keywordtype">void</span> priv_erasure_update_cache()
<a name="l02630"></a>02630    {  priv_erasure_update_cache(cache_begin_t()); }
<a name="l02631"></a>02631 
<a name="l02632"></a>02632    <span class="keywordtype">void</span> priv_erasure_update_cache(detail::bool_&lt;true&gt;)
<a name="l02633"></a>02633    {
<a name="l02634"></a>02634       <span class="keywordflow">if</span>(constant_time_size &amp;&amp; !<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#ac6a1412a8d4768b3dc4428b6378a56a3">size</a>()){
<a name="l02635"></a>02635          priv_initialize_cache();
<a name="l02636"></a>02636       }
<a name="l02637"></a>02637       <span class="keywordflow">else</span>{
<a name="l02638"></a>02638          size_type current_n = this-&gt;data_.internal_.bucket_hash_equal_.cached_begin_ - priv_buckets();
<a name="l02639"></a>02639          <span class="keywordflow">for</span>( <span class="keyword">const</span> size_type num_buckets = this-&gt;priv_buckets_len()
<a name="l02640"></a>02640             ; current_n &lt; num_buckets
<a name="l02641"></a>02641             ; ++current_n, ++this-&gt;data_.internal_.bucket_hash_equal_.cached_begin_){
<a name="l02642"></a>02642             <span class="keywordflow">if</span>(!this-&gt;data_.internal_.bucket_hash_equal_.cached_begin_-&gt;empty()){
<a name="l02643"></a>02643                <span class="keywordflow">return</span>;
<a name="l02644"></a>02644             }
<a name="l02645"></a>02645          }
<a name="l02646"></a>02646          priv_initialize_cache();
<a name="l02647"></a>02647       }
<a name="l02648"></a>02648    }
<a name="l02649"></a>02649 
<a name="l02650"></a>02650    <span class="keywordtype">void</span> priv_erasure_update_cache(detail::bool_&lt;false&gt;)
<a name="l02651"></a>02651    {}
<a name="l02652"></a>02652 
<a name="l02653"></a>02653    <span class="keywordtype">void</span> priv_swap_cache(detail::bool_&lt;true&gt;, <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a5f699f562acc743153b66b4020f788f0">hashtable_impl</a> &amp;other)
<a name="l02654"></a>02654    {
<a name="l02655"></a>02655       <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a409d6dc57547168d08264128e9d85d74">std::swap</a>( this-&gt;data_.internal_.bucket_hash_equal_.cached_begin_
<a name="l02656"></a>02656                , other.data_.internal_.bucket_hash_equal_.cached_begin_);
<a name="l02657"></a>02657    }
<a name="l02658"></a>02658 
<a name="l02659"></a>02659    <span class="keywordtype">void</span> priv_swap_cache(detail::bool_&lt;false&gt;, <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a5f699f562acc743153b66b4020f788f0">hashtable_impl</a> &amp;)
<a name="l02660"></a>02660    {}
<a name="l02661"></a>02661 
<a name="l02662"></a>02662    bucket_ptr priv_get_cache()
<a name="l02663"></a>02663    {  <span class="keywordflow">return</span> priv_get_cache(cache_begin_t());   }
<a name="l02664"></a>02664 
<a name="l02665"></a>02665    bucket_ptr priv_get_cache(detail::bool_&lt;true&gt;)
<a name="l02666"></a>02666    {  <span class="keywordflow">return</span> this-&gt;data_.internal_.bucket_hash_equal_.cached_begin_;  }
<a name="l02667"></a>02667 
<a name="l02668"></a>02668    bucket_ptr priv_get_cache(detail::bool_&lt;false&gt;)
<a name="l02669"></a>02669    {  <span class="keywordflow">return</span> this-&gt;priv_buckets();  }
<a name="l02670"></a>02670 
<a name="l02671"></a>02671    <span class="keywordtype">void</span> priv_set_cache(bucket_ptr p)
<a name="l02672"></a>02672    {  priv_set_cache(p, cache_begin_t());   }
<a name="l02673"></a>02673 
<a name="l02674"></a>02674    <span class="keywordtype">void</span> priv_set_cache(bucket_ptr p, detail::bool_&lt;true&gt;)
<a name="l02675"></a>02675    {  this-&gt;data_.internal_.bucket_hash_equal_.cached_begin_ = p;  }
<a name="l02676"></a>02676 
<a name="l02677"></a>02677    <span class="keywordtype">void</span> priv_set_cache(bucket_ptr, detail::bool_&lt;false&gt;)
<a name="l02678"></a>02678    {}
<a name="l02679"></a>02679 
<a name="l02680"></a>02680    size_type priv_get_cache_bucket_num()
<a name="l02681"></a>02681    {  <span class="keywordflow">return</span> priv_get_cache_bucket_num(cache_begin_t());   }
<a name="l02682"></a>02682 
<a name="l02683"></a>02683    size_type priv_get_cache_bucket_num(detail::bool_&lt;true&gt;)
<a name="l02684"></a>02684    {  <span class="keywordflow">return</span> this-&gt;data_.internal_.bucket_hash_equal_.cached_begin_ - this-&gt;priv_buckets();  }
<a name="l02685"></a>02685 
<a name="l02686"></a>02686    size_type priv_get_cache_bucket_num(detail::bool_&lt;false&gt;)
<a name="l02687"></a>02687    {  <span class="keywordflow">return</span> 0u;  }
<a name="l02688"></a>02688 
<a name="l02689"></a>02689    <span class="keywordtype">void</span> priv_clear_buckets()
<a name="l02690"></a>02690    {
<a name="l02691"></a>02691       this-&gt;priv_clear_buckets
<a name="l02692"></a>02692          ( priv_get_cache()
<a name="l02693"></a>02693          , this-&gt;priv_buckets_len() - (priv_get_cache() - priv_buckets()));
<a name="l02694"></a>02694    }
<a name="l02695"></a>02695 
<a name="l02696"></a>02696    <span class="keywordtype">void</span> priv_initialize_buckets()
<a name="l02697"></a>02697    {  this-&gt;priv_clear_buckets(priv_buckets(), this-&gt;priv_buckets_len());  }
<a name="l02698"></a>02698 
<a name="l02699"></a>02699    <span class="keywordtype">void</span> priv_clear_buckets(bucket_ptr buckets_ptr, size_type buckets_len)
<a name="l02700"></a>02700    {
<a name="l02701"></a>02701       <span class="keywordflow">for</span>(; buckets_len--; ++buckets_ptr){
<a name="l02702"></a>02702          <span class="keywordflow">if</span>(safemode_or_autounlink){
<a name="l02703"></a>02703             priv_clear_group_nodes(*buckets_ptr, optimize_multikey_t());
<a name="l02704"></a>02704             buckets_ptr-&gt;clear_and_dispose(detail::init_disposer&lt;node_algorithms&gt;());
<a name="l02705"></a>02705          }
<a name="l02706"></a>02706          <span class="keywordflow">else</span>{
<a name="l02707"></a>02707             buckets_ptr-&gt;clear();
<a name="l02708"></a>02708          }
<a name="l02709"></a>02709       }
<a name="l02710"></a>02710       priv_initialize_cache();
<a name="l02711"></a>02711    }
<a name="l02712"></a>02712 
<a name="l02713"></a>02713    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyHasher, <span class="keyword">class</span> KeyValueEqual&gt;
<a name="l02714"></a>02714    siterator priv_find
<a name="l02715"></a>02715       ( <span class="keyword">const</span> KeyType &amp;key,  KeyHasher hash_func
<a name="l02716"></a>02716       , KeyValueEqual equal_func, size_type &amp;bucket_number, std::size_t &amp;h, siterator &amp;previt)<span class="keyword"> const</span>
<a name="l02717"></a>02717 <span class="keyword">   </span>{
<a name="l02718"></a>02718       h = hash_func(key);
<a name="l02719"></a>02719       <span class="keywordflow">return</span> priv_find_with_hash(key, equal_func, bucket_number, h, previt);
<a name="l02720"></a>02720    }
<a name="l02721"></a>02721 
<a name="l02722"></a>02722    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyValueEqual&gt;
<a name="l02723"></a>02723    siterator priv_find_with_hash
<a name="l02724"></a>02724       ( <span class="keyword">const</span> KeyType &amp;key, KeyValueEqual equal_func, size_type &amp;bucket_number, <span class="keyword">const</span> std::size_t h, siterator &amp;previt)<span class="keyword"> const</span>
<a name="l02725"></a>02725 <span class="keyword">   </span>{
<a name="l02726"></a>02726       bucket_number = priv_hash_to_bucket(h);
<a name="l02727"></a>02727       bucket_type &amp;b = this-&gt;priv_buckets()[bucket_number];
<a name="l02728"></a>02728       previt = b.before_begin();
<a name="l02729"></a>02729       <span class="keywordflow">if</span>(constant_time_size &amp;&amp; this-&gt;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a70e71ceca07382bd97a45e1d1a1b3b4b">empty</a>()){
<a name="l02730"></a>02730          <span class="keywordflow">return</span> priv_invalid_local_it();
<a name="l02731"></a>02731       }
<a name="l02732"></a>02732       
<a name="l02733"></a>02733       siterator it = previt;
<a name="l02734"></a>02734       ++it;
<a name="l02735"></a>02735 
<a name="l02736"></a>02736       <span class="keywordflow">while</span>(it != b.end()){
<a name="l02737"></a>02737          <span class="keyword">const</span> value_type &amp;v = priv_value_from_slist_node(it.pointed_node());
<a name="l02738"></a>02738          <span class="keywordflow">if</span>(compare_hash){
<a name="l02739"></a>02739             std::size_t vh = this-&gt;priv_stored_or_compute_hash(v, store_hash_t());
<a name="l02740"></a>02740             <span class="keywordflow">if</span>(h == vh &amp;&amp; equal_func(key, v)){
<a name="l02741"></a>02741                <span class="keywordflow">return</span> it;
<a name="l02742"></a>02742             }
<a name="l02743"></a>02743          }
<a name="l02744"></a>02744          <span class="keywordflow">else</span> <span class="keywordflow">if</span>(equal_func(key, v)){
<a name="l02745"></a>02745             <span class="keywordflow">return</span> it;
<a name="l02746"></a>02746          }
<a name="l02747"></a>02747          <span class="keywordflow">if</span>(optimize_multikey){
<a name="l02748"></a>02748             previt = bucket_type::s_iterator_to
<a name="l02749"></a>02749                (*group_functions_t::priv_get_last_in_group
<a name="l02750"></a>02750                   (dcast_bucket_ptr(it.pointed_node()), optimize_multikey_t()));
<a name="l02751"></a>02751             it = previt;
<a name="l02752"></a>02752          }
<a name="l02753"></a>02753          <span class="keywordflow">else</span>{
<a name="l02754"></a>02754             previt = it;
<a name="l02755"></a>02755          }
<a name="l02756"></a>02756          ++it;
<a name="l02757"></a>02757       }
<a name="l02758"></a>02758       previt = b.before_begin();
<a name="l02759"></a>02759       <span class="keywordflow">return</span> priv_invalid_local_it();
<a name="l02760"></a>02760    }
<a name="l02761"></a>02761 
<a name="l02762"></a>02762    iterator priv_insert_equal_with_hash(reference value, std::size_t hash_value)
<a name="l02763"></a>02763    {
<a name="l02764"></a>02764       size_type bucket_num;
<a name="l02765"></a>02765       siterator prev;
<a name="l02766"></a>02766       siterator it = this-&gt;priv_find_with_hash
<a name="l02767"></a>02767          (value, this-&gt;priv_equal(), bucket_num, hash_value, prev);
<a name="l02768"></a>02768       <span class="keywordflow">return</span> priv_insert_equal_find(value, bucket_num, hash_value, it);
<a name="l02769"></a>02769    }
<a name="l02770"></a>02770 
<a name="l02771"></a>02771    iterator priv_insert_equal_find(reference value, size_type bucket_num, std::size_t hash_value, siterator it)
<a name="l02772"></a>02772    {
<a name="l02773"></a>02773       bucket_type &amp;b = this-&gt;priv_buckets()[bucket_num];
<a name="l02774"></a>02774       <span class="keywordtype">bool</span> found_equal = it != priv_invalid_local_it();
<a name="l02775"></a>02775       <span class="keywordflow">if</span>(!found_equal){
<a name="l02776"></a>02776          it = b.before_begin();
<a name="l02777"></a>02777       }
<a name="l02778"></a>02778       <span class="comment">//Now store hash if needed</span>
<a name="l02779"></a>02779       node_ptr n = node_ptr(&amp;priv_value_to_node(value));
<a name="l02780"></a>02780       this-&gt;priv_store_hash(n, hash_value, store_hash_t());
<a name="l02781"></a>02781       <span class="comment">//Checks for some modes</span>
<a name="l02782"></a>02782       <span class="keywordflow">if</span>(safemode_or_autounlink)
<a name="l02783"></a>02783          BOOST_INTRUSIVE_SAFE_HOOK_DEFAULT_ASSERT(node_algorithms::unique(n));
<a name="l02784"></a>02784       <span class="comment">//Shorcut for optimize_multikey cases</span>
<a name="l02785"></a>02785       <span class="keywordflow">if</span>(optimize_multikey){
<a name="l02786"></a>02786          node_ptr first_in_group = found_equal ?
<a name="l02787"></a>02787             dcast_bucket_ptr(it.pointed_node()) : node_ptr(0);
<a name="l02788"></a>02788          this-&gt;priv_insert_in_group(first_in_group, n, optimize_multikey_t());
<a name="l02789"></a>02789       }
<a name="l02790"></a>02790       <span class="comment">//Update cache and increment size if needed</span>
<a name="l02791"></a>02791       priv_insertion_update_cache(bucket_num);
<a name="l02792"></a>02792       this-&gt;priv_size_traits().increment();
<a name="l02793"></a>02793       <span class="comment">//Insert the element in the bucket after it</span>
<a name="l02794"></a>02794       <span class="keywordflow">return</span> iterator(b.insert_after(it, *n), <span class="keyword">this</span>);
<a name="l02795"></a>02795    }
<a name="l02796"></a>02796 
<a name="l02797"></a>02797    <span class="keyword">template</span>&lt;<span class="keyword">class</span> KeyType, <span class="keyword">class</span> KeyHasher, <span class="keyword">class</span> KeyValueEqual&gt;
<a name="l02798"></a>02798    std::pair&lt;siterator, siterator&gt; priv_equal_range
<a name="l02799"></a>02799       ( <span class="keyword">const</span> KeyType &amp;key
<a name="l02800"></a>02800       , KeyHasher hash_func
<a name="l02801"></a>02801       , KeyValueEqual equal_func
<a name="l02802"></a>02802       , size_type &amp;bucket_number_first
<a name="l02803"></a>02803       , size_type &amp;bucket_number_second
<a name="l02804"></a>02804       , size_type &amp;<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a45a810b8add3071142d41cdb6e33e1dc">count</a>)<span class="keyword"> const</span>
<a name="l02805"></a>02805 <span class="keyword">   </span>{
<a name="l02806"></a>02806       std::size_t h;
<a name="l02807"></a>02807       count = 0;
<a name="l02808"></a>02808       siterator prev;
<a name="l02809"></a>02809       <span class="comment">//Let&#39;s see if the element is present</span>
<a name="l02810"></a>02810       std::pair&lt;siterator, siterator&gt; to_return
<a name="l02811"></a>02811          ( priv_find(key, hash_func, equal_func, bucket_number_first, h, prev)
<a name="l02812"></a>02812          , priv_invalid_local_it());
<a name="l02813"></a>02813       <span class="keywordflow">if</span>(to_return.first == to_return.second){
<a name="l02814"></a>02814          bucket_number_second = bucket_number_first;
<a name="l02815"></a>02815          <span class="keywordflow">return</span> to_return;
<a name="l02816"></a>02816       }
<a name="l02817"></a>02817       <span class="comment">//If it&#39;s present, find the first that it&#39;s not equal in</span>
<a name="l02818"></a>02818       <span class="comment">//the same bucket</span>
<a name="l02819"></a>02819       bucket_type &amp;b = this-&gt;priv_buckets()[bucket_number_first];
<a name="l02820"></a>02820       siterator it = to_return.first;
<a name="l02821"></a>02821       <span class="keywordflow">if</span>(optimize_multikey){
<a name="l02822"></a>02822          to_return.second = bucket_type::s_iterator_to
<a name="l02823"></a>02823             (*node_traits::get_next(group_functions_t::priv_get_last_in_group
<a name="l02824"></a>02824                (dcast_bucket_ptr(it.pointed_node()), optimize_multikey_t())));
<a name="l02825"></a>02825          count = std::distance(it, to_return.second);
<a name="l02826"></a>02826          <span class="keywordflow">if</span>(to_return.second !=  b.end()){
<a name="l02827"></a>02827             bucket_number_second = bucket_number_first;
<a name="l02828"></a>02828             <span class="keywordflow">return</span> to_return;
<a name="l02829"></a>02829          }
<a name="l02830"></a>02830       }
<a name="l02831"></a>02831       <span class="keywordflow">else</span>{
<a name="l02832"></a>02832          ++<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a45a810b8add3071142d41cdb6e33e1dc">count</a>;
<a name="l02833"></a>02833          ++it;
<a name="l02834"></a>02834          <span class="keywordflow">while</span>(it != b.end()){
<a name="l02835"></a>02835             <span class="keyword">const</span> value_type &amp;v = priv_value_from_slist_node(it.pointed_node());
<a name="l02836"></a>02836             <span class="keywordflow">if</span>(compare_hash){
<a name="l02837"></a>02837                std::size_t hv = this-&gt;priv_stored_or_compute_hash(v, store_hash_t());
<a name="l02838"></a>02838                <span class="keywordflow">if</span>(hv != h || !equal_func(key, v)){
<a name="l02839"></a>02839                   to_return.second = it;
<a name="l02840"></a>02840                   bucket_number_second = bucket_number_first;
<a name="l02841"></a>02841                   <span class="keywordflow">return</span> to_return;
<a name="l02842"></a>02842                }
<a name="l02843"></a>02843             }
<a name="l02844"></a>02844             <span class="keywordflow">else</span> <span class="keywordflow">if</span>(!equal_func(key, v)){
<a name="l02845"></a>02845                to_return.second = it;
<a name="l02846"></a>02846                bucket_number_second = bucket_number_first;
<a name="l02847"></a>02847                <span class="keywordflow">return</span> to_return;
<a name="l02848"></a>02848             }
<a name="l02849"></a>02849             ++it;
<a name="l02850"></a>02850             ++<a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html#a45a810b8add3071142d41cdb6e33e1dc">count</a>;
<a name="l02851"></a>02851          }
<a name="l02852"></a>02852       }
<a name="l02853"></a>02853    
<a name="l02854"></a>02854       <span class="comment">//If we reached the end, find the first, non-empty bucket</span>
<a name="l02855"></a>02855       <span class="keywordflow">for</span>(bucket_number_second = bucket_number_first+1
<a name="l02856"></a>02856          ; bucket_number_second != this-&gt;priv_buckets_len()
<a name="l02857"></a>02857          ; ++bucket_number_second){
<a name="l02858"></a>02858          bucket_type &amp;b = this-&gt;priv_buckets()[bucket_number_second];
<a name="l02859"></a>02859          <span class="keywordflow">if</span>(!b.empty()){
<a name="l02860"></a>02860             to_return.second = b.begin();
<a name="l02861"></a>02861             <span class="keywordflow">return</span> to_return;
<a name="l02862"></a>02862          }
<a name="l02863"></a>02863       }
<a name="l02864"></a>02864 
<a name="l02865"></a>02865       <span class="comment">//Otherwise, return the end node</span>
<a name="l02866"></a>02866       to_return.second = priv_invalid_local_it();
<a name="l02867"></a>02867       <span class="keywordflow">return</span> to_return;
<a name="l02868"></a>02868    }
<a name="l02870"></a>02870 };
<a name="l02871"></a>02871 
<a name="l02873"></a>02873 <span class="preprocessor">#if !defined(BOOST_INTRUSIVE_VARIADIC_TEMPLATES)</span>
<a name="l02874"></a>02874 <span class="preprocessor"></span><span class="keyword">template</span> &lt; <span class="keyword">class </span>T
<a name="l02875"></a>02875          , <span class="keywordtype">bool</span> UniqueKeys
<a name="l02876"></a>02876          , <span class="keyword">class </span>O1 = none, <span class="keyword">class </span>O2 = none
<a name="l02877"></a>02877          , <span class="keyword">class </span>O3 = none, <span class="keyword">class </span>O4 = none
<a name="l02878"></a>02878          , <span class="keyword">class </span>O5 = none, <span class="keyword">class </span>O6 = none
<a name="l02879"></a>02879          , <span class="keyword">class </span>O7 = none, <span class="keyword">class </span>O8 = none
<a name="l02880"></a>02880          , <span class="keyword">class </span>O9 = none, <span class="keyword">class </span>O10= none
<a name="l02881"></a>02881          &gt;
<a name="l02882"></a>02882 <span class="preprocessor">#else</span>
<a name="l02883"></a>02883 <span class="preprocessor"></span><span class="keyword">template</span> &lt;<span class="keyword">class </span>T, <span class="keywordtype">bool</span> UniqueKeys, <span class="keyword">class </span>...Options&gt;
<a name="l02884"></a>02884 <span class="preprocessor">#endif</span>
<a name="l02885"></a>02885 <span class="preprocessor"></span><span class="keyword">struct </span>make_hashtable_opt
<a name="l02886"></a>02886 {
<a name="l02887"></a>02887    <span class="keyword">typedef</span> <span class="keyword">typename</span> pack_options
<a name="l02888"></a>02888       &lt; uset_defaults&lt;T&gt;, 
<a name="l02889"></a>02889 <span class="preprocessor">         #if !defined(BOOST_INTRUSIVE_VARIADIC_TEMPLATES)</span>
<a name="l02890"></a>02890 <span class="preprocessor"></span>         O1, O2, O3, O4, O5, O6, O7, O8, O9, O10
<a name="l02891"></a>02891 <span class="preprocessor">         #else</span>
<a name="l02892"></a>02892 <span class="preprocessor"></span>         Options...
<a name="l02893"></a>02893          #endif
<a name="l02894"></a>02894       &gt;::type packed_options;
<a name="l02895"></a>02895 
<a name="l02896"></a>02896    <span class="comment">//Real value traits must be calculated from options</span>
<a name="l02897"></a>02897    <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::get_value_traits
<a name="l02898"></a>02898       &lt;T, <span class="keyword">typename</span> packed_options::value_traits&gt;::type   value_traits;
<a name="l02900"></a>02900    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">bool</span> external_value_traits =
<a name="l02901"></a>02901       detail::external_value_traits_is_true&lt;value_traits&gt;::value;
<a name="l02902"></a>02902    <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::eval_if_c
<a name="l02903"></a>02903       &lt; external_value_traits
<a name="l02904"></a>02904       , detail::eval_value_traits&lt;value_traits&gt;
<a name="l02905"></a>02905       , detail::identity&lt;value_traits&gt;
<a name="l02906"></a>02906       &gt;::type                                            real_value_traits;
<a name="l02907"></a>02907    <span class="keyword">typedef</span> <span class="keyword">typename</span> packed_options::bucket_traits        specified_bucket_traits;   
<a name="l02909"></a>02909 
<a name="l02910"></a>02910    <span class="comment">//Real bucket traits must be calculated from options and calculated value_traits</span>
<a name="l02911"></a>02911    <span class="keyword">typedef</span> <span class="keyword">typename</span> detail::get_slist_impl
<a name="l02912"></a>02912       &lt;<span class="keyword">typename</span> detail::reduced_slist_node_traits
<a name="l02913"></a>02913          &lt;<span class="keyword">typename</span> real_value_traits::node_traits&gt;::type
<a name="l02914"></a>02914       &gt;::type                                            slist_impl;
<a name="l02915"></a>02915 
<a name="l02916"></a>02916    <span class="keyword">typedef</span> <span class="keyword">typename</span>
<a name="l02917"></a>02917       detail::if_c&lt; detail::is_same
<a name="l02918"></a>02918                      &lt; specified_bucket_traits
<a name="l02919"></a>02919                      , default_bucket_traits
<a name="l02920"></a>02920                      &gt;::value
<a name="l02921"></a>02921                   , detail::bucket_traits_impl&lt;slist_impl&gt;
<a name="l02922"></a>02922                   , specified_bucket_traits
<a name="l02923"></a>02923                   &gt;::type                                real_bucket_traits;
<a name="l02924"></a>02924 
<a name="l02925"></a>02925    <span class="keyword">typedef</span> detail::usetopt
<a name="l02926"></a>02926       &lt; value_traits
<a name="l02927"></a>02927       , <span class="keyword">typename</span> packed_options::hash
<a name="l02928"></a>02928       , <span class="keyword">typename</span> packed_options::equal
<a name="l02929"></a>02929       , <span class="keyword">typename</span> packed_options::size_type
<a name="l02930"></a>02930       , real_bucket_traits
<a name="l02931"></a>02931       ,  (std::size_t(UniqueKeys)*detail::hash_bool_flags::unique_keys_pos)
<a name="l02932"></a>02932       |  (std::size_t(packed_options::constant_time_size)*detail::hash_bool_flags::constant_time_size_pos)
<a name="l02933"></a>02933       |  (std::size_t(packed_options::power_2_buckets)*detail::hash_bool_flags::power_2_buckets_pos)
<a name="l02934"></a>02934       |  (std::size_t(packed_options::cache_begin)*detail::hash_bool_flags::cache_begin_pos)
<a name="l02935"></a>02935       |  (std::size_t(packed_options::compare_hash)*detail::hash_bool_flags::compare_hash_pos)
<a name="l02936"></a>02936       |  (std::size_t(packed_options::incremental)*detail::hash_bool_flags::incremental_pos)
<a name="l02937"></a>02937       &gt; type;
<a name="l02938"></a>02938 };
<a name="l02940"></a>02940 
<a name="l02943"></a>02943 <span class="preprocessor">#if defined(BOOST_INTRUSIVE_DOXYGEN_INVOKED) || defined(BOOST_INTRUSIVE_VARIADIC_TEMPLATES)</span>
<a name="l02944"></a>02944 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class </span>T, <span class="keyword">class </span>...Options&gt;
<a name="l02945"></a>02945 <span class="preprocessor">#else</span>
<a name="l02946"></a>02946 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class </span>T, <span class="keyword">class </span>O1 = none, <span class="keyword">class </span>O2 = none
<a name="l02947"></a>02947                 , <span class="keyword">class </span>O3 = none, <span class="keyword">class </span>O4 = none
<a name="l02948"></a>02948                 , <span class="keyword">class </span>O5 = none, <span class="keyword">class </span>O6 = none
<a name="l02949"></a>02949                 , <span class="keyword">class </span>O7 = none, <span class="keyword">class </span>O8 = none
<a name="l02950"></a>02950                 , <span class="keyword">class </span>O9 = none, <span class="keyword">class </span>O10= none
<a name="l02951"></a>02951                 &gt;
<a name="l02952"></a>02952 <span class="preprocessor">#endif</span>
<a name="l02953"></a><a class="code" href="structboost_1_1intrusive_1_1make__hashtable.html">02953</a> <span class="preprocessor"></span><span class="keyword">struct </span><a class="code" href="structboost_1_1intrusive_1_1make__hashtable.html">make_hashtable</a>
<a name="l02954"></a>02954 {
<a name="l02956"></a>02956    <span class="keyword">typedef</span> <a class="code" href="classboost_1_1intrusive_1_1hashtable__impl.html">hashtable_impl</a>
<a name="l02957"></a>02957       &lt;  <span class="keyword">typename</span> make_hashtable_opt
<a name="l02958"></a>02958             &lt;T, <span class="keyword">false</span>, 
<a name="l02959"></a>02959 <span class="preprocessor">            #if !defined(BOOST_INTRUSIVE_VARIADIC_TEMPLATES)</span>
<a name="l02960"></a>02960 <span class="preprocessor"></span>            O1, O2, O3, O4, O5, O6, O7, O8, O9, O10
<a name="l02961"></a>02961 <span class="preprocessor">            #else</span>
<a name="l02962"></a>02962 <span class="preprocessor"></span>            Options...
<a name="l02963"></a>02963             #endif
<a name="l02964"></a>02964          &gt;::type
<a name="l02965"></a>02965       &gt; implementation_defined;
<a name="l02966"></a>02966 
<a name="l02968"></a>02968    <span class="keyword">typedef</span> implementation_defined type;
<a name="l02969"></a>02969 };
<a name="l02970"></a>02970 
<a name="l02971"></a>02971 <span class="preprocessor">#if !defined(BOOST_INTRUSIVE_DOXYGEN_INVOKED)</span>
<a name="l02972"></a>02972 <span class="preprocessor"></span>
<a name="l02973"></a>02973 <span class="preprocessor">#if defined(BOOST_INTRUSIVE_VARIADIC_TEMPLATES)</span>
<a name="l02974"></a>02974 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class </span>T, <span class="keyword">class </span>...Options&gt;
<a name="l02975"></a>02975 <span class="preprocessor">#else</span>
<a name="l02976"></a>02976 <span class="preprocessor"></span><span class="keyword">template</span>&lt;<span class="keyword">class</span> T, <span class="keyword">class</span> O1, <span class="keyword">class</span> O2, <span class="keyword">class</span> O3, <span class="keyword">class</span> O4, <span class="keyword">class</span> O5, <span class="keyword">class</span> O6, <span class="keyword">class</span> O7, <span class="keyword">class</span> O8, <span class="keyword">class</span> O9, <span class="keyword">class</span> O10&gt;
<a name="l02977"></a>02977 <span class="preprocessor">#endif</span>
<a name="l02978"></a><a class="code" href="classboost_1_1intrusive_1_1hashtable.html">02978</a> <span class="preprocessor"></span><span class="keyword">class </span><a class="code" href="classboost_1_1intrusive_1_1hashtable.html">hashtable</a>
<a name="l02979"></a>02979    :  <span class="keyword">public</span> <a class="code" href="structboost_1_1intrusive_1_1make__hashtable.html">make_hashtable</a>&lt;T, 
<a name="l02980"></a>02980          #if !defined(BOOST_INTRUSIVE_VARIADIC_TEMPLATES)
<a name="l02981"></a>02981          O1, O2, O3, O4, O5, O6, O7, O8, O9, O10
<a name="l02982"></a>02982          #else
<a name="l02983"></a>02983          Options...
<a name="l02984"></a>02984          #endif
<a name="l02985"></a>02985          &gt;::type
<a name="l02986"></a>02986 {
<a name="l02987"></a>02987    <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="structboost_1_1intrusive_1_1make__hashtable.html">make_hashtable</a>&lt;T, 
<a name="l02988"></a>02988 <span class="preprocessor">      #if !defined(BOOST_INTRUSIVE_VARIADIC_TEMPLATES)</span>
<a name="l02989"></a>02989 <span class="preprocessor"></span>      O1, O2, O3, O4, O5, O6, O7, O8, O9, O10
<a name="l02990"></a>02990 <span class="preprocessor">      #else</span>
<a name="l02991"></a>02991 <span class="preprocessor"></span>      Options...
<a name="l02992"></a>02992       #endif
<a name="l02993"></a>02993       &gt;::type   Base;
<a name="l02994"></a>02994 
<a name="l02995"></a>02995    <span class="keyword">public</span>:
<a name="l02996"></a>02996    <span class="keyword">typedef</span> <span class="keyword">typename</span> Base::value_traits       value_traits;
<a name="l02997"></a>02997    <span class="keyword">typedef</span> <span class="keyword">typename</span> Base::real_value_traits  real_value_traits;
<a name="l02998"></a>02998    <span class="keyword">typedef</span> <span class="keyword">typename</span> Base::iterator           iterator;
<a name="l02999"></a>02999    <span class="keyword">typedef</span> <span class="keyword">typename</span> Base::const_iterator     const_iterator;
<a name="l03000"></a>03000    <span class="keyword">typedef</span> <span class="keyword">typename</span> Base::bucket_ptr         bucket_ptr;
<a name="l03001"></a>03001    <span class="keyword">typedef</span> <span class="keyword">typename</span> Base::size_type          size_type;
<a name="l03002"></a>03002    <span class="keyword">typedef</span> <span class="keyword">typename</span> Base::hasher             hasher;
<a name="l03003"></a>03003    <span class="keyword">typedef</span> <span class="keyword">typename</span> Base::bucket_traits      bucket_traits;
<a name="l03004"></a>03004    <span class="keyword">typedef</span> <span class="keyword">typename</span> Base::key_equal          key_equal;
<a name="l03005"></a>03005 
<a name="l03006"></a>03006    <span class="comment">//Assert if passed value traits are compatible with the type</span>
<a name="l03007"></a>03007    BOOST_STATIC_ASSERT((<a class="code" href="structboost_1_1intrusive_1_1detail_1_1is__same.html">detail::is_same&lt;typename real_value_traits::value_type, T&gt;::value</a>));
<a name="l03008"></a>03008 
<a name="l03009"></a>03009    <a class="code" href="classboost_1_1intrusive_1_1hashtable.html">hashtable</a> ( <span class="keyword">const</span> bucket_traits &amp;b_traits
<a name="l03010"></a>03010              , <span class="keyword">const</span> hasher &amp; hash_func = hasher()
<a name="l03011"></a>03011              , <span class="keyword">const</span> key_equal &amp;equal_func = key_equal()
<a name="l03012"></a>03012              , <span class="keyword">const</span> value_traits &amp;v_traits = value_traits())
<a name="l03013"></a>03013       :  Base(b_traits, hash_func, equal_func, v_traits)
<a name="l03014"></a>03014    {}
<a name="l03015"></a>03015 };
<a name="l03016"></a>03016 
<a name="l03017"></a>03017 <span class="preprocessor">#endif</span>
<a name="l03018"></a>03018 <span class="preprocessor"></span>
<a name="l03019"></a>03019 } <span class="comment">//namespace intrusive </span>
<a name="l03020"></a>03020 } <span class="comment">//namespace boost </span>
<a name="l03021"></a>03021 
<a name="l03022"></a>03022 <span class="preprocessor">#include &lt;boost/intrusive/detail/config_end.hpp&gt;</span>
<a name="l03023"></a>03023 
<a name="l03024"></a>03024 <span class="preprocessor">#endif //BOOST_INTRUSIVE_HASHTABLE_HPP</span>
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Apr 27 2011 00:50:04 for Nutcracker by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
