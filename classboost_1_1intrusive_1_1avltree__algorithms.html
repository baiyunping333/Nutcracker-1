<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nutcracker: boost::intrusive::avltree_algorithms&lt; NodeTraits &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><b>boost</b>      </li>
      <li><b>intrusive</b>      </li>
      <li><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">avltree_algorithms</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>boost::intrusive::avltree_algorithms&lt; NodeTraits &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="boost::intrusive::avltree_algorithms" -->
<p><code>#include &lt;<a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>&gt;</code></p>

<p><a href="classboost_1_1intrusive_1_1avltree__algorithms-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a255da0fffd75bd874d51d832019dad83"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::node" ref="a255da0fffd75bd874d51d832019dad83" args="" -->
typedef NodeTraits::node&#160;</td><td class="memItemRight" valign="bottom"><b>node</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcb39269597f1acdd5b5a3442eed8d8a"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::node_traits" ref="abcb39269597f1acdd5b5a3442eed8d8a" args="" -->
typedef NodeTraits&#160;</td><td class="memItemRight" valign="bottom"><b>node_traits</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad7d87f3e9dcd66c5d07950ac5e0d9b94"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::node_ptr" ref="ad7d87f3e9dcd66c5d07950ac5e0d9b94" args="" -->
typedef NodeTraits::node_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>node_ptr</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae289373b4c361299c10d4cda8fab6103"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::const_node_ptr" ref="ae289373b4c361299c10d4cda8fab6103" args="" -->
typedef NodeTraits::const_node_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>const_node_ptr</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3ab7bda66db0b154cac5e7e76eae5b2d"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::balance" ref="a3ab7bda66db0b154cac5e7e76eae5b2d" args="" -->
typedef NodeTraits::balance&#160;</td><td class="memItemRight" valign="bottom"><b>balance</b></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
tree_algorithms::insert_commit_data&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a665cb410c60648bda0beebcb4425529a">insert_commit_data</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4fe881adcbc5dcb1c780df33acf3abde"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::begin_node" ref="a4fe881adcbc5dcb1c780df33acf3abde" args="(const_node_ptr header)" -->
static node_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>begin_node</b> (const_node_ptr header)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abd08b1c4fbbd35653ed9980658a0429d"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::end_node" ref="abd08b1c4fbbd35653ed9980658a0429d" args="(const_node_ptr header)" -->
static node_ptr&#160;</td><td class="memItemRight" valign="bottom"><b>end_node</b> (const_node_ptr header)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a370c2b58046648ea3a46436af7c29bc9">swap_tree</a> (node_ptr header1, node_ptr header2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a2b5d024ad06790441c6db3e3d852224d">swap_nodes</a> (node_ptr node1, node_ptr node2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#af11c1753f1070ce074eea234a243c086">swap_nodes</a> (node_ptr node1, node_ptr header1, node_ptr node2, node_ptr header2)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a3a0033dbc2de8c3241d492609f229076">replace_node</a> (node_ptr node_to_be_replaced, node_ptr new_node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a83e08757e9222a631706d9801ca33662">replace_node</a> (node_ptr node_to_be_replaced, node_ptr header, node_ptr new_node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#ada0d25e75a4dc102a4201787fb973f09">unlink</a> (node_ptr node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a8b6d981fedca525fd1267cf6d98e9532">unlink_leftmost_without_rebalance</a> (node_ptr header)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a52c89a7cce0d9a47932baf0dac75a182">unique</a> (const_node_ptr node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a31de2b5cf415163b2b09ed8a66c5e479">count</a> (const_node_ptr node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#ac691942055b31a5c0d829cffb5fe284a">size</a> (const_node_ptr header)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a27203b0933c60cf45795d635cedc8c86">next_node</a> (node_ptr p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a29f8b93619672332ac7c6e81ed110681">prev_node</a> (node_ptr p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#ab4ffe5a1e462b71935fb6278be1578a0">init</a> (node_ptr node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#aff1eb6bd54330f68814ab3fec06dca3f">init_header</a> (node_ptr header)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a02dc37a7c4d5176e5feb0d3ee27e97f9">erase</a> (node_ptr header, node_ptr z)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Cloner , class Disposer &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a277a8b8c968979be53a89816f9b9ee18">clone</a> (const_node_ptr source_header, node_ptr target_header, Cloner cloner, Disposer disposer)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Disposer &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a2f03e0cae0c82049c166f576c9eb7a6d">clear_and_dispose</a> (node_ptr header, Disposer disposer)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KeyType , class KeyNodePtrCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a465fd5b53170cbfeabfe8917058a1090">lower_bound</a> (const_node_ptr header, const KeyType &amp;key, KeyNodePtrCompare comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KeyType , class KeyNodePtrCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a4f808b9edf8de9155e80fe015b27a755">upper_bound</a> (const_node_ptr header, const KeyType &amp;key, KeyNodePtrCompare comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KeyType , class KeyNodePtrCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#abc355c3774b114f940327bc22289930a">find</a> (const_node_ptr header, const KeyType &amp;key, KeyNodePtrCompare comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KeyType , class KeyNodePtrCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static std::pair&lt; node_ptr, <br class="typebreak"/>
node_ptr &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#aeacfaa89bbd66cd437b10eac85d3ed30">equal_range</a> (const_node_ptr header, const KeyType &amp;key, KeyNodePtrCompare comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class NodePtrCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#abecb600f2b10c37cdb2d9963841ad816">insert_equal_upper_bound</a> (node_ptr h, node_ptr new_node, NodePtrCompare comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class NodePtrCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a040c19df27e252cb50c103d39f4b3089">insert_equal_lower_bound</a> (node_ptr h, node_ptr new_node, NodePtrCompare comp)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class NodePtrCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a19ec254ccc3dbb0e8cbd8d6b8b21fd68">insert_equal</a> (node_ptr header, node_ptr hint, node_ptr new_node, NodePtrCompare comp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a8d072143805d08b25dddd2a61cffea64">insert_before</a> (node_ptr header, node_ptr pos, node_ptr new_node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a2359f2e9e64f77f22dbdea53c117bff1">push_back</a> (node_ptr header, node_ptr new_node)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a5921e3c87fcc03ef063a3c30534db09f">push_front</a> (node_ptr header, node_ptr new_node)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KeyType , class KeyNodePtrCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static std::pair&lt; node_ptr, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#adc5f9efddddb617a2c309a38d3b88859">insert_unique_check</a> (const_node_ptr header, const KeyType &amp;key, KeyNodePtrCompare comp, <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a665cb410c60648bda0beebcb4425529a">insert_commit_data</a> &amp;commit_data)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class KeyType , class KeyNodePtrCompare &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">static std::pair&lt; node_ptr, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a03e72716cefad1aab953a506f42f5cab">insert_unique_check</a> (const_node_ptr header, node_ptr hint, const KeyType &amp;key, KeyNodePtrCompare comp, <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a665cb410c60648bda0beebcb4425529a">insert_commit_data</a> &amp;commit_data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#aeeacc69262c098d64ff5de7c8afdc208">insert_unique_commit</a> (node_ptr header, node_ptr new_value, const <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a665cb410c60648bda0beebcb4425529a">insert_commit_data</a> &amp;commit_data)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static node_ptr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a43a00e521c8f7a4bb96c1eca6abdcf03">get_header</a> (node_ptr n)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class NodeTraits&gt;<br/>
 class boost::intrusive::avltree_algorithms&lt; NodeTraits &gt;</h3>

<p><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">avltree_algorithms</a> is configured with a NodeTraits class, which encapsulates the information about the node to be manipulated. NodeTraits must support the following interface:</p>
<p><b>Typedefs</b>:</p>
<p><code>node</code>: The type of the node that forms the circular list</p>
<p><code>node_ptr</code>: A pointer to a node</p>
<p><code>const_node_ptr</code>: A pointer to a const node</p>
<p><code>balance</code>: The type of the balance factor</p>
<p><b>Static functions</b>:</p>
<p><code>static node_ptr get_parent(const_node_ptr n);</code></p>
<p><code>static void set_parent(node_ptr n, node_ptr parent);</code></p>
<p><code>static node_ptr get_left(const_node_ptr n);</code></p>
<p><code>static void set_left(node_ptr n, node_ptr left);</code></p>
<p><code>static node_ptr get_right(const_node_ptr n);</code></p>
<p><code>static void set_right(node_ptr n, node_ptr right);</code></p>
<p><code>static balance get_balance(const_node_ptr n);</code></p>
<p><code>static void set_balance(node_ptr n, balance b);</code></p>
<p><code>static balance negative();</code></p>
<p><code>static balance zero();</code></p>
<p><code>static balance positive();</code> </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00068">68</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="a665cb410c60648bda0beebcb4425529a"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::insert_commit_data" ref="a665cb410c60648bda0beebcb4425529a" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef tree_algorithms::insert_commit_data <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::<a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a665cb410c60648bda0beebcb4425529a">insert_commit_data</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>This type is the information that will be filled by insert_unique_check </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00120">120</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a2f03e0cae0c82049c166f576c9eb7a6d"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::clear_and_dispose" ref="a2f03e0cae0c82049c166f576c9eb7a6d" args="(node_ptr header, Disposer disposer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class Disposer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::clear_and_dispose </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Disposer&#160;</td>
          <td class="paramname"> <em>disposer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: "disposer" must be an object function taking a node_ptr parameter and shouldn't throw.</p>
<p><b>Effects</b>: Empties the target tree calling <code>void disposer::operator()(node_ptr)</code> for every node of the tree except the header.</p>
<p><b>Complexity</b>: Linear to the number of element of the source tree plus the. number of elements of tree target tree when calling this function.</p>
<p><b>Throws</b>: If cloner functor throws. If this happens target nodes are disposed. </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00398">398</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a277a8b8c968979be53a89816f9b9ee18"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::clone" ref="a277a8b8c968979be53a89816f9b9ee18" args="(const_node_ptr source_header, node_ptr target_header, Cloner cloner, Disposer disposer)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class Cloner , class Disposer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::clone </td>
          <td>(</td>
          <td class="paramtype">const_node_ptr&#160;</td>
          <td class="paramname"> <em>source_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>target_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Cloner&#160;</td>
          <td class="paramname"> <em>cloner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Disposer&#160;</td>
          <td class="paramname"> <em>disposer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: "cloner" must be a function object taking a node_ptr and returning a new cloned node of it. "disposer" must take a node_ptr and shouldn't throw.</p>
<p><b>Effects</b>: First empties target tree calling <code>void disposer::operator()(node_ptr)</code> for every node of the tree except the header.</p>
<p>Then, duplicates the entire tree pointed by "source_header" cloning each source node with <code>node_ptr Cloner::operator()(node_ptr)</code> to obtain the nodes of the target tree. If "cloner" throws, the cloned target nodes are disposed using <code>void disposer(node_ptr)</code>.</p>
<p><b>Complexity</b>: Linear to the number of element of the source tree plus the. number of elements of tree target tree when calling this function.</p>
<p><b>Throws</b>: If cloner functor throws. If this happens target nodes are disposed. </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00380">380</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a31de2b5cf415163b2b09ed8a66c5e479"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::count" ref="a31de2b5cf415163b2b09ed8a66c5e479" args="(const_node_ptr node)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static std::size_t <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::count </td>
          <td>(</td>
          <td class="paramtype">const_node_ptr&#160;</td>
          <td class="paramname"> <em>node</em>&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: node is a node of the tree but it's not the header.</p>
<p><b>Effects</b>: Returns the number of nodes of the subtree.</p>
<p><b>Complexity</b>: Linear time.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00280">280</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeacfaa89bbd66cd437b10eac85d3ed30"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::equal_range" ref="aeacfaa89bbd66cd437b10eac85d3ed30" args="(const_node_ptr header, const KeyType &amp;key, KeyNodePtrCompare comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class KeyType , class KeyNodePtrCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static std::pair&lt;node_ptr, node_ptr&gt; <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::equal_range </td>
          <td>(</td>
          <td class="paramtype">const_node_ptr&#160;</td>
          <td class="paramname"> <em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyNodePtrCompare&#160;</td>
          <td class="paramname"> <em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</p>
<p><b>Effects</b>: Returns an a pair of node_ptr delimiting a range containing all elements that are equivalent to "key" according to "comp" or an empty range that indicates the position where those elements would be if they there are no equivalent elements.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: If "comp" throws. </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00465">465</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a02dc37a7c4d5176e5feb0d3ee27e97f9"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::erase" ref="a02dc37a7c4d5176e5feb0d3ee27e97f9" args="(node_ptr header, node_ptr z)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static node_ptr <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: header must be the header of a tree, z a node of that tree and z != header.</p>
<p><b>Effects</b>: Erases node "z" from the tree with header "header".</p>
<p><b>Complexity</b>: Amortized constant time.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00349">349</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abc355c3774b114f940327bc22289930a"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::find" ref="abc355c3774b114f940327bc22289930a" args="(const_node_ptr header, const KeyType &amp;key, KeyNodePtrCompare comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class KeyType , class KeyNodePtrCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static node_ptr <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::find </td>
          <td>(</td>
          <td class="paramtype">const_node_ptr&#160;</td>
          <td class="paramname"> <em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyNodePtrCompare&#160;</td>
          <td class="paramname"> <em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</p>
<p><b>Effects</b>: Returns an node_ptr to the element that is equivalent to "key" according to "comp" or "header" if that element does not exist.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: If "comp" throws. </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00447">447</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a43a00e521c8f7a4bb96c1eca6abdcf03"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::get_header" ref="a43a00e521c8f7a4bb96c1eca6abdcf03" args="(node_ptr n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static node_ptr <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::get_header </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>n</em>&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: "n" must be a node inserted in a tree.</p>
<p><b>Effects</b>: Returns a pointer to the header node of the tree.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00709">709</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab4ffe5a1e462b71935fb6278be1578a0"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::init" ref="ab4ffe5a1e462b71935fb6278be1578a0" args="(node_ptr node)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::init </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>node</em>&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: node must not be part of any tree.</p>
<p><b>Effects</b>: After the function unique(node) == true.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Nodes</b>: If node is inserted in a tree, this function corrupts the tree. </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00322">322</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aff1eb6bd54330f68814ab3fec06dca3f"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::init_header" ref="aff1eb6bd54330f68814ab3fec06dca3f" args="(node_ptr header)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::init_header </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>header</em>&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: node must not be part of any tree.</p>
<p><b>Effects</b>: Initializes the header to represent an empty tree. unique(header) == true.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Nodes</b>: If node is inserted in a tree, this function corrupts the tree. </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00335">335</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8d072143805d08b25dddd2a61cffea64"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::insert_before" ref="a8d072143805d08b25dddd2a61cffea64" args="(node_ptr header, node_ptr pos, node_ptr new_node)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static node_ptr <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::insert_before </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>new_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: "header" must be the header node of a tree. "pos" must be a valid iterator or header (end) node. "pos" must be an iterator pointing to the successor to "new_node" once inserted according to the order of already inserted nodes. This function does not check "pos" and this precondition must be guaranteed by the caller.</p>
<p><b>Effects</b>: Inserts new_node into the tree before "pos".</p>
<p><b>Complexity</b>: Constant-time.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: If "pos" is not the successor of the newly inserted "new_node" tree invariants might be broken. </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00548">548</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a19ec254ccc3dbb0e8cbd8d6b8b21fd68"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::insert_equal" ref="a19ec254ccc3dbb0e8cbd8d6b8b21fd68" args="(node_ptr header, node_ptr hint, node_ptr new_node, NodePtrCompare comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class NodePtrCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static node_ptr <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::insert_equal </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>new_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodePtrCompare&#160;</td>
          <td class="paramname"> <em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: "header" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs. "hint" is node from the "header"'s tree.</p>
<p><b>Effects</b>: Inserts new_node into the tree, using "hint" as a hint to where it will be inserted. If "hint" is the upper_bound the insertion takes constant time (two comparisons in the worst case).</p>
<p><b>Complexity</b>: Logarithmic in general, but it is amortized constant time if new_node is inserted immediately before "hint".</p>
<p><b>Throws</b>: If "comp" throws. </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00526">526</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a040c19df27e252cb50c103d39f4b3089"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::insert_equal_lower_bound" ref="a040c19df27e252cb50c103d39f4b3089" args="(node_ptr h, node_ptr new_node, NodePtrCompare comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class NodePtrCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static node_ptr <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::insert_equal_lower_bound </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>new_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodePtrCompare&#160;</td>
          <td class="paramname"> <em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: "h" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs.</p>
<p><b>Effects</b>: Inserts new_node into the tree before the lower bound according to "comp".</p>
<p><b>Complexity</b>: Average complexity for insert element is at most logarithmic.</p>
<p><b>Throws</b>: If "comp" throws. </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00503">503</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abecb600f2b10c37cdb2d9963841ad816"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::insert_equal_upper_bound" ref="abecb600f2b10c37cdb2d9963841ad816" args="(node_ptr h, node_ptr new_node, NodePtrCompare comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class NodePtrCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static node_ptr <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::insert_equal_upper_bound </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>new_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NodePtrCompare&#160;</td>
          <td class="paramname"> <em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: "h" must be the header node of a tree. NodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares two node_ptrs.</p>
<p><b>Effects</b>: Inserts new_node into the tree before the upper bound according to "comp".</p>
<p><b>Complexity</b>: Average complexity for insert element is at most logarithmic.</p>
<p><b>Throws</b>: If "comp" throws. </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00482">482</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adc5f9efddddb617a2c309a38d3b88859"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::insert_unique_check" ref="adc5f9efddddb617a2c309a38d3b88859" args="(const_node_ptr header, const KeyType &amp;key, KeyNodePtrCompare comp, insert_commit_data &amp;commit_data)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class KeyType , class KeyNodePtrCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static std::pair&lt;node_ptr, bool&gt; <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::insert_unique_check </td>
          <td>(</td>
          <td class="paramtype">const_node_ptr&#160;</td>
          <td class="paramname"> <em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyNodePtrCompare&#160;</td>
          <td class="paramname"> <em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a665cb410c60648bda0beebcb4425529a">insert_commit_data</a> &amp;&#160;</td>
          <td class="paramname"> <em>commit_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares KeyType with a node_ptr.</p>
<p><b>Effects</b>: Checks if there is an equivalent node to "key" in the tree according to "comp" and obtains the needed information to realize a constant-time node insertion if there is no equivalent node.</p>
<p><b>Returns</b>: If there is an equivalent value returns a pair containing a node_ptr to the already present node and false. If there is not equivalent key can be inserted returns true in the returned pair's boolean and fills "commit_data" that is meant to be used with the "insert_commit" function to achieve a constant-time insertion function.</p>
<p><b>Complexity</b>: Average complexity is at most logarithmic.</p>
<p><b>Throws</b>: If "comp" throws.</p>
<p><b>Notes</b>: This function is used to improve performance when constructing a node is expensive and the user does not want to have two equivalent nodes in the tree: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the node and this function offers the possibility to use that part to check if the insertion will be successful.</p>
<p>If the check is successful, the user can construct the node and use "insert_commit" to insert the node in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</p>
<p>"commit_data" remains valid for a subsequent "insert_unique_commit" only if no more objects are inserted or erased from the set. </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00629">629</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a03e72716cefad1aab953a506f42f5cab"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::insert_unique_check" ref="a03e72716cefad1aab953a506f42f5cab" args="(const_node_ptr header, node_ptr hint, const KeyType &amp;key, KeyNodePtrCompare comp, insert_commit_data &amp;commit_data)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class KeyType , class KeyNodePtrCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static std::pair&lt;node_ptr, bool&gt; <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::insert_unique_check </td>
          <td>(</td>
          <td class="paramtype">const_node_ptr&#160;</td>
          <td class="paramname"> <em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>hint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyNodePtrCompare&#160;</td>
          <td class="paramname"> <em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a665cb410c60648bda0beebcb4425529a">insert_commit_data</a> &amp;&#160;</td>
          <td class="paramname"> <em>commit_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. NodePtrCompare compares KeyType with a node_ptr. "hint" is node from the "header"'s tree.</p>
<p><b>Effects</b>: Checks if there is an equivalent node to "key" in the tree according to "comp" using "hint" as a hint to where it should be inserted and obtains the needed information to realize a constant-time node insertion if there is no equivalent node. If "hint" is the upper_bound the function has constant time complexity (two comparisons in the worst case).</p>
<p><b>Returns</b>: If there is an equivalent value returns a pair containing a node_ptr to the already present node and false. If there is not equivalent key can be inserted returns true in the returned pair's boolean and fills "commit_data" that is meant to be used with the "insert_commit" function to achieve a constant-time insertion function.</p>
<p><b>Complexity</b>: Average complexity is at most logarithmic, but it is amortized constant time if new_node should be inserted immediately before "hint".</p>
<p><b>Throws</b>: If "comp" throws.</p>
<p><b>Notes</b>: This function is used to improve performance when constructing a node is expensive and the user does not want to have two equivalent nodes in the tree: if there is an equivalent value the constructed object must be discarded. Many times, the part of the node that is used to impose the order is much cheaper to construct than the node and this function offers the possibility to use that part to check if the insertion will be successful.</p>
<p>If the check is successful, the user can construct the node and use "insert_commit" to insert the node in constant-time. This gives a total logarithmic complexity to the insertion: check(O(log(N)) + commit(O(1)).</p>
<p>"commit_data" remains valid for a subsequent "insert_unique_commit" only if no more objects are inserted or erased from the set. </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00674">674</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aeeacc69262c098d64ff5de7c8afdc208"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::insert_unique_commit" ref="aeeacc69262c098d64ff5de7c8afdc208" args="(node_ptr header, node_ptr new_value, const insert_commit_data &amp;commit_data)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::insert_unique_commit </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>new_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#a665cb410c60648bda0beebcb4425529a">insert_commit_data</a> &amp;&#160;</td>
          <td class="paramname"> <em>commit_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: "header" must be the header node of a tree. "commit_data" must have been obtained from a previous call to "insert_unique_check". No objects should have been inserted or erased from the set between the "insert_unique_check" that filled "commit_data" and the call to "insert_commit".</p>
<p><b>Effects</b>: Inserts new_node in the set using the information obtained from the "commit_data" that a previous "insert_check" filled.</p>
<p><b>Complexity</b>: Constant time.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Notes</b>: This function has only sense if a "insert_unique_check" has been previously executed to fill "commit_data". No value should be inserted or erased between the "insert_check" and "insert_commit" calls. </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00696">696</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a465fd5b53170cbfeabfe8917058a1090"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::lower_bound" ref="a465fd5b53170cbfeabfe8917058a1090" args="(const_node_ptr header, const KeyType &amp;key, KeyNodePtrCompare comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class KeyType , class KeyNodePtrCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static node_ptr <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::lower_bound </td>
          <td>(</td>
          <td class="paramtype">const_node_ptr&#160;</td>
          <td class="paramname"> <em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyNodePtrCompare&#160;</td>
          <td class="paramname"> <em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</p>
<p><b>Effects</b>: Returns an node_ptr to the first element that is not less than "key" according to "comp" or "header" if that element does not exist.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: If "comp" throws. </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00415">415</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a27203b0933c60cf45795d635cedc8c86"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::next_node" ref="a27203b0933c60cf45795d635cedc8c86" args="(node_ptr p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static node_ptr <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::next_node </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>p</em>&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: p is a node from the tree except the header.</p>
<p><b>Effects</b>: Returns the next node of the tree.</p>
<p><b>Complexity</b>: Average constant time.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00300">300</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a29f8b93619672332ac7c6e81ed110681"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::prev_node" ref="a29f8b93619672332ac7c6e81ed110681" args="(node_ptr p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static node_ptr <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::prev_node </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>p</em>&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: p is a node from the tree except the leftmost node.</p>
<p><b>Effects</b>: Returns the previous node of the tree.</p>
<p><b>Complexity</b>: Average constant time.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00310">310</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2359f2e9e64f77f22dbdea53c117bff1"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::push_back" ref="a2359f2e9e64f77f22dbdea53c117bff1" args="(node_ptr header, node_ptr new_node)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::push_back </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>new_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: "header" must be the header node of a tree. "new_node" must be, according to the used ordering no less than the greatest inserted key.</p>
<p><b>Effects</b>: Inserts new_node into the tree before "pos".</p>
<p><b>Complexity</b>: Constant-time.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: If "new_node" is less than the greatest inserted key tree invariants are broken. This function is slightly faster than using "insert_before". </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00568">568</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5921e3c87fcc03ef063a3c30534db09f"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::push_front" ref="a5921e3c87fcc03ef063a3c30534db09f" args="(node_ptr header, node_ptr new_node)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>new_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: "header" must be the header node of a tree. "new_node" must be, according to the used ordering, no greater than the lowest inserted key.</p>
<p><b>Effects</b>: Inserts new_node into the tree before "pos".</p>
<p><b>Complexity</b>: Constant-time.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: If "new_node" is greater than the lowest inserted key tree invariants are broken. This function is slightly faster than using "insert_before". </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00587">587</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a83e08757e9222a631706d9801ca33662"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::replace_node" ref="a83e08757e9222a631706d9801ca33662" args="(node_ptr node_to_be_replaced, node_ptr header, node_ptr new_node)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::replace_node </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>node_to_be_replaced</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>new_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: node_to_be_replaced must be inserted in a tree with header "header" and new_node must not be inserted in a tree.</p>
<p><b>Effects</b>: Replaces node_to_be_replaced in its position in the tree with new_node. The tree does not need to be rebalanced</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: This function will break container ordering invariants if new_node is not equivalent to node_to_be_replaced according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing or comparison is needed.</p>
<p>Experimental function </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00223">223</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3a0033dbc2de8c3241d492609f229076"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::replace_node" ref="a3a0033dbc2de8c3241d492609f229076" args="(node_ptr node_to_be_replaced, node_ptr new_node)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::replace_node </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>node_to_be_replaced</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>new_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: node_to_be_replaced must be inserted in a tree and new_node must not be inserted in a tree.</p>
<p><b>Effects</b>: Replaces node_to_be_replaced in its position in the tree with new_node. The tree does not need to be rebalanced</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: This function will break container ordering invariants if new_node is not equivalent to node_to_be_replaced according to the ordering rules. This function is faster than erasing and inserting the node, since no rebalancing and comparison is needed.</p>
<p>Experimental function </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00200">200</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac691942055b31a5c0d829cffb5fe284a"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::size" ref="ac691942055b31a5c0d829cffb5fe284a" args="(const_node_ptr header)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static std::size_t <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::size </td>
          <td>(</td>
          <td class="paramtype">const_node_ptr&#160;</td>
          <td class="paramname"> <em>header</em>&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: header is the header node of the tree.</p>
<p><b>Effects</b>: Returns the number of nodes above the header.</p>
<p><b>Complexity</b>: Linear time.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00290">290</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2b5d024ad06790441c6db3e3d852224d"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::swap_nodes" ref="a2b5d024ad06790441c6db3e3d852224d" args="(node_ptr node1, node_ptr node2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::swap_nodes </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>node2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: node1 and node2 can't be header nodes of two trees.</p>
<p><b>Effects</b>: Swaps two nodes. After the function node1 will be inserted in the position node2 before the function. node2 will be inserted in the position node1 had before the function.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: This function will break container ordering invariants if node1 and node2 are not equivalent according to the ordering rules.</p>
<p>Experimental function </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00149">149</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af11c1753f1070ce074eea234a243c086"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::swap_nodes" ref="af11c1753f1070ce074eea234a243c086" args="(node_ptr node1, node_ptr header1, node_ptr node2, node_ptr header2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::swap_nodes </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>node1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>header1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>node2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>header2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: node1 and node2 can't be header nodes of two trees with header header1 and header2.</p>
<p><b>Effects</b>: Swaps two nodes. After the function node1 will be inserted in the position node2 before the function. node2 will be inserted in the position node1 had before the function.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Note</b>: This function will break container ordering invariants if node1 and node2 are not equivalent according to the ordering rules.</p>
<p>Experimental function </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00173">173</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a370c2b58046648ea3a46436af7c29bc9"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::swap_tree" ref="a370c2b58046648ea3a46436af7c29bc9" args="(node_ptr header1, node_ptr header2)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::swap_tree </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>header1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>header2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: header1 and header2 must be the header nodes of two trees.</p>
<p><b>Effects</b>: Swaps two trees. After the function header1 will contain links to the second tree and header2 will have links to the first tree.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00131">131</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a52c89a7cce0d9a47932baf0dac75a182"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::unique" ref="a52c89a7cce0d9a47932baf0dac75a182" args="(const_node_ptr node)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::unique </td>
          <td>(</td>
          <td class="paramtype">const_node_ptr&#160;</td>
          <td class="paramname"> <em>node</em>&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: node is a node of the tree or an node initialized by init(...).</p>
<p><b>Effects</b>: Returns true if the node is initialized by <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html#ab4ffe5a1e462b71935fb6278be1578a0">init()</a>.</p>
<p><b>Complexity</b>: Constant time.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00270">270</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ada0d25e75a4dc102a4201787fb973f09"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::unlink" ref="ada0d25e75a4dc102a4201787fb973f09" args="(node_ptr node)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::unlink </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>node</em>&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: node is a tree node but not the header.</p>
<p><b>Effects</b>: Unlinks the node and rebalances the tree.</p>
<p><b>Complexity</b>: Average complexity is constant time.</p>
<p><b>Throws</b>: Nothing. </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00236">236</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8b6d981fedca525fd1267cf6d98e9532"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::unlink_leftmost_without_rebalance" ref="a8b6d981fedca525fd1267cf6d98e9532" args="(node_ptr header)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static node_ptr <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::unlink_leftmost_without_rebalance </td>
          <td>(</td>
          <td class="paramtype">node_ptr&#160;</td>
          <td class="paramname"> <em>header</em>&#160;)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: header is the header of a tree.</p>
<p><b>Effects</b>: Unlinks the leftmost node from the tree, and updates the header link to the new leftmost node.</p>
<p><b>Complexity</b>: Average complexity is constant time.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Notes</b>: This function breaks the tree and the tree can only be used for more unlink_leftmost_without_rebalance calls. This function is normally used to achieve a step by step controlled destruction of the tree. </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00259">259</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4f808b9edf8de9155e80fe015b27a755"></a><!-- doxytag: member="boost::intrusive::avltree_algorithms::upper_bound" ref="a4f808b9edf8de9155e80fe015b27a755" args="(const_node_ptr header, const KeyType &amp;key, KeyNodePtrCompare comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class NodeTraits &gt; </div>
<div class="memtemplate">
template&lt;class KeyType , class KeyNodePtrCompare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">static node_ptr <a class="el" href="classboost_1_1intrusive_1_1avltree__algorithms.html">boost::intrusive::avltree_algorithms</a>&lt; NodeTraits &gt;::upper_bound </td>
          <td>(</td>
          <td class="paramtype">const_node_ptr&#160;</td>
          <td class="paramname"> <em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const KeyType &amp;&#160;</td>
          <td class="paramname"> <em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyNodePtrCompare&#160;</td>
          <td class="paramname"> <em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: "header" must be the header node of a tree. KeyNodePtrCompare is a function object that induces a strict weak ordering compatible with the strict weak ordering used to create the the tree. KeyNodePtrCompare can compare KeyType with tree's node_ptrs.</p>
<p><b>Effects</b>: Returns an node_ptr to the first element that is greater than "key" according to "comp" or "header" if that element does not exist.</p>
<p><b>Complexity</b>: Logarithmic.</p>
<p><b>Throws</b>: If "comp" throws. </p>

<p>Definition at line <a class="el" href="avltree__algorithms_8hpp_source.html#l00431">431</a> of file <a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="avltree__algorithms_8hpp_source.html">avltree_algorithms.hpp</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Apr 27 2011 00:50:17 for Nutcracker by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
