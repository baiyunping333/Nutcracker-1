<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nutcracker: chain.cpp Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script src="http://www.mathjax.org/mathjax/MathJax.js">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.3 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Nutcracker</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<div class="header">
  <div class="headertitle">
<h1>chain.cpp</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">//@+leo-ver=5-thin</span>
<a name="l00002"></a>00002 <span class="comment">//@+node:gcross.20110130170743.1674: * @file chain.cpp</span>
<a name="l00003"></a>00003 <span class="comment">//@@language cplusplus</span>
<a name="l00004"></a>00004 
<a name="l00005"></a>00005 <span class="comment">//@+&lt;&lt; License &gt;&gt;</span>
<a name="l00006"></a>00006 <span class="comment">//@+node:gcross.20110220182654.2026: ** &lt;&lt; License &gt;&gt;</span>
<a name="l00007"></a>00007 <span class="comment">//@+at</span>
<a name="l00008"></a>00008 <span class="comment">// Copyright (c) 2011, Gregory Crosswhite</span>
<a name="l00009"></a>00009 <span class="comment">// All rights reserved.</span>
<a name="l00010"></a>00010 <span class="comment">// </span>
<a name="l00011"></a>00011 <span class="comment">// Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:</span>
<a name="l00012"></a>00012 <span class="comment">// </span>
<a name="l00013"></a>00013 <span class="comment">//     * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.</span>
<a name="l00014"></a>00014 <span class="comment">//     * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.</span>
<a name="l00015"></a>00015 <span class="comment">// </span>
<a name="l00016"></a>00016 <span class="comment">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00017"></a>00017 <span class="comment">//@@c</span>
<a name="l00018"></a>00018 <span class="comment">//@-&lt;&lt; License &gt;&gt;</span>
<a name="l00019"></a>00019 
<a name="l00020"></a>00020 <span class="comment">//@+&lt;&lt; Includes &gt;&gt;</span>
<a name="l00021"></a>00021 <span class="comment">//@+node:gcross.20110130170743.1675: ** &lt;&lt; Includes &gt;&gt;</span>
<a name="l00022"></a>00022 <span class="preprocessor">#include &lt;boost/assign.hpp&gt;</span>
<a name="l00023"></a>00023 <span class="preprocessor">#include &lt;boost/bind.hpp&gt;</span>
<a name="l00024"></a>00024 <span class="preprocessor">#include &lt;boost/foreach.hpp&gt;</span>
<a name="l00025"></a>00025 <span class="preprocessor">#include &lt;boost/lambda/lambda.hpp&gt;</span>
<a name="l00026"></a>00026 <span class="preprocessor">#include &lt;boost/range/adaptor/reversed.hpp&gt;</span>
<a name="l00027"></a>00027 <span class="preprocessor">#include &lt;boost/range/adaptor/transformed.hpp&gt;</span>
<a name="l00028"></a>00028 <span class="preprocessor">#include &lt;boost/range/algorithm/reverse_copy.hpp&gt;</span>
<a name="l00029"></a>00029 <span class="preprocessor">#include &lt;boost/range/numeric.hpp&gt;</span>
<a name="l00030"></a>00030 <span class="preprocessor">#include &lt;boost/range/irange.hpp&gt;</span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &lt;iterator&gt;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &lt;limits&gt;</span>
<a name="l00033"></a>00033 <span class="preprocessor">#include &lt;numeric&gt;</span>
<a name="l00034"></a>00034 <span class="preprocessor">#include &lt;utility&gt;</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="preprocessor">#include &quot;boundaries.hpp&quot;</span>
<a name="l00037"></a>00037 <span class="preprocessor">#include &quot;chain.hpp&quot;</span>
<a name="l00038"></a>00038 <span class="preprocessor">#include &quot;core.hpp&quot;</span>
<a name="l00039"></a>00039 <span class="preprocessor">#include &quot;optimizer.hpp&quot;</span>
<a name="l00040"></a>00040 <span class="preprocessor">#include &quot;utilities.hpp&quot;</span>
<a name="l00041"></a>00041 <span class="comment">//@-&lt;&lt; Includes &gt;&gt;</span>
<a name="l00042"></a>00042 
<a name="l00043"></a>00043 <span class="keyword">namespace </span>Nutcracker {
<a name="l00044"></a>00044 
<a name="l00045"></a>00045 <span class="comment">//@+&lt;&lt; Usings &gt;&gt;</span>
<a name="l00046"></a>00046 <span class="comment">//@+node:gcross.20110130170743.1676: ** &lt;&lt; Usings &gt;&gt;</span>
<a name="l00047"></a>00047 <span class="keyword">using</span> boost::accumulate;
<a name="l00048"></a>00048 <span class="keyword">using</span> boost::adaptors::transformed;
<a name="l00049"></a>00049 <span class="keyword">using</span> boost::adaptors::reversed;
<a name="l00050"></a>00050 <span class="keyword">using</span> boost::function;
<a name="l00051"></a>00051 
<a name="l00052"></a>00052 <span class="keyword">using</span> std::abs;
<a name="l00053"></a>00053 <span class="keyword">using</span> std::max;
<a name="l00054"></a>00054 <span class="keyword">using</span> std::min;
<a name="l00055"></a>00055 <span class="keyword">using</span> std::numeric_limits;
<a name="l00056"></a>00056 <span class="comment">//@-&lt;&lt; Usings &gt;&gt;</span>
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 <span class="comment">//@+others</span>
<a name="l00059"></a>00059 <span class="comment">//@+node:gcross.20110208151104.1790: ** Values</span>
<a name="l00060"></a>00060 Chain::Options <span class="keyword">const</span> Chain::defaults =
<a name="l00061"></a>00061     { 10000
<a name="l00062"></a>00062     , 1e-12
<a name="l00063"></a>00063     , 1e-12
<a name="l00064"></a>00064     , 1e-12
<a name="l00065"></a>00065     , 1e-12
<a name="l00066"></a>00066     , lambda::_1+1
<a name="l00067"></a>00067     };
<a name="l00068"></a>00068 <span class="comment">//@+node:gcross.20110202175920.1714: ** class Chain</span>
<a name="l00069"></a>00069 <span class="comment">//@+node:gcross.20110202175920.1715: *3* (constructors)</span>
<a name="l00070"></a>00070 Chain::Chain(
<a name="l00071"></a>00071       Operator <span class="keyword">const</span>&amp; operator_sites
<a name="l00072"></a>00072     , <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> bandwidth_dimension
<a name="l00073"></a>00073     , Options <span class="keyword">const</span>&amp; options
<a name="l00074"></a>00074     , OptimizerMode <span class="keyword">const</span>&amp; optimizer_mode
<a name="l00075"></a>00075 ) : number_of_sites(operator_sites.size())
<a name="l00076"></a>00076   , operator_sites(operator_sites)
<a name="l00077"></a>00077   , optimizer_mode(optimizer_mode)
<a name="l00078"></a>00078   , current_site_number(0)
<a name="l00079"></a>00079   , left_expectation_boundary(<a class="code" href="group__DummyArguments.html#gab348bc87d12559fc5e924286d3e6d6fd" title="The singleton instance of MakeTrivial.">make_trivial</a>)
<a name="l00080"></a>00080   , right_expectation_boundary(<a class="code" href="group__DummyArguments.html#gab348bc87d12559fc5e924286d3e6d6fd" title="The singleton instance of MakeTrivial.">make_trivial</a>)
<a name="l00081"></a>00081   , energy(0)
<a name="l00082"></a>00082   , physical_dimensions(extractPhysicalDimensions(operator_sites))
<a name="l00083"></a>00083   , maximum_number_of_levels(accumulate(physical_dimensions,1,multiplies&lt;unsigned int&gt;()))
<a name="l00084"></a>00084   , maximum_bandwidth_dimension(<a class="code" href="group__BandwidthDimensionFunctions.html#gaa647b59ff1bfa8d5c0479429ee2f6f47" title="Computes the maximum bandwidth dimension attainable given the sequence of physical dimensions...">maximumBandwidthDimension</a>(physical_dimensions))
<a name="l00085"></a>00085   , bandwidth_dimension(bandwidth_dimension)
<a name="l00086"></a>00086   , options(options)
<a name="l00087"></a>00087 {
<a name="l00088"></a>00088     assert(number_of_sites &gt; 0);
<a name="l00089"></a>00089     assert(bandwidth_dimension &lt;= maximum_bandwidth_dimension);
<a name="l00090"></a>00090 
<a name="l00091"></a>00091     reset(bandwidth_dimension);
<a name="l00092"></a>00092 }
<a name="l00093"></a>00093 <span class="comment">//@+node:gcross.20110202175920.1720: *3* computeExpectationValueAtSite</span>
<a name="l00094"></a>00094 complex&lt;double&gt; Chain::computeExpectationValueAtCurrentSite()<span class="keyword"> const </span>{
<a name="l00095"></a>00095     <span class="keywordflow">return</span> 
<a name="l00096"></a>00096         <a class="code" href="group__BoundaryContractors.html#gaf744ae3619f183b5e397db4e4dc6728f" title="Computes the expectation value at a given site.">Nutcracker::computeExpectationValueAtSite</a>(
<a name="l00097"></a>00097              left_expectation_boundary
<a name="l00098"></a>00098             ,state_site
<a name="l00099"></a>00099             ,*operator_sites[current_site_number]
<a name="l00100"></a>00100             ,right_expectation_boundary
<a name="l00101"></a>00101         );
<a name="l00102"></a>00102 }
<a name="l00103"></a>00103 <span class="comment">//@+node:gcross.20110219083229.1937: *3* computeProjectorOverlapAtSite</span>
<a name="l00104"></a>00104 <span class="keywordtype">double</span> Chain::computeProjectorOverlapAtCurrentSite()<span class="keyword"> const </span>{
<a name="l00105"></a>00105     <span class="keywordflow">return</span> computeOverlapWithProjectors(projector_matrix,state_site);
<a name="l00106"></a>00106 }
<a name="l00107"></a>00107 <span class="comment">//@+node:gcross.20110202175920.1721: *3* computeStateNorm</span>
<a name="l00108"></a>00108 <span class="keywordtype">double</span> Chain::computeStateNorm()<span class="keyword"> const </span>{
<a name="l00109"></a>00109     <span class="keywordflow">return</span> state_site.norm();
<a name="l00110"></a>00110 }
<a name="l00111"></a>00111 <span class="comment">//@+node:gcross.20110218083552.1930: *3* convertStateToProjectorAndReset</span>
<a name="l00112"></a>00112 <span class="keywordtype">void</span> Chain::convertStateToProjectorAndReset(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> new_bandwidth_dimension) {
<a name="l00113"></a>00113     <span class="keyword">using namespace </span>boost;
<a name="l00114"></a>00114     assert(current_site_number == 0);
<a name="l00115"></a>00115     projectors.push_back(
<a name="l00116"></a>00116         computeProjectorFromStateSites(
<a name="l00117"></a>00117              state_site
<a name="l00118"></a>00118             ,right_neighbors | reversed | transformed(bind(&amp;Neighbor&lt;Right&gt;::state_site,_1))
<a name="l00119"></a>00119         )
<a name="l00120"></a>00120     );
<a name="l00121"></a>00121     reset(
<a name="l00122"></a>00122         min(maximum_bandwidth_dimension
<a name="l00123"></a>00123            ,max(new_bandwidth_dimension
<a name="l00124"></a>00124                ,minimumBandwidthDimensionForProjectorCount(
<a name="l00125"></a>00125                      physical_dimensions
<a name="l00126"></a>00126                     ,projectors.size()
<a name="l00127"></a>00127                 )+1
<a name="l00128"></a>00128             )
<a name="l00129"></a>00129         )
<a name="l00130"></a>00130     );
<a name="l00131"></a>00131 }
<a name="l00132"></a>00132 <span class="comment">//@+node:gcross.20110207120702.1784: *3* increaseBandwidthDimension</span>
<a name="l00133"></a>00133 <span class="keywordtype">void</span> Chain::increaseBandwidthDimension(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> new_bandwidth_dimension) {
<a name="l00134"></a>00134     <span class="keywordflow">if</span>(bandwidth_dimension == new_bandwidth_dimension) <span class="keywordflow">return</span>;
<a name="l00135"></a>00135     assert(bandwidth_dimension &lt; new_bandwidth_dimension);
<a name="l00136"></a>00136     assert(new_bandwidth_dimension &lt;= maximum_bandwidth_dimension);
<a name="l00137"></a>00137     assert(current_site_number == 0);
<a name="l00138"></a>00138     vector&lt;unsigned int&gt; initial_bandwidth_dimensions = <a class="code" href="group__BandwidthDimensionFunctions.html#ga099aa7c5ad6c6053d67337ec57325ae1" title="Computes the bandwidth dimension sequence given the requested bandwidth dimension and the sequence of...">computeBandwidthDimensionSequence</a>(new_bandwidth_dimension,physical_dimensions);
<a name="l00139"></a>00139     vector&lt;unsigned int&gt;::const_reverse_iterator dimension_iterator = initial_bandwidth_dimensions.rbegin()+1;
<a name="l00140"></a>00140 
<a name="l00141"></a>00141     vector&lt;Neighbor&lt;Right&gt; &gt; old_right_neighbors(boost::move(right_neighbors));
<a name="l00142"></a>00142 
<a name="l00143"></a>00143     StateSite&lt;Middle&gt; first_state_site(boost::move(state_site));
<a name="l00144"></a>00144 
<a name="l00145"></a>00145     resetBoundaries();
<a name="l00146"></a>00146 
<a name="l00147"></a>00147     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> operator_number = number_of_sites-1;
<a name="l00148"></a>00148     <span class="keywordflow">for</span>(vector&lt;Neighbor&lt;Right&gt; &gt;::iterator neighbor_iterator = old_right_neighbors.begin()
<a name="l00149"></a>00149        ;neighbor_iterator != old_right_neighbors.end()
<a name="l00150"></a>00150        ;++neighbor_iterator,--operator_number
<a name="l00151"></a>00151     ) {
<a name="l00152"></a>00152         <span class="keywordflow">if</span>(operator_number &gt; 1) {
<a name="l00153"></a>00153             StateSite&lt;Right&gt;&amp; next_right_state_site = (neighbor_iterator+1)-&gt;state_site;
<a name="l00154"></a>00154             IncreaseDimensionBetweenResult&lt;Right,Right&gt; result(
<a name="l00155"></a>00155                 increaseDimensionBetweenRightRight(
<a name="l00156"></a>00156                      *(dimension_iterator++)
<a name="l00157"></a>00157                     ,next_right_state_site
<a name="l00158"></a>00158                     ,neighbor_iterator-&gt;state_site
<a name="l00159"></a>00159                 )
<a name="l00160"></a>00160             );
<a name="l00161"></a>00161             next_right_state_site = boost::move(result.state_site_1);
<a name="l00162"></a>00162             absorb&lt;Right&gt;(boost::move(result.state_site_2),operator_number);
<a name="l00163"></a>00163         } <span class="keywordflow">else</span> {
<a name="l00164"></a>00164             IncreaseDimensionBetweenResult&lt;Middle,Right&gt; result(
<a name="l00165"></a>00165                 increaseDimensionBetweenMiddleRight(
<a name="l00166"></a>00166                      *(dimension_iterator++)
<a name="l00167"></a>00167                     ,first_state_site
<a name="l00168"></a>00168                     ,neighbor_iterator-&gt;state_site
<a name="l00169"></a>00169                 )
<a name="l00170"></a>00170             );
<a name="l00171"></a>00171             state_site = boost::move(result.state_site_1);
<a name="l00172"></a>00172             absorb&lt;Right&gt;(boost::move(result.state_site_2),operator_number);
<a name="l00173"></a>00173         }
<a name="l00174"></a>00174     }
<a name="l00175"></a>00175     bandwidth_dimension = new_bandwidth_dimension;
<a name="l00176"></a>00176 
<a name="l00177"></a>00177     resetProjectorMatrix();
<a name="l00178"></a>00178 }
<a name="l00179"></a>00179 <span class="comment">//@+node:gcross.20110215235924.1878: *3* makeCopyOfState</span>
<a name="l00180"></a>00180 State Chain::makeCopyOfState()<span class="keyword"> const </span>{
<a name="l00181"></a>00181     assert(current_site_number == 0);
<a name="l00182"></a>00182     StateSite&lt;Middle&gt; first_state_site(<a class="code" href="group__ConstructorParameters.html#gafd335eeb0a9be2f542e8410546ed570a" title="A convenience function for wrapping values in CopyFrom.">copyFrom</a>&lt;StateSite&lt;Middle&gt; <span class="keyword">const</span>&gt;(state_site));
<a name="l00183"></a>00183     vector&lt;StateSite&lt;Right&gt; &gt; rest_state_sites; rest_state_sites.reserve(number_of_sites-1);
<a name="l00184"></a>00184     BOOST_FOREACH(Neighbor&lt;Right&gt; <span class="keyword">const</span>&amp; neighbor, right_neighbors | reversed) {
<a name="l00185"></a>00185         rest_state_sites.emplace_back(<a class="code" href="group__ConstructorParameters.html#gafd335eeb0a9be2f542e8410546ed570a" title="A convenience function for wrapping values in CopyFrom.">copyFrom</a>&lt;StateSite&lt;Right&gt; <span class="keyword">const</span>&gt;(neighbor.state_site));
<a name="l00186"></a>00186     }
<a name="l00187"></a>00187     <span class="keywordflow">return</span> State(
<a name="l00188"></a>00188          boost::move(first_state_site)
<a name="l00189"></a>00189         ,boost::move(rest_state_sites)
<a name="l00190"></a>00190     );
<a name="l00191"></a>00191 }
<a name="l00192"></a>00192 <span class="comment">//@+node:gcross.20110218083552.2522: *3* moveTo</span>
<a name="l00193"></a>00193 <span class="keywordtype">void</span> Chain::moveTo(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> new_site_number) {
<a name="l00194"></a>00194     assert(new_site_number &lt; number_of_sites);
<a name="l00195"></a>00195     <span class="keywordflow">while</span>(current_site_number &gt; new_site_number) {
<a name="l00196"></a>00196         move&lt;Left&gt;();
<a name="l00197"></a>00197     }
<a name="l00198"></a>00198     <span class="keywordflow">while</span>(current_site_number &lt; new_site_number) {
<a name="l00199"></a>00199         move&lt;Right&gt;();
<a name="l00200"></a>00200     }
<a name="l00201"></a>00201 }
<a name="l00202"></a>00202 <span class="comment">//@+node:gcross.20110208230325.1790: *3* optimizeChain</span>
<a name="l00203"></a>00203 <span class="keywordtype">void</span> Chain::optimizeChain() {
<a name="l00204"></a>00204     <span class="keywordtype">double</span> previous_energy = energy;
<a name="l00205"></a>00205     sweepUntilConverged();
<a name="l00206"></a>00206     <span class="keywordflow">while</span>(<a class="code" href="group__Utilities.html#ga04c647826f947bec8cc1b2013a6d11d6" title="Returns whether a and b do not match within the specified relative tolerance.">outsideTolerance</a>(previous_energy,energy,options.chain_convergence_threshold)
<a name="l00207"></a>00207        &amp;&amp; bandwidth_dimension &lt; maximum_bandwidth_dimension
<a name="l00208"></a>00208     ) {
<a name="l00209"></a>00209         previous_energy = energy;
<a name="l00210"></a>00210         increaseBandwidthDimension(min(options.computeNewBandwidthDimension(bandwidth_dimension),maximum_bandwidth_dimension));
<a name="l00211"></a>00211         sweepUntilConverged();
<a name="l00212"></a>00212     }
<a name="l00213"></a>00213     signalChainOptimized();
<a name="l00214"></a>00214 }
<a name="l00215"></a>00215 <span class="comment">//@+node:gcross.20110206130502.1754: *3* optimizeSite</span>
<a name="l00216"></a>00216 <span class="keywordtype">void</span> Chain::optimizeSite() {
<a name="l00217"></a>00217     <span class="keywordflow">try</span> {
<a name="l00218"></a>00218         OptimizerResult result(
<a name="l00219"></a>00219             <a class="code" href="group__Optimizer.html#gafce29804bfc9e2db0c803c90ceaf0a5d" title="Optimizes a site and returns the result.">optimizeStateSite</a>(
<a name="l00220"></a>00220                  left_expectation_boundary
<a name="l00221"></a>00221                 ,state_site
<a name="l00222"></a>00222                 ,*operator_sites[current_site_number]
<a name="l00223"></a>00223                 ,right_expectation_boundary
<a name="l00224"></a>00224                 ,projector_matrix
<a name="l00225"></a>00225                 ,options.site_convergence_threshold
<a name="l00226"></a>00226                 ,options.sanity_check_threshold
<a name="l00227"></a>00227                 ,options.maximum_number_of_iterations
<a name="l00228"></a>00228                 ,optimizer_mode
<a name="l00229"></a>00229             )
<a name="l00230"></a>00230         );
<a name="l00231"></a>00231         <span class="keywordflow">if</span>(optimizer_mode.checkForRegressionFromTo(energy,result.eigenvalue,options.sanity_check_threshold)) {
<a name="l00232"></a>00232             <span class="keywordflow">throw</span> OptimizerObtainedRegressiveEigenvalue(energy,result.eigenvalue);
<a name="l00233"></a>00233         }
<a name="l00234"></a>00234         <span class="keywordflow">if</span>((energy &gt;= 0 &amp;&amp; result.eigenvalue &gt;= 0) || (energy &lt;= 0 &amp;&amp; result.eigenvalue &lt;= 0) || <a class="code" href="group__Utilities.html#ga04c647826f947bec8cc1b2013a6d11d6" title="Returns whether a and b do not match within the specified relative tolerance.">outsideTolerance</a>(abs(energy),abs(result.eigenvalue),options.sanity_check_threshold)) {
<a name="l00235"></a>00235             energy = result.eigenvalue;
<a name="l00236"></a>00236             state_site = boost::move(result.state_site);
<a name="l00237"></a>00237         }
<a name="l00238"></a>00238         signalOptimizeSiteSuccess(result.number_of_iterations);
<a name="l00239"></a>00239     } <span class="keywordflow">catch</span>(OptimizerFailure&amp; failure) {
<a name="l00240"></a>00240         signalOptimizeSiteFailure(failure);
<a name="l00241"></a>00241     }
<a name="l00242"></a>00242 }
<a name="l00243"></a>00243 <span class="comment">//@+node:gcross.20110206130502.1759: *3* performOptimizationSweep</span>
<a name="l00244"></a>00244 <span class="keywordtype">void</span> Chain::performOptimizationSweep() {
<a name="l00245"></a>00245     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> starting_site = current_site_number;
<a name="l00246"></a>00246     optimizeSite();
<a name="l00247"></a>00247     <span class="keywordflow">while</span>(current_site_number+1 &lt; number_of_sites) {
<a name="l00248"></a>00248         move&lt;Right&gt;();
<a name="l00249"></a>00249         optimizeSite();
<a name="l00250"></a>00250     }
<a name="l00251"></a>00251     <span class="keywordflow">while</span>(current_site_number &gt; 0) {
<a name="l00252"></a>00252         move&lt;Left&gt;();
<a name="l00253"></a>00253         optimizeSite();
<a name="l00254"></a>00254     }
<a name="l00255"></a>00255     <span class="keywordflow">while</span>(current_site_number &lt; starting_site) {
<a name="l00256"></a>00256         move&lt;Right&gt;();
<a name="l00257"></a>00257         optimizeSite();
<a name="l00258"></a>00258     }
<a name="l00259"></a>00259     signalSweepPerformed();
<a name="l00260"></a>00260 }
<a name="l00261"></a>00261 <span class="comment">//@+node:gcross.20110208233325.1798: *3* reset</span>
<a name="l00262"></a>00262 <span class="keywordtype">void</span> Chain::reset(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> bandwidth_dimension) {
<a name="l00263"></a>00263     current_site_number = 0;
<a name="l00264"></a>00264 
<a name="l00265"></a>00265     resetBoundaries();
<a name="l00266"></a>00266 
<a name="l00267"></a>00267     right_neighbors.clear();
<a name="l00268"></a>00268     right_neighbors.reserve(number_of_sites-1);
<a name="l00269"></a>00269 
<a name="l00270"></a>00270     vector&lt;unsigned int&gt; initial_bandwidth_dimensions = <a class="code" href="group__BandwidthDimensionFunctions.html#ga099aa7c5ad6c6053d67337ec57325ae1" title="Computes the bandwidth dimension sequence given the requested bandwidth dimension and the sequence of...">computeBandwidthDimensionSequence</a>(bandwidth_dimension,physical_dimensions);
<a name="l00271"></a>00271     vector&lt;unsigned int&gt;::const_reverse_iterator
<a name="l00272"></a>00272           right_dimension = initial_bandwidth_dimensions.rbegin()
<a name="l00273"></a>00273         , left_dimension = right_dimension+1;
<a name="l00274"></a>00274     BOOST_FOREACH(
<a name="l00275"></a>00275          <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> operator_number
<a name="l00276"></a>00276         ,irange(1u,number_of_sites) | reversed
<a name="l00277"></a>00277     ) {
<a name="l00278"></a>00278         absorb&lt;Right&gt;(
<a name="l00279"></a>00279              randomStateSiteRight(
<a name="l00280"></a>00280                  operator_sites[operator_number]-&gt;physicalDimension()
<a name="l00281"></a>00281                 ,LeftDimension(*(left_dimension++))
<a name="l00282"></a>00282                 ,RightDimension(*(right_dimension++))
<a name="l00283"></a>00283              )
<a name="l00284"></a>00284             ,operator_number
<a name="l00285"></a>00285         );
<a name="l00286"></a>00286     }
<a name="l00287"></a>00287 
<a name="l00288"></a>00288     state_site =
<a name="l00289"></a>00289         randomStateSiteMiddle(
<a name="l00290"></a>00290              operator_sites[0]-&gt;physicalDimension()
<a name="l00291"></a>00291             ,LeftDimension(initial_bandwidth_dimensions[0])
<a name="l00292"></a>00292             ,RightDimension(initial_bandwidth_dimensions[1])
<a name="l00293"></a>00293         );
<a name="l00294"></a>00294 
<a name="l00295"></a>00295     resetProjectorMatrix();
<a name="l00296"></a>00296 
<a name="l00297"></a>00297     <span class="keywordflow">if</span>(projectors.size() &gt; 0) {
<a name="l00298"></a>00298         <span class="keywordflow">while</span>(projector_matrix.orthogonalSubspaceDimension() == 0) {
<a name="l00299"></a>00299             move&lt;Right&gt;();
<a name="l00300"></a>00300         }
<a name="l00301"></a>00301         state_site = applyProjectorMatrix(projector_matrix,state_site);
<a name="l00302"></a>00302         assert(abs(state_site.norm()-1) &lt; 1e-7);
<a name="l00303"></a>00303         moveTo(0);
<a name="l00304"></a>00304     }
<a name="l00305"></a>00305 
<a name="l00306"></a>00306     complex&lt;double&gt; <span class="keyword">const</span> expectation_value = computeExpectationValueAtCurrentSite();
<a name="l00307"></a>00307     <span class="keywordflow">if</span>(abs(expectation_value.imag()) &gt; 1e-10) <span class="keywordflow">throw</span> InitialChainEnergyNotRealError(expectation_value);
<a name="l00308"></a>00308     energy = expectation_value.real();
<a name="l00309"></a>00309 
<a name="l00310"></a>00310     signalChainReset();
<a name="l00311"></a>00311 }
<a name="l00312"></a>00312 <span class="comment">//@+node:gcross.20110218114759.1932: *3* resetBoundaries</span>
<a name="l00313"></a>00313 <span class="keywordtype">void</span> Chain::resetBoundaries() {
<a name="l00314"></a>00314     left_expectation_boundary = ExpectationBoundary&lt;Left&gt;(<a class="code" href="group__DummyArguments.html#gab348bc87d12559fc5e924286d3e6d6fd" title="The singleton instance of MakeTrivial.">make_trivial</a>);
<a name="l00315"></a>00315 
<a name="l00316"></a>00316     left_overlap_boundaries.clear();
<a name="l00317"></a>00317     <a class="code" href="group__Utilities.html#ga0c7b5dd039bcb1b7cbdcb6c738dd5945" title="Repeats a statement or block n times.">REPEAT</a>(projectors.size()) {
<a name="l00318"></a>00318         left_overlap_boundaries.emplace_back(<a class="code" href="group__DummyArguments.html#gab348bc87d12559fc5e924286d3e6d6fd" title="The singleton instance of MakeTrivial.">make_trivial</a>);
<a name="l00319"></a>00319     }
<a name="l00320"></a>00320 
<a name="l00321"></a>00321     right_expectation_boundary = ExpectationBoundary&lt;Right&gt;(<a class="code" href="group__DummyArguments.html#gab348bc87d12559fc5e924286d3e6d6fd" title="The singleton instance of MakeTrivial.">make_trivial</a>);
<a name="l00322"></a>00322 
<a name="l00323"></a>00323     right_overlap_boundaries.clear();
<a name="l00324"></a>00324     <a class="code" href="group__Utilities.html#ga0c7b5dd039bcb1b7cbdcb6c738dd5945" title="Repeats a statement or block n times.">REPEAT</a>(projectors.size()) {
<a name="l00325"></a>00325         right_overlap_boundaries.emplace_back(<a class="code" href="group__DummyArguments.html#gab348bc87d12559fc5e924286d3e6d6fd" title="The singleton instance of MakeTrivial.">make_trivial</a>);
<a name="l00326"></a>00326     }
<a name="l00327"></a>00327 }
<a name="l00328"></a>00328 <span class="comment">//@+node:gcross.20110218083552.1931: *3* resetProjectorMatrix</span>
<a name="l00329"></a>00329 <span class="keyword">namespace </span>resetProjectorMatrix_IMPLEMENTATION {
<a name="l00330"></a><a class="code" href="structNutcracker_1_1resetProjectorMatrix__IMPLEMENTATION_1_1FetchOverlapSite.html">00330</a>     <span class="keyword">struct </span><a class="code" href="structNutcracker_1_1resetProjectorMatrix__IMPLEMENTATION_1_1FetchOverlapSite.html">FetchOverlapSite</a> {
<a name="l00331"></a>00331         <span class="keyword">typedef</span> <a class="code" href="classNutcracker_1_1OverlapSite.html">OverlapSite&lt;Middle&gt;</a> <span class="keyword">const</span>&amp; <a class="code" href="classNutcracker_1_1OverlapSite.html">result_type</a>;
<a name="l00332"></a>00332         <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> current_site_number;
<a name="l00333"></a>00333         <a class="code" href="structNutcracker_1_1resetProjectorMatrix__IMPLEMENTATION_1_1FetchOverlapSite.html">FetchOverlapSite</a>() {}
<a name="l00334"></a>00334         <a class="code" href="structNutcracker_1_1resetProjectorMatrix__IMPLEMENTATION_1_1FetchOverlapSite.html">FetchOverlapSite</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="keyword">const</span> current_site_number) : current_site_number(current_site_number) {}
<a name="l00335"></a>00335         <a class="code" href="classNutcracker_1_1OverlapSite.html">OverlapSite&lt;Middle&gt;</a> <span class="keyword">const</span>&amp; operator()(<a class="code" href="structNutcracker_1_1Projector.html">Projector</a> <span class="keyword">const</span>&amp; projector)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> projector[current_site_number].get&lt;Middle&gt;(); }
<a name="l00336"></a>00336     };
<a name="l00337"></a>00337 }
<a name="l00338"></a>00338 
<a name="l00339"></a>00339 <span class="keywordtype">void</span> Chain::resetProjectorMatrix() {
<a name="l00340"></a>00340     <span class="keyword">using namespace </span>resetProjectorMatrix_IMPLEMENTATION;
<a name="l00341"></a>00341     projector_matrix =
<a name="l00342"></a>00342         formProjectorMatrix(
<a name="l00343"></a>00343              left_overlap_boundaries
<a name="l00344"></a>00344             ,right_overlap_boundaries
<a name="l00345"></a>00345             ,projectors | transformed(FetchOverlapSite(current_site_number))
<a name="l00346"></a>00346         );
<a name="l00347"></a>00347 }
<a name="l00348"></a>00348 <span class="comment">//@+node:gcross.20110218083552.3113: *3* solveForMultipleLevels</span>
<a name="l00349"></a>00349 <span class="keywordtype">void</span> Chain::solveForMultipleLevels(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> number_of_levels) {
<a name="l00350"></a>00350     assert(number_of_levels+projectors.size() &lt;= maximum_number_of_levels);
<a name="l00351"></a>00351     <a class="code" href="group__Utilities.html#ga0c7b5dd039bcb1b7cbdcb6c738dd5945" title="Repeats a statement or block n times.">REPEAT</a>(number_of_levels-1) {
<a name="l00352"></a>00352         optimizeChain();
<a name="l00353"></a>00353         convertStateToProjectorAndReset();
<a name="l00354"></a>00354     }
<a name="l00355"></a>00355     optimizeChain();
<a name="l00356"></a>00356 }
<a name="l00357"></a>00357 <span class="comment">//@+node:gcross.20110208151104.1791: *3* sweepUntilConverged</span>
<a name="l00358"></a>00358 <span class="keywordtype">void</span> Chain::sweepUntilConverged() {
<a name="l00359"></a>00359     <span class="keywordtype">double</span> previous_energy = energy;
<a name="l00360"></a>00360     performOptimizationSweep();
<a name="l00361"></a>00361     <span class="keywordflow">while</span>(<a class="code" href="group__Utilities.html#ga04c647826f947bec8cc1b2013a6d11d6" title="Returns whether a and b do not match within the specified relative tolerance.">outsideTolerance</a>(previous_energy,energy,options.sweep_convergence_threshold)) {
<a name="l00362"></a>00362         previous_energy = energy;
<a name="l00363"></a>00363         performOptimizationSweep();
<a name="l00364"></a>00364     }
<a name="l00365"></a>00365     signalSweepsConverged();
<a name="l00366"></a>00366 }
<a name="l00367"></a>00367 <span class="comment">//@-others</span>
<a name="l00368"></a>00368 
<a name="l00369"></a>00369 }
<a name="l00370"></a>00370 <span class="comment">//@-leo</span>
</pre></div></div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Tue May 31 2011 16:30:04 for Nutcracker by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </small></address>
</body>
</html>
