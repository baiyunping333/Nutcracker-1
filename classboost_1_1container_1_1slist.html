<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Nutcracker: boost::container::slist&lt; T, A &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.2 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
  <div class="navpath">
    <ul>
      <li><b>boost</b>      </li>
      <li><b>container</b>      </li>
      <li><a class="el" href="classboost_1_1container_1_1slist.html">slist</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<h1>boost::container::slist&lt; T, A &gt; Class Template Reference</h1>  </div>
</div>
<div class="contents">
<!-- doxytag: class="boost::container::slist" --><!-- doxytag: inherits="node_alloc_holder&lt; A, containers_detail::intrusive_slist_type&lt; A &gt;::type &gt;" -->
<p><code>#include &lt;<a class="el" href="container_2slist_8hpp_source.html">slist.hpp</a>&gt;</code></p>
<!-- startSectionHeader --><div class="dynheader">
Inheritance diagram for boost::container::slist&lt; T, A &gt;:<!-- endSectionHeader --></div>
<!-- startSectionSummary --><!-- endSectionSummary --><!-- startSectionContent --><div class="dyncontent">
 <div class="center">
  <img src="classboost_1_1container_1_1slist.png" usemap="#boost::container::slist&lt; T, A &gt;_map" alt=""/>
  <map id="boost::container::slist&lt; T, A &gt;_map" name="boost::container::slist&lt; T, A &gt;_map">
<area href="structboost_1_1container_1_1containers__detail_1_1node__alloc__holder.html" alt="boost::container::containers_detail::node_alloc_holder&lt; A, containers_detail::intrusive_slist_type&lt; A &gt;::type &gt;" shape="rect" coords="0,0,628,24"/>
</map>
 </div><!-- endSectionContent --></div>

<p><a href="classboost_1_1container_1_1slist-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#ada1c51abfb494e8b0ac9230f2755f2ef">value_type</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acca92259bc3ac7a13762fb64741811c0"></a><!-- doxytag: member="boost::container::slist::pointer" ref="acca92259bc3ac7a13762fb64741811c0" args="" -->
typedef A::pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#acca92259bc3ac7a13762fb64741811c0">pointer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to T. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31b124f73d8218697f08654cee58e6c3"></a><!-- doxytag: member="boost::container::slist::const_pointer" ref="a31b124f73d8218697f08654cee58e6c3" args="" -->
typedef A::const_pointer&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a31b124f73d8218697f08654cee58e6c3">const_pointer</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Const pointer to T. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1feb29cf8a510172f24942110960bdc7"></a><!-- doxytag: member="boost::container::slist::reference" ref="a1feb29cf8a510172f24942110960bdc7" args="" -->
typedef A::reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a1feb29cf8a510172f24942110960bdc7">reference</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Reference to T. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6478a26d1db0284c60e53b3e6e3a2a25"></a><!-- doxytag: member="boost::container::slist::const_reference" ref="a6478a26d1db0284c60e53b3e6e3a2a25" args="" -->
typedef A::const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a6478a26d1db0284c60e53b3e6e3a2a25">const_reference</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Const reference to T. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac93e9211a0ecddfa243723dce515d12e"></a><!-- doxytag: member="boost::container::slist::size_type" ref="ac93e9211a0ecddfa243723dce515d12e" args="" -->
typedef A::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#ac93e9211a0ecddfa243723dce515d12e">size_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">An unsigned integral type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7a0d1c8b2e4eac602c431c9f10f55bb0"></a><!-- doxytag: member="boost::container::slist::difference_type" ref="a7a0d1c8b2e4eac602c431c9f10f55bb0" args="" -->
typedef A::difference_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a7a0d1c8b2e4eac602c431c9f10f55bb0">difference_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">A signed integral type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac85bda0d3cca109416d73067b6a7d1cf"></a><!-- doxytag: member="boost::container::slist::allocator_type" ref="ac85bda0d3cca109416d73067b6a7d1cf" args="" -->
typedef A&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#ac85bda0d3cca109416d73067b6a7d1cf">allocator_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The allocator type. <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6f10d494faa5b8429e6bf508bb09dd6"></a><!-- doxytag: member="boost::container::slist::stored_allocator_type" ref="ae6f10d494faa5b8429e6bf508bb09dd6" args="" -->
typedef NodeAlloc&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#ae6f10d494faa5b8429e6bf508bb09dd6">stored_allocator_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The stored allocator type. <br/></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#afed0716dbc4e971a9d7c77ea0706165d">slist</a> (const <a class="el" href="classboost_1_1container_1_1slist.html#ac85bda0d3cca109416d73067b6a7d1cf">allocator_type</a> &amp;a=<a class="el" href="classboost_1_1container_1_1slist.html#ac85bda0d3cca109416d73067b6a7d1cf">allocator_type</a>())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1b71cdf9199322da1a8ec58d6e0c412d"></a><!-- doxytag: member="boost::container::slist::slist" ref="a1b71cdf9199322da1a8ec58d6e0c412d" args="(size_type n)" -->
&#160;</td><td class="memItemRight" valign="bottom"><b>slist</b> (<a class="el" href="classboost_1_1container_1_1slist.html#ac93e9211a0ecddfa243723dce515d12e">size_type</a> n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#ad39df85f2476ca867e807d8b9981fc84">slist</a> (<a class="el" href="classboost_1_1container_1_1slist.html#ac93e9211a0ecddfa243723dce515d12e">size_type</a> n, const <a class="el" href="classboost_1_1container_1_1slist.html#ada1c51abfb494e8b0ac9230f2755f2ef">value_type</a> &amp;x, const <a class="el" href="classboost_1_1container_1_1slist.html#ac85bda0d3cca109416d73067b6a7d1cf">allocator_type</a> &amp;a=<a class="el" href="classboost_1_1container_1_1slist.html#ac85bda0d3cca109416d73067b6a7d1cf">allocator_type</a>())</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InpIt &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a176d180c27481607fbd61a47fa78b00b">slist</a> (InpIt first, InpIt last, const <a class="el" href="classboost_1_1container_1_1slist.html#ac85bda0d3cca109416d73067b6a7d1cf">allocator_type</a> &amp;a=<a class="el" href="classboost_1_1container_1_1slist.html#ac85bda0d3cca109416d73067b6a7d1cf">allocator_type</a>())</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a4319c1c8eab4d3e5f0b1807530296909">slist</a> (const <a class="el" href="classboost_1_1container_1_1slist.html">slist</a> &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#aba895a83456a75200cc4057e06aa41ce">slist</a> (BOOST_MOVE_MACRO_RV_REF(<a class="el" href="classboost_1_1container_1_1slist.html">slist</a>) x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1slist.html">slist</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#af70980a0d0f05e2eb0721adade8b0722">operator=</a> (BOOST_MOVE_MACRO_COPY_ASSIGN_REF(<a class="el" href="classboost_1_1container_1_1slist.html">slist</a>) x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1slist.html">slist</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a5fd79456f09cf308db6f14eaedfcb987">operator=</a> (BOOST_MOVE_MACRO_RV_REF(<a class="el" href="classboost_1_1container_1_1slist.html">slist</a>) mx)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a7294b29d7d08ebb767dcf10726084d70">~slist</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1slist.html#ac85bda0d3cca109416d73067b6a7d1cf">allocator_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a5e5721548caee1c17e1e3578e5bd8b23">get_allocator</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3956eeaf3a9bfe713cbb9a71857946d9"></a><!-- doxytag: member="boost::container::slist::get_stored_allocator" ref="a3956eeaf3a9bfe713cbb9a71857946d9" args="() const " -->
const <a class="el" href="classboost_1_1container_1_1slist.html#ae6f10d494faa5b8429e6bf508bb09dd6">stored_allocator_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_stored_allocator</b> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aed2adb43d5c0628aa3387335552a1594"></a><!-- doxytag: member="boost::container::slist::get_stored_allocator" ref="aed2adb43d5c0628aa3387335552a1594" args="()" -->
<a class="el" href="classboost_1_1container_1_1slist.html#ae6f10d494faa5b8429e6bf508bb09dd6">stored_allocator_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_stored_allocator</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a765027edbbbf91e991bab993c92e4835">assign</a> (<a class="el" href="classboost_1_1container_1_1slist.html#ac93e9211a0ecddfa243723dce515d12e">size_type</a> n, const T &amp;val)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InpIt &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a0e4a7380e4dff16504f438c8ded10250">assign</a> (InpIt first, InpIt last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a83778601ebfcbb90c1d17b845a649e1f">begin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#aa23f35140e4bb099fee3b4f07323d782">begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#ab31a233f7bc667ad2d5ff44049948c77">end</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#aba9529782f39988a30fd6b48c0f56093">end</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a36e8fb28547d1bb543739a64b5127fcd">before_begin</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a0ed8b47ec2120d0d338ed0871a199406">before_begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a7f32d7422faa2a97f59b23b3c6754020">cbegin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a08c472b2fe0b86bbe334a605fe5b9be3">cend</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#ac82567a19ab4246ca34225b037295049">cbefore_begin</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1slist.html#ac93e9211a0ecddfa243723dce515d12e">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#ace7731b692473cd2d8e98bad96f3a71e">size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1slist.html#ac93e9211a0ecddfa243723dce515d12e">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#aab512694fac6eab6ee94237299a82d9f">max_size</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a665e2c0fc61750320d3d62d2648a6276">empty</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a9e8b4db5db0ec61e560b5c2616892bf3">swap</a> (<a class="el" href="classboost_1_1container_1_1slist.html">slist</a> &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1slist.html#a1feb29cf8a510172f24942110960bdc7">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a8195679aaa8458166ec22f2378801ac5">front</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="classboost_1_1container_1_1slist.html#a6478a26d1db0284c60e53b3e6e3a2a25">const_reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a9948c6c540c6bd7fd60b5ce858bb231d">front</a> () const </td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a988baa9a1d08f6a7966650c3226e5361">push_front</a> (insert_const_ref_type x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#ab0f42ef62ee770b718bbeb0726c992ec">push_front</a> (BOOST_MOVE_MACRO_RV_REF(T) x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#ae714555fc9a24f0e03a5c93cf169bc3b">pop_front</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a782bb218b62967d3b6b8faa9c7633388">previous</a> (iterator p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#ae63dcc0c1c4b62b40d769bba986d90ff">previous</a> (const_iterator p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a356419d381448a8e2f6e5378c73af478">insert_after</a> (const_iterator prev_pos, insert_const_ref_type x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#ad2b2cc0fa033338cae5f3ee87c4a221e">insert_after</a> (const_iterator prev_pos, BOOST_MOVE_MACRO_RV_REF(<a class="el" href="classboost_1_1container_1_1slist.html#ada1c51abfb494e8b0ac9230f2755f2ef">value_type</a>) x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a92cd2669e737e67588ebabd07193f0e7">insert_after</a> (const_iterator prev_pos, <a class="el" href="classboost_1_1container_1_1slist.html#ac93e9211a0ecddfa243723dce515d12e">size_type</a> n, const <a class="el" href="classboost_1_1container_1_1slist.html#ada1c51abfb494e8b0ac9230f2755f2ef">value_type</a> &amp;x)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InIter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a4b2950b3c94cf8c4aaf95dcbfbef6e24">insert_after</a> (const_iterator prev_pos, InIter first, InIter last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#aba22191316aaf4c741036fc2bbb9b71d">insert</a> (const_iterator position, insert_const_ref_type x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#ae7f90e422d1dadc1fa58ca449585643b">insert</a> (const_iterator p, BOOST_MOVE_MACRO_RV_REF(<a class="el" href="classboost_1_1container_1_1slist.html#ada1c51abfb494e8b0ac9230f2755f2ef">value_type</a>) x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a55c75694fff07e3e492eb8b3b08aaf78">insert</a> (const_iterator p, <a class="el" href="classboost_1_1container_1_1slist.html#ac93e9211a0ecddfa243723dce515d12e">size_type</a> n, const <a class="el" href="classboost_1_1container_1_1slist.html#ada1c51abfb494e8b0ac9230f2755f2ef">value_type</a> &amp;x)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class InIter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#aaf97ae5274a9278447843fdd2d4c64b6">insert</a> (const_iterator p, InIter first, InIter last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa0a3be99331836dcea579cb012b5969d"></a><!-- doxytag: member="boost::container::slist::emplace_front" ref="aa0a3be99331836dcea579cb012b5969d" args="()" -->
void&#160;</td><td class="memItemRight" valign="bottom"><b>emplace_front</b> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a07519ebf8b1a42e4760df67ce8b2d5ef"></a><!-- doxytag: member="boost::container::slist::emplace" ref="a07519ebf8b1a42e4760df67ce8b2d5ef" args="(const_iterator p)" -->
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>emplace</b> (const_iterator p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef6658761c53b0d03817b06a9d5d8cb3"></a><!-- doxytag: member="boost::container::slist::emplace_after" ref="aef6658761c53b0d03817b06a9d5d8cb3" args="(const_iterator prev)" -->
iterator&#160;</td><td class="memItemRight" valign="bottom"><b>emplace_after</b> (const_iterator prev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a4c850dfbd4c7673e4002ff91fb812480">erase_after</a> (const_iterator prev_pos)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#ac2c1b7bb94c6b2e240b5e941405baaeb">erase_after</a> (const_iterator before_first, const_iterator last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a2b791b9611437bc29736798e24757fca">erase</a> (const_iterator p)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#aca105ac54bf8e90659064f790d215795">erase</a> (const_iterator first, const_iterator last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a6b6f69dfe2ce62c4fb1859c4696e713a">resize</a> (<a class="el" href="classboost_1_1container_1_1slist.html#ac93e9211a0ecddfa243723dce515d12e">size_type</a> new_size, const T &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a0429408127f055b47136cc6235785db2">resize</a> (<a class="el" href="classboost_1_1container_1_1slist.html#ac93e9211a0ecddfa243723dce515d12e">size_type</a> new_size)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a458d9a0664b6cf95ae24c6e6fcdbadd6">clear</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a8478921b26695823774873e2b9210d78">splice_after</a> (const_iterator prev_pos, <a class="el" href="classboost_1_1container_1_1slist.html">slist</a> &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#aa52d95249b51ee315f97e57a79ff3ebe">splice_after</a> (const_iterator prev_pos, <a class="el" href="classboost_1_1container_1_1slist.html">slist</a> &amp;x, const_iterator prev)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#ac18a9dfbebdc4b4117103a14e232e12d">splice_after</a> (const_iterator prev_pos, <a class="el" href="classboost_1_1container_1_1slist.html">slist</a> &amp;x, const_iterator before_first, const_iterator before_last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a39ed20410525a2047336b2bb29537473">splice_after</a> (const_iterator prev_pos, <a class="el" href="classboost_1_1container_1_1slist.html">slist</a> &amp;x, const_iterator before_first, const_iterator before_last, <a class="el" href="classboost_1_1container_1_1slist.html#ac93e9211a0ecddfa243723dce515d12e">size_type</a> n)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#acb75ab5d9b97ccf70e927e7dfd877346">splice</a> (const_iterator p, ThisType &amp;x)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#ae34fa1becf9754217369137129f26695">splice</a> (const_iterator p, <a class="el" href="classboost_1_1container_1_1slist.html">slist</a> &amp;x, const_iterator i)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a5a21930d1e858b266d350c7b4c098e18">splice</a> (const_iterator p, <a class="el" href="classboost_1_1container_1_1slist.html">slist</a> &amp;x, const_iterator first, const_iterator last)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#aead3367979d00925eea1ca46cb1a6eb4">reverse</a> ()</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#af34a9bc735684e7d34e1a35f69aeb605">remove</a> (const T &amp;value)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Pred &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a93e9d031f9196211bea4f517ac51bcd3">remove_if</a> (Pred pred)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a0a3cf376f4df477bee9e6fd913780bff">unique</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Pred &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a8f1a249068eda323d8be6b8556231aff">unique</a> (Pred pred)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#abc7ac2e57d984ab48ce2101e95ec1fe4">merge</a> (<a class="el" href="classboost_1_1container_1_1slist.html">slist</a> &amp;x)</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class StrictWeakOrdering &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#ae106c72d867f2535c75cb34400c78f53">merge</a> (<a class="el" href="classboost_1_1container_1_1slist.html">slist</a> &amp;x, StrictWeakOrdering comp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#ae77eae4e54a3b5939a6a1ec276abaa38">sort</a> ()</td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class StrictWeakOrdering &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classboost_1_1container_1_1slist.html#a5b856e750a9b6e9d4813af4d6db2e17f">sort</a> (StrictWeakOrdering comp)</td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<h3>template&lt;class T, class A&gt;<br/>
 class boost::container::slist&lt; T, A &gt;</h3>

<p>An slist is a singly linked list: a list where each element is linked to the next element, but not to the previous element. That is, it is a Sequence that supports forward but not backward traversal, and (amortized) constant time insertion and removal of elements. Slists, like lists, have the important property that insertion and splicing do not invalidate iterators to list elements, and that even removal invalidates only the iterators that point to the elements that are removed. The ordering of iterators may be changed (that is, slist&lt;T&gt;::iterator might have a different predecessor or successor after a list operation than it did before), but the iterators themselves will not be invalidated or made to point to different elements unless that invalidation or mutation is explicit.</p>
<p>The main difference between slist and list is that list's iterators are bidirectional iterators, while slist's iterators are forward iterators. This means that slist is less versatile than list; frequently, however, bidirectional iterators are unnecessary. You should usually use slist unless you actually need the extra functionality of list, because singly linked lists are smaller and faster than double linked lists.</p>
<p>Important performance note: like every other Sequence, slist defines the member functions insert and erase. Using these member functions carelessly, however, can result in disastrously slow programs. The problem is that insert's first argument is an iterator p, and that it inserts the new element(s) before p. This means that insert must find the iterator just before p; this is a constant-time operation for list, since list has bidirectional iterators, but for slist it must find that iterator by traversing the list from the beginning up to p. In other words: insert and erase are slow operations anywhere but near the beginning of the slist.</p>
<p>Slist provides the member functions insert_after and erase_after, which are constant time operations: you should always use insert_after and erase_after whenever possible. If you find that insert_after and erase_after aren't adequate for your needs, and that you often need to use insert and erase in the middle of the list, then you should probably use list instead of slist. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00154">154</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>
<hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="ada1c51abfb494e8b0ac9230f2755f2ef"></a><!-- doxytag: member="boost::container::slist::value_type" ref="ada1c51abfb494e8b0ac9230f2755f2ef" args="" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef T <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::<a class="el" href="classboost_1_1container_1_1slist.html#ada1c51abfb494e8b0ac9230f2755f2ef">value_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The type of object, T, stored in the list </p>

<p>Reimplemented from <a class="el" href="structboost_1_1container_1_1containers__detail_1_1node__alloc__holder.html">boost::container::containers_detail::node_alloc_holder&lt; A, containers_detail::intrusive_slist_type&lt; A &gt;::type &gt;</a>.</p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00205">205</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="afed0716dbc4e971a9d7c77ea0706165d"></a><!-- doxytag: member="boost::container::slist::slist" ref="afed0716dbc4e971a9d7c77ea0706165d" args="(const allocator_type &amp;a=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::<a class="el" href="classboost_1_1container_1_1slist.html">slist</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1container_1_1slist.html#ac85bda0d3cca109416d73067b6a7d1cf">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"> <em>a</em> = <code><a class="el" href="classboost_1_1container_1_1slist.html#ac85bda0d3cca109416d73067b6a7d1cf">allocator_type</a>()</code>&#160;)</td>
          <td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Constructs a list taking the allocator as parameter.</p>
<p><b>Throws</b>: If allocator_type's copy constructor throws.</p>
<p><b>Complexity</b>: Constant. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00327">327</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad39df85f2476ca867e807d8b9981fc84"></a><!-- doxytag: member="boost::container::slist::slist" ref="ad39df85f2476ca867e807d8b9981fc84" args="(size_type n, const value_type &amp;x, const allocator_type &amp;a=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::<a class="el" href="classboost_1_1container_1_1slist.html">slist</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1slist.html#ac93e9211a0ecddfa243723dce515d12e">size_type</a>&#160;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1container_1_1slist.html#ada1c51abfb494e8b0ac9230f2755f2ef">value_type</a> &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1container_1_1slist.html#ac85bda0d3cca109416d73067b6a7d1cf">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"> <em>a</em> = <code><a class="el" href="classboost_1_1container_1_1slist.html#ac85bda0d3cca109416d73067b6a7d1cf">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, explicit]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Constructs a list that will use a copy of allocator a and inserts n copies of value.</p>
<p><b>Throws</b>: If allocator_type's default constructor or copy constructor throws or T's default or copy constructor throws.</p>
<p><b>Complexity</b>: Linear to n. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00342">342</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a176d180c27481607fbd61a47fa78b00b"></a><!-- doxytag: member="boost::container::slist::slist" ref="a176d180c27481607fbd61a47fa78b00b" args="(InpIt first, InpIt last, const allocator_type &amp;a=allocator_type())" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
<div class="memtemplate">
template&lt;class InpIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::<a class="el" href="classboost_1_1container_1_1slist.html">slist</a> </td>
          <td>(</td>
          <td class="paramtype">InpIt&#160;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InpIt&#160;</td>
          <td class="paramname"> <em>last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1container_1_1slist.html#ac85bda0d3cca109416d73067b6a7d1cf">allocator_type</a> &amp;&#160;</td>
          <td class="paramname"> <em>a</em> = <code><a class="el" href="classboost_1_1container_1_1slist.html#ac85bda0d3cca109416d73067b6a7d1cf">allocator_type</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Constructs a list that will use a copy of allocator a and inserts a copy of the range [first, last) in the list.</p>
<p><b>Throws</b>: If allocator_type's default constructor or copy constructor throws or T's constructor taking an dereferenced InIt throws.</p>
<p><b>Complexity</b>: Linear to the range [first, last). </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00354">354</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4319c1c8eab4d3e5f0b1807530296909"></a><!-- doxytag: member="boost::container::slist::slist" ref="a4319c1c8eab4d3e5f0b1807530296909" args="(const slist &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::<a class="el" href="classboost_1_1container_1_1slist.html">slist</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classboost_1_1container_1_1slist.html">slist</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Copy constructs a list.</p>
<p><b>Postcondition</b>: x == *this.</p>
<p><b>Throws</b>: If allocator_type's default constructor or copy constructor throws.</p>
<p><b>Complexity</b>: Linear to the elements x contains. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00366">366</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aba895a83456a75200cc4057e06aa41ce"></a><!-- doxytag: member="boost::container::slist::slist" ref="aba895a83456a75200cc4057e06aa41ce" args="(BOOST_MOVE_MACRO_RV_REF(slist) x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::<a class="el" href="classboost_1_1container_1_1slist.html">slist</a> </td>
          <td>(</td>
          <td class="paramtype">BOOST_MOVE_MACRO_RV_REF(<a class="el" href="classboost_1_1container_1_1slist.html">slist</a>&lt; T, A &gt;)&#160;</td>
          <td class="paramname"> <em>x</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Move constructor. Moves mx's resources to *this.</p>
<p><b>Throws</b>: If allocator_type's copy constructor throws.</p>
<p><b>Complexity</b>: Constant. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00375">375</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7294b29d7d08ebb767dcf10726084d70"></a><!-- doxytag: member="boost::container::slist::~slist" ref="a7294b29d7d08ebb767dcf10726084d70" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::~<a class="el" href="classboost_1_1container_1_1slist.html">slist</a> </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Destroys the list. All stored values are destroyed and used memory is deallocated.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Linear to the number of elements. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00418">418</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="a765027edbbbf91e991bab993c92e4835"></a><!-- doxytag: member="boost::container::slist::assign" ref="a765027edbbbf91e991bab993c92e4835" args="(size_type n, const T &amp;val)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::assign </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1slist.html#ac93e9211a0ecddfa243723dce515d12e">size_type</a>&#160;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"> <em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Assigns the n copies of val to *this.</p>
<p><b>Throws</b>: If memory allocation throws or T's copy constructor throws.</p>
<p><b>Complexity</b>: Linear to n. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00442">442</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0e4a7380e4dff16504f438c8ded10250"></a><!-- doxytag: member="boost::container::slist::assign" ref="a0e4a7380e4dff16504f438c8ded10250" args="(InpIt first, InpIt last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
<div class="memtemplate">
template&lt;class InpIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::assign </td>
          <td>(</td>
          <td class="paramtype">InpIt&#160;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InpIt&#160;</td>
          <td class="paramname"> <em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Assigns the range [first, last) to *this.</p>
<p><b>Throws</b>: If memory allocation throws or T's constructor from dereferencing InpIt throws.</p>
<p><b>Complexity</b>: Linear to n. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00452">452</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a36e8fb28547d1bb543739a64b5127fcd"></a><!-- doxytag: member="boost::container::slist::before_begin" ref="a36e8fb28547d1bb543739a64b5127fcd" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::before_begin </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns a non-dereferenceable iterator that, when incremented, yields <a class="el" href="classboost_1_1container_1_1slist.html#a83778601ebfcbb90c1d17b845a649e1f">begin()</a>. This iterator may be used as the argument toinsert_after, erase_after, etc.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Constant. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00498">498</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0ed8b47ec2120d0d338ed0871a199406"></a><!-- doxytag: member="boost::container::slist::before_begin" ref="a0ed8b47ec2120d0d338ed0871a199406" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::before_begin </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns a non-dereferenceable const_iterator that, when incremented, yields <a class="el" href="classboost_1_1container_1_1slist.html#a83778601ebfcbb90c1d17b845a649e1f">begin()</a>. This iterator may be used as the argument toinsert_after, erase_after, etc.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Constant. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00508">508</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a83778601ebfcbb90c1d17b845a649e1f"></a><!-- doxytag: member="boost::container::slist::begin" ref="a83778601ebfcbb90c1d17b845a649e1f" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::begin </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns an iterator to the first element contained in the list.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Constant. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00464">464</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa23f35140e4bb099fee3b4f07323d782"></a><!-- doxytag: member="boost::container::slist::begin" ref="aa23f35140e4bb099fee3b4f07323d782" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::begin </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns a const_iterator to the first element contained in the list.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Constant. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00472">472</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac82567a19ab4246ca34225b037295049"></a><!-- doxytag: member="boost::container::slist::cbefore_begin" ref="ac82567a19ab4246ca34225b037295049" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::cbefore_begin </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns a non-dereferenceable const_iterator that, when incremented, yields <a class="el" href="classboost_1_1container_1_1slist.html#a83778601ebfcbb90c1d17b845a649e1f">begin()</a>. This iterator may be used as the argument toinsert_after, erase_after, etc.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Constant. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00534">534</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7f32d7422faa2a97f59b23b3c6754020"></a><!-- doxytag: member="boost::container::slist::cbegin" ref="a7f32d7422faa2a97f59b23b3c6754020" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::cbegin </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns a const_iterator to the first element contained in the list.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Constant. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00516">516</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a08c472b2fe0b86bbe334a605fe5b9be3"></a><!-- doxytag: member="boost::container::slist::cend" ref="a08c472b2fe0b86bbe334a605fe5b9be3" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::cend </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns a const_iterator to the end of the list.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Constant. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00524">524</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a458d9a0664b6cf95ae24c6e6fcdbadd6"></a><!-- doxytag: member="boost::container::slist::clear" ref="a458d9a0664b6cf95ae24c6e6fcdbadd6" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::clear </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Erases all the elements of the list.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Linear to the number of elements in the list. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00966">966</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a665e2c0fc61750320d3d62d2648a6276"></a><!-- doxytag: member="boost::container::slist::empty" ref="a665e2c0fc61750320d3d62d2648a6276" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::empty </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns true if the list contains no elements.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Constant. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00558">558</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab31a233f7bc667ad2d5ff44049948c77"></a><!-- doxytag: member="boost::container::slist::end" ref="ab31a233f7bc667ad2d5ff44049948c77" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::end </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns an iterator to the end of the list.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Constant. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00480">480</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aba9529782f39988a30fd6b48c0f56093"></a><!-- doxytag: member="boost::container::slist::end" ref="aba9529782f39988a30fd6b48c0f56093" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::end </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns a const_iterator to the end of the list.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Constant. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00488">488</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2b791b9611437bc29736798e24757fca"></a><!-- doxytag: member="boost::container::slist::erase" ref="a2b791b9611437bc29736798e24757fca" args="(const_iterator p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>p</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: p must be a valid iterator of *this.</p>
<p><b>Effects</b>: Erases the element at p p.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Linear to the number of elements before p. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00904">904</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca105ac54bf8e90659064f790d215795"></a><!-- doxytag: member="boost::container::slist::erase" ref="aca105ac54bf8e90659064f790d215795" args="(const_iterator first, const_iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::erase </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: first and last must be valid iterator to elements in *this.</p>
<p><b>Effects</b>: Erases the elements pointed by [first, last).</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Linear to the distance between first and last plus linear to the elements before first. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00915">915</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4c850dfbd4c7673e4002ff91fb812480"></a><!-- doxytag: member="boost::container::slist::erase_after" ref="a4c850dfbd4c7673e4002ff91fb812480" args="(const_iterator prev_pos)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::erase_after </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>prev_pos</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Erases the element after the element pointed by prev_pos of the list.</p>
<p><b>Returns</b>: the first element remaining beyond the removed elements, or <a class="el" href="classboost_1_1container_1_1slist.html#ab31a233f7bc667ad2d5ff44049948c77">end()</a> if no such element exists.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Note</b>: Does not invalidate iterators or references to non erased elements. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00876">876</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac2c1b7bb94c6b2e240b5e941405baaeb"></a><!-- doxytag: member="boost::container::slist::erase_after" ref="ac2c1b7bb94c6b2e240b5e941405baaeb" args="(const_iterator before_first, const_iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::erase_after </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>before_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Erases the range (before_first, last) from the list.</p>
<p><b>Returns</b>: the first element remaining beyond the removed elements, or <a class="el" href="classboost_1_1container_1_1slist.html#ab31a233f7bc667ad2d5ff44049948c77">end()</a> if no such element exists.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Linear to the number of erased elements.</p>
<p><b>Note</b>: Does not invalidate iterators or references to non erased elements. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00892">892</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8195679aaa8458166ec22f2378801ac5"></a><!-- doxytag: member="boost::container::slist::front" ref="a8195679aaa8458166ec22f2378801ac5" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1slist.html#a1feb29cf8a510172f24942110960bdc7">reference</a> <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::front </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: !empty()</p>
<p><b>Effects</b>: Returns a reference to the first element from the beginning of the container.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Constant. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00579">579</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9948c6c540c6bd7fd60b5ce858bb231d"></a><!-- doxytag: member="boost::container::slist::front" ref="a9948c6c540c6bd7fd60b5ce858bb231d" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1slist.html#a6478a26d1db0284c60e53b3e6e3a2a25">const_reference</a> <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::front </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: !empty()</p>
<p><b>Effects</b>: Returns a const reference to the first element from the beginning of the container.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Constant. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00590">590</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5e5721548caee1c17e1e3578e5bd8b23"></a><!-- doxytag: member="boost::container::slist::get_allocator" ref="a5e5721548caee1c17e1e3578e5bd8b23" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1slist.html#ac85bda0d3cca109416d73067b6a7d1cf">allocator_type</a> <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::get_allocator </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns a copy of the internal allocator.</p>
<p><b>Throws</b>: If allocator's copy constructor throws.</p>
<p><b>Complexity</b>: Constant. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00426">426</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aba22191316aaf4c741036fc2bbb9b71d"></a><!-- doxytag: member="boost::container::slist::insert" ref="aba22191316aaf4c741036fc2bbb9b71d" args="(const_iterator position, insert_const_ref_type x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">insert_const_ref_type&#160;</td>
          <td class="paramname"> <em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: p must be a valid iterator of *this.</p>
<p><b>Effects</b>: Insert a copy of x before p.</p>
<p><b>Throws</b>: If memory allocation throws or x's copy constructor throws.</p>
<p><b>Complexity</b>: Linear to the elements before p. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00728">728</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae7f90e422d1dadc1fa58ca449585643b"></a><!-- doxytag: member="boost::container::slist::insert" ref="ae7f90e422d1dadc1fa58ca449585643b" args="(const_iterator p, BOOST_MOVE_MACRO_RV_REF(value_type) x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOST_MOVE_MACRO_RV_REF(<a class="el" href="classboost_1_1container_1_1slist.html#ada1c51abfb494e8b0ac9230f2755f2ef">value_type</a>)&#160;</td>
          <td class="paramname"> <em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: p must be a valid iterator of *this.</p>
<p><b>Effects</b>: Insert a new element before p with mx's resources.</p>
<p><b>Throws</b>: If memory allocation throws.</p>
<p><b>Complexity</b>: Linear to the elements before p. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00747">747</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a55c75694fff07e3e492eb8b3b08aaf78"></a><!-- doxytag: member="boost::container::slist::insert" ref="a55c75694fff07e3e492eb8b3b08aaf78" args="(const_iterator p, size_type n, const value_type &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1slist.html#ac93e9211a0ecddfa243723dce515d12e">size_type</a>&#160;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1container_1_1slist.html#ada1c51abfb494e8b0ac9230f2755f2ef">value_type</a> &amp;&#160;</td>
          <td class="paramname"> <em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: p must be a valid iterator of *this.</p>
<p><b>Effects</b>: Inserts n copies of x before p.</p>
<p><b>Throws</b>: If memory allocation throws or T's copy constructor throws.</p>
<p><b>Complexity</b>: Linear to n plus linear to the elements before p. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00757">757</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aaf97ae5274a9278447843fdd2d4c64b6"></a><!-- doxytag: member="boost::container::slist::insert" ref="aaf97ae5274a9278447843fdd2d4c64b6" args="(const_iterator p, InIter first, InIter last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
<div class="memtemplate">
template&lt;class InIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::insert </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InIter&#160;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InIter&#160;</td>
          <td class="paramname"> <em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: p must be a valid iterator of *this.</p>
<p><b>Effects</b>: Insert a copy of the [first, last) range before p.</p>
<p><b>Throws</b>: If memory allocation throws, T's constructor from a dereferenced InpIt throws.</p>
<p><b>Complexity</b>: Linear to std::distance [first, last) plus linear to the elements before p. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00770">770</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a356419d381448a8e2f6e5378c73af478"></a><!-- doxytag: member="boost::container::slist::insert_after" ref="a356419d381448a8e2f6e5378c73af478" args="(const_iterator prev_pos, insert_const_ref_type x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::insert_after </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>prev_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">insert_const_ref_type&#160;</td>
          <td class="paramname"> <em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: p must be a valid iterator of *this.</p>
<p><b>Effects</b>: Inserts a copy of the value after the p pointed by prev_p.</p>
<p><b>Returns</b>: An iterator to the inserted element.</p>
<p><b>Throws</b>: If memory allocation throws or T's copy constructor throws.</p>
<p><b>Complexity</b>: Amortized constant time.</p>
<p><b>Note</b>: Does not affect the validity of iterators and references of previous values. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00660">660</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad2b2cc0fa033338cae5f3ee87c4a221e"></a><!-- doxytag: member="boost::container::slist::insert_after" ref="ad2b2cc0fa033338cae5f3ee87c4a221e" args="(const_iterator prev_pos, BOOST_MOVE_MACRO_RV_REF(value_type) x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::insert_after </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>prev_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BOOST_MOVE_MACRO_RV_REF(<a class="el" href="classboost_1_1container_1_1slist.html#ada1c51abfb494e8b0ac9230f2755f2ef">value_type</a>)&#160;</td>
          <td class="paramname"> <em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: prev_pos must be a valid iterator of *this.</p>
<p><b>Effects</b>: Inserts a move constructed copy object from the value after the p pointed by prev_pos.</p>
<p><b>Returns</b>: An iterator to the inserted element.</p>
<p><b>Throws</b>: If memory allocation throws.</p>
<p><b>Complexity</b>: Amortized constant time.</p>
<p><b>Note</b>: Does not affect the validity of iterators and references of previous values. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00685">685</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a92cd2669e737e67588ebabd07193f0e7"></a><!-- doxytag: member="boost::container::slist::insert_after" ref="a92cd2669e737e67588ebabd07193f0e7" args="(const_iterator prev_pos, size_type n, const value_type &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::insert_after </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>prev_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1slist.html#ac93e9211a0ecddfa243723dce515d12e">size_type</a>&#160;</td>
          <td class="paramname"> <em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classboost_1_1container_1_1slist.html#ada1c51abfb494e8b0ac9230f2755f2ef">value_type</a> &amp;&#160;</td>
          <td class="paramname"> <em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: prev_pos must be a valid iterator of *this.</p>
<p><b>Effects</b>: Inserts n copies of x after prev_pos.</p>
<p><b>Throws</b>: If memory allocation throws or T's copy constructor throws.</p>
<p><b>Complexity</b>: Linear to n.</p>
<p><b>Note</b>: Does not affect the validity of iterators and references of previous values. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00698">698</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4b2950b3c94cf8c4aaf95dcbfbef6e24"></a><!-- doxytag: member="boost::container::slist::insert_after" ref="a4b2950b3c94cf8c4aaf95dcbfbef6e24" args="(const_iterator prev_pos, InIter first, InIter last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
<div class="memtemplate">
template&lt;class InIter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::insert_after </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>prev_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InIter&#160;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InIter&#160;</td>
          <td class="paramname"> <em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: prev_pos must be a valid iterator of *this.</p>
<p><b>Effects</b>: Inserts the range pointed by [first, last) after the p prev_pos.</p>
<p><b>Throws</b>: If memory allocation throws, T's constructor from a dereferenced InpIt throws.</p>
<p><b>Complexity</b>: Linear to the number of elements inserted.</p>
<p><b>Note</b>: Does not affect the validity of iterators and references of previous values. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00714">714</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aab512694fac6eab6ee94237299a82d9f"></a><!-- doxytag: member="boost::container::slist::max_size" ref="aab512694fac6eab6ee94237299a82d9f" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1slist.html#ac93e9211a0ecddfa243723dce515d12e">size_type</a> <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::max_size </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns the largest possible size of the list.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Constant. </p>

<p>Reimplemented from <a class="el" href="structboost_1_1container_1_1containers__detail_1_1node__alloc__holder.html">boost::container::containers_detail::node_alloc_holder&lt; A, containers_detail::intrusive_slist_type&lt; A &gt;::type &gt;</a>.</p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00550">550</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abc7ac2e57d984ab48ce2101e95ec1fe4"></a><!-- doxytag: member="boost::container::slist::merge" ref="abc7ac2e57d984ab48ce2101e95ec1fe4" args="(slist &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1slist.html">slist</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: The lists x and *this must be distinct.</p>
<p><b>Effects</b>: This function removes all of x's elements and inserts them in order into *this according to std::less&lt;value_type&gt;. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: This function is linear time: it performs at most <a class="el" href="classboost_1_1container_1_1slist.html#ace7731b692473cd2d8e98bad96f3a71e">size()</a> + x.size() - 1 comparisons. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l01196">1196</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae106c72d867f2535c75cb34400c78f53"></a><!-- doxytag: member="boost::container::slist::merge" ref="ae106c72d867f2535c75cb34400c78f53" args="(slist &amp;x, StrictWeakOrdering comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
<div class="memtemplate">
template&lt;class StrictWeakOrdering &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1slist.html">slist</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakOrdering&#160;</td>
          <td class="paramname"> <em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: p must be a comparison function that induces a strict weak ordering and both *this and x must be sorted according to that ordering The lists x and *this must be distinct.</p>
<p><b>Effects</b>: This function removes all of x's elements and inserts them in order into *this. The merge is stable; that is, if an element from *this is equivalent to one from x, then the element from *this will precede the one from x.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: This function is linear time: it performs at most <a class="el" href="classboost_1_1container_1_1slist.html#ace7731b692473cd2d8e98bad96f3a71e">size()</a> + x.size() - 1 comparisons.</p>
<p><b>Note</b>: Iterators and references to *this are not invalidated. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l01214">1214</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5fd79456f09cf308db6f14eaedfcb987"></a><!-- doxytag: member="boost::container::slist::operator=" ref="a5fd79456f09cf308db6f14eaedfcb987" args="(BOOST_MOVE_MACRO_RV_REF(slist) mx)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1slist.html">slist</a>&amp; <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">BOOST_MOVE_MACRO_RV_REF(<a class="el" href="classboost_1_1container_1_1slist.html">slist</a>&lt; T, A &gt;)&#160;</td>
          <td class="paramname"> <em>mx</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Makes *this contain the same elements as x.</p>
<p><b>Postcondition</b>: this-&gt;<a class="el" href="classboost_1_1container_1_1slist.html#ace7731b692473cd2d8e98bad96f3a71e">size()</a> == x.size(). *this contains a copy of each of x's elements.</p>
<p><b>Throws</b>: If memory allocation throws or T's copy constructor throws.</p>
<p><b>Complexity</b>: Linear to the number of elements in x. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00403">403</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af70980a0d0f05e2eb0721adade8b0722"></a><!-- doxytag: member="boost::container::slist::operator=" ref="af70980a0d0f05e2eb0721adade8b0722" args="(BOOST_MOVE_MACRO_COPY_ASSIGN_REF(slist) x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1slist.html">slist</a>&amp; <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">BOOST_MOVE_MACRO_COPY_ASSIGN_REF(<a class="el" href="classboost_1_1container_1_1slist.html">slist</a>&lt; T, A &gt;)&#160;</td>
          <td class="paramname"> <em>x</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Makes *this contain the same elements as x.</p>
<p><b>Postcondition</b>: this-&gt;<a class="el" href="classboost_1_1container_1_1slist.html#ace7731b692473cd2d8e98bad96f3a71e">size()</a> == x.size(). *this contains a copy of each of x's elements.</p>
<p><b>Throws</b>: If memory allocation throws or T's copy constructor throws.</p>
<p><b>Complexity</b>: Linear to the number of elements in x. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00387">387</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae714555fc9a24f0e03a5c93cf169bc3b"></a><!-- doxytag: member="boost::container::slist::pop_front" ref="ae714555fc9a24f0e03a5c93cf169bc3b" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::pop_front </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Removes the first element from the list.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Amortized constant time. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00624">624</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae63dcc0c1c4b62b40d769bba986d90ff"></a><!-- doxytag: member="boost::container::slist::previous" ref="ae63dcc0c1c4b62b40d769bba986d90ff" args="(const_iterator p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::previous </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>p</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Returns</b>: The const_iterator to the element before i in the sequence. Returns the end-const_iterator, if either i is the begin-const_iterator or the sequence is empty.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Linear to the number of elements before i. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00644">644</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a782bb218b62967d3b6b8faa9c7633388"></a><!-- doxytag: member="boost::container::slist::previous" ref="a782bb218b62967d3b6b8faa9c7633388" args="(iterator p)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::previous </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"> <em>p</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Returns</b>: The iterator to the element before i in the sequence. Returns the end-iterator, if either i is the begin-iterator or the sequence is empty.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Linear to the number of elements before i. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00634">634</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a988baa9a1d08f6a7966650c3226e5361"></a><!-- doxytag: member="boost::container::slist::push_front" ref="a988baa9a1d08f6a7966650c3226e5361" args="(insert_const_ref_type x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">insert_const_ref_type&#160;</td>
          <td class="paramname"> <em>x</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Inserts a copy of t in the beginning of the list.</p>
<p><b>Throws</b>: If memory allocation throws or T's copy constructor throws.</p>
<p><b>Complexity</b>: Amortized constant time. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00599">599</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab0f42ef62ee770b718bbeb0726c992ec"></a><!-- doxytag: member="boost::container::slist::push_front" ref="ab0f42ef62ee770b718bbeb0726c992ec" args="(BOOST_MOVE_MACRO_RV_REF(T) x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::push_front </td>
          <td>(</td>
          <td class="paramtype">BOOST_MOVE_MACRO_RV_REF(T)&#160;</td>
          <td class="paramname"> <em>x</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Constructs a new element in the beginning of the list and moves the resources of t to this new element.</p>
<p><b>Throws</b>: If memory allocation throws.</p>
<p><b>Complexity</b>: Amortized constant time. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00616">616</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af34a9bc735684e7d34e1a35f69aeb605"></a><!-- doxytag: member="boost::container::slist::remove" ref="af34a9bc735684e7d34e1a35f69aeb605" args="(const T &amp;value)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::remove </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"> <em>value</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Removes all the elements that compare equal to value.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Linear time. It performs exactly <a class="el" href="classboost_1_1container_1_1slist.html#ace7731b692473cd2d8e98bad96f3a71e">size()</a> comparisons for equality.</p>
<p><b>Note</b>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l01138">1138</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a93e9d031f9196211bea4f517ac51bcd3"></a><!-- doxytag: member="boost::container::slist::remove_if" ref="a93e9d031f9196211bea4f517ac51bcd3" args="(Pred pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
<div class="memtemplate">
template&lt;class Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::remove_if </td>
          <td>(</td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"> <em>pred</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Removes all the elements for which a specified predicate is satisfied.</p>
<p><b>Throws</b>: If pred throws.</p>
<p><b>Complexity</b>: Linear time. It performs exactly <a class="el" href="classboost_1_1container_1_1slist.html#ace7731b692473cd2d8e98bad96f3a71e">size()</a> calls to the predicate.</p>
<p><b>Note</b>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l01151">1151</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6b6f69dfe2ce62c4fb1859c4696e713a"></a><!-- doxytag: member="boost::container::slist::resize" ref="a6b6f69dfe2ce62c4fb1859c4696e713a" args="(size_type new_size, const T &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1slist.html#ac93e9211a0ecddfa243723dce515d12e">size_type</a>&#160;</td>
          <td class="paramname"> <em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"> <em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Inserts or erases elements at the end such that the size becomes n. New elements are copy constructed from x.</p>
<p><b>Throws</b>: If memory allocation throws, or T's copy constructor throws.</p>
<p><b>Complexity</b>: Linear to the difference between <a class="el" href="classboost_1_1container_1_1slist.html#ace7731b692473cd2d8e98bad96f3a71e">size()</a> and new_size. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00924">924</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0429408127f055b47136cc6235785db2"></a><!-- doxytag: member="boost::container::slist::resize" ref="a0429408127f055b47136cc6235785db2" args="(size_type new_size)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1slist.html#ac93e9211a0ecddfa243723dce515d12e">size_type</a>&#160;</td>
          <td class="paramname"> <em>new_size</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Inserts or erases elements at the end such that the size becomes n. New elements are default constructed.</p>
<p><b>Throws</b>: If memory allocation throws, or T's copy constructor throws.</p>
<p><b>Complexity</b>: Linear to the difference between <a class="el" href="classboost_1_1container_1_1slist.html#ace7731b692473cd2d8e98bad96f3a71e">size()</a> and new_size. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00943">943</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aead3367979d00925eea1ca46cb1a6eb4"></a><!-- doxytag: member="boost::container::slist::reverse" ref="aead3367979d00925eea1ca46cb1a6eb4" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::reverse </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Reverses the order of elements in the list.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: This function is linear time.</p>
<p><b>Note</b>: Iterators and references are not invalidated </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l01127">1127</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ace7731b692473cd2d8e98bad96f3a71e"></a><!-- doxytag: member="boost::container::slist::size" ref="ace7731b692473cd2d8e98bad96f3a71e" args="() const " -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classboost_1_1container_1_1slist.html#ac93e9211a0ecddfa243723dce515d12e">size_type</a> <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::size </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td> const<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Returns the number of the elements contained in the list.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Constant. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00542">542</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5b856e750a9b6e9d4813af4d6db2e17f"></a><!-- doxytag: member="boost::container::slist::sort" ref="a5b856e750a9b6e9d4813af4d6db2e17f" args="(StrictWeakOrdering comp)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
<div class="memtemplate">
template&lt;class StrictWeakOrdering &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">StrictWeakOrdering&#160;</td>
          <td class="paramname"> <em>comp</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: This function sorts the list *this according to std::less&lt;value_type&gt;. The sort is stable, that is, the relative order of equivalent elements is preserved.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Notes</b>: Iterators and references are not invalidated.</p>
<p><b>Complexity</b>: The number of comparisons is approximately N log N, where N is the list's size. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l01247">1247</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae77eae4e54a3b5939a6a1ec276abaa38"></a><!-- doxytag: member="boost::container::slist::sort" ref="ae77eae4e54a3b5939a6a1ec276abaa38" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::sort </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: This function sorts the list *this according to std::less&lt;value_type&gt;. The sort is stable, that is, the relative order of equivalent elements is preserved.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Notes</b>: Iterators and references are not invalidated.</p>
<p><b>Complexity</b>: The number of comparisons is approximately N log N, where N is the list's size. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l01234">1234</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5a21930d1e858b266d350c7b4c098e18"></a><!-- doxytag: member="boost::container::slist::splice" ref="a5a21930d1e858b266d350c7b4c098e18" args="(const_iterator p, slist &amp;x, const_iterator first, const_iterator last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::splice </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1slist.html">slist</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: p must point to an element contained by this list. first and last must point to elements contained in list x.</p>
<p><b>Effects</b>: Transfers the range pointed by first and last from list x to this list, before the the element pointed by p. No destructors or copy constructors are called.</p>
<p><b>Throws</b>: std::runtime_error if this' allocator and x's allocator are not equal.</p>
<p><b>Complexity</b>: Linear in distance(<a class="el" href="classboost_1_1container_1_1slist.html#a83778601ebfcbb90c1d17b845a649e1f">begin()</a>, p), in distance(x.begin(), first), and in distance(first, last).</p>
<p><b>Note</b>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l01117">1117</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae34fa1becf9754217369137129f26695"></a><!-- doxytag: member="boost::container::slist::splice" ref="ae34fa1becf9754217369137129f26695" args="(const_iterator p, slist &amp;x, const_iterator i)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::splice </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1slist.html">slist</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: p must point to an element contained by this list. i must point to an element contained in list x.</p>
<p><b>Effects</b>: Transfers the value pointed by i, from list x to this list, before the the element pointed by p. No destructors or copy constructors are called. If p == i or p == ++i, this function is a null operation.</p>
<p><b>Throws</b>: std::runtime_error if this' allocator and x's allocator are not equal.</p>
<p><b>Complexity</b>: Linear in distance(<a class="el" href="classboost_1_1container_1_1slist.html#a83778601ebfcbb90c1d17b845a649e1f">begin()</a>, p), and in distance(x.begin(), i).</p>
<p><b>Note</b>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l01100">1100</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acb75ab5d9b97ccf70e927e7dfd877346"></a><!-- doxytag: member="boost::container::slist::splice" ref="acb75ab5d9b97ccf70e927e7dfd877346" args="(const_iterator p, ThisType &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::splice </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ThisType &amp;&#160;</td>
          <td class="paramname"> <em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: p must point to an element contained by the list. x != *this</p>
<p><b>Effects</b>: Transfers all the elements of list x to this list, before the the element pointed by p. No destructors or copy constructors are called.</p>
<p><b>Throws</b>: std::runtime_error if this' allocator and x's allocator are not equal.</p>
<p><b>Complexity</b>: Linear in distance(<a class="el" href="classboost_1_1container_1_1slist.html#a83778601ebfcbb90c1d17b845a649e1f">begin()</a>, p), and linear in x.size().</p>
<p><b>Note</b>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l01083">1083</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8478921b26695823774873e2b9210d78"></a><!-- doxytag: member="boost::container::slist::splice_after" ref="a8478921b26695823774873e2b9210d78" args="(const_iterator prev_pos, slist &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::splice_after </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>prev_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1slist.html">slist</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: p must point to an element contained by the list. x != *this</p>
<p><b>Effects</b>: Transfers all the elements of list x to this list, after the the element pointed by p. No destructors or copy constructors are called.</p>
<p><b>Throws</b>: std::runtime_error if this' allocator and x's allocator are not equal.</p>
<p><b>Complexity</b>: Linear to the elements in x.</p>
<p><b>Note</b>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00982">982</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa52d95249b51ee315f97e57a79ff3ebe"></a><!-- doxytag: member="boost::container::slist::splice_after" ref="aa52d95249b51ee315f97e57a79ff3ebe" args="(const_iterator prev_pos, slist &amp;x, const_iterator prev)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::splice_after </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>prev_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1slist.html">slist</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>prev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: prev_pos must be a valid iterator of this. i must point to an element contained in list x.</p>
<p><b>Effects</b>: Transfers the value pointed by i, from list x to this list, after the element pointed by prev_pos. If prev_pos == prev or prev_pos == ++prev, this function is a null operation.</p>
<p><b>Throws</b>: std::runtime_error if this' allocator and x's allocator are not equal.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Note</b>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l01006">1006</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac18a9dfbebdc4b4117103a14e232e12d"></a><!-- doxytag: member="boost::container::slist::splice_after" ref="ac18a9dfbebdc4b4117103a14e232e12d" args="(const_iterator prev_pos, slist &amp;x, const_iterator before_first, const_iterator before_last)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::splice_after </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>prev_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1slist.html">slist</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>before_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>before_last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: prev_pos must be a valid iterator of this. before_first and before_last must be valid iterators of x. prev_pos must not be contained in [before_first, before_last) range.</p>
<p><b>Effects</b>: Transfers the range [before_first + 1, before_last + 1) from list x to this list, after the element pointed by prev_pos.</p>
<p><b>Throws</b>: std::runtime_error if this' allocator and x's allocator are not equal.</p>
<p><b>Complexity</b>: Linear to the number of transferred elements.</p>
<p><b>Note</b>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l01030">1030</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a39ed20410525a2047336b2bb29537473"></a><!-- doxytag: member="boost::container::slist::splice_after" ref="a39ed20410525a2047336b2bb29537473" args="(const_iterator prev_pos, slist &amp;x, const_iterator before_first, const_iterator before_last, size_type n)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::splice_after </td>
          <td>(</td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>prev_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1slist.html">slist</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>before_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const_iterator&#160;</td>
          <td class="paramname"> <em>before_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1slist.html#ac93e9211a0ecddfa243723dce515d12e">size_type</a>&#160;</td>
          <td class="paramname"> <em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Requires</b>: prev_pos must be a valid iterator of this. before_first and before_last must be valid iterators of x. prev_pos must not be contained in [before_first, before_last) range. n == std::distance(before_first, before_last)</p>
<p><b>Effects</b>: Transfers the range [before_first + 1, before_last + 1) from list x to this list, after the element pointed by prev_pos.</p>
<p><b>Throws</b>: std::runtime_error if this' allocator and x's allocator are not equal.</p>
<p><b>Complexity</b>: Constant.</p>
<p><b>Note</b>: Iterators of values obtained from list x now point to elements of this list. Iterators of this list and all the references are not invalidated. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l01057">1057</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9e8b4db5db0ec61e560b5c2616892bf3"></a><!-- doxytag: member="boost::container::slist::swap" ref="a9e8b4db5db0ec61e560b5c2616892bf3" args="(slist &amp;x)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classboost_1_1container_1_1slist.html">slist</a>&lt; T, A &gt; &amp;&#160;</td>
          <td class="paramname"> <em>x</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Swaps the contents of *this and x. If this-&gt;<a class="el" href="classboost_1_1container_1_1slist.html#ac85bda0d3cca109416d73067b6a7d1cf" title="The allocator type.">allocator_type()</a> != x.allocator_type() allocators are also swapped.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Linear to the number of elements on *this and x. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l00568">568</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0a3cf376f4df477bee9e6fd913780bff"></a><!-- doxytag: member="boost::container::slist::unique" ref="a0a3cf376f4df477bee9e6fd913780bff" args="()" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::unique </td>
          <td>(</td>
          <td class="paramname">&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Removes adjacent duplicate elements or adjacent elements that are equal from the list.</p>
<p><b>Throws</b>: Nothing.</p>
<p><b>Complexity</b>: Linear time (<a class="el" href="classboost_1_1container_1_1slist.html#ace7731b692473cd2d8e98bad96f3a71e">size()</a>-1 comparisons calls to pred()).</p>
<p><b>Note</b>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l01166">1166</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8f1a249068eda323d8be6b8556231aff"></a><!-- doxytag: member="boost::container::slist::unique" ref="a8f1a249068eda323d8be6b8556231aff" args="(Pred pred)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
<div class="memtemplate">
template&lt;class Pred &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classboost_1_1container_1_1slist.html">boost::container::slist</a>&lt; T, A &gt;::unique </td>
          <td>(</td>
          <td class="paramtype">Pred&#160;</td>
          <td class="paramname"> <em>pred</em>&#160;)</td>
          <td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p><b>Effects</b>: Removes adjacent duplicate elements or adjacent elements that satisfy some binary predicate from the list.</p>
<p><b>Throws</b>: If pred throws.</p>
<p><b>Complexity</b>: Linear time (<a class="el" href="classboost_1_1container_1_1slist.html#ace7731b692473cd2d8e98bad96f3a71e">size()</a>-1 comparisons equality comparisons).</p>
<p><b>Note</b>: The relative order of elements that are not removed is unchanged, and iterators to elements that are not removed remain valid. </p>

<p>Definition at line <a class="el" href="container_2slist_8hpp_source.html#l01179">1179</a> of file <a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="container_2slist_8hpp_source.html">container/slist.hpp</a></li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Apr 27 2011 00:50:13 for Nutcracker by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.2 </small></address>
</body>
</html>
